<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agenda Web</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3b82f6">
    
    <!-- PWA Meta Tags for Android -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="AgendaPWA">
    <meta name="application-name" content="AgendaPWA">
    <meta name="msapplication-TileColor" content="#3b82f6">
    <meta name="msapplication-tap-highlight" content="no">
    
    <!-- Additional PWA optimizations -->
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-config" content="none">
    <meta name="theme-color" content="#3b82f6" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#1e293b" media="(prefers-color-scheme: dark)">

    <style>
        :root {
            /* Modern 3D Color Palette */
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            --success-gradient: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            --warning-gradient: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
            --card-gradient: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%);
            --shadow-light: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-medium: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --shadow-heavy: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            --shadow-inset: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
            --border-3d: 1px solid rgba(255, 255, 255, 0.2);
            --border-3d-dark: 1px solid rgba(0, 0, 0, 0.1);
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-attachment: fixed;
            overscroll-behavior: none;
            min-height: 100vh;
        }

        /* 3D Container Styles */
        .container-3d {
            background: var(--card-gradient);
            border-radius: 20px;
            box-shadow: var(--shadow-heavy);
            border: var(--border-3d);
            position: relative;
            overflow: hidden;
        }

        .container-3d::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
            pointer-events: none;
        }

        /* 3D Button Styles */
        .btn-3d {
            background: linear-gradient(145deg, #ffffff, #f1f5f9);
            border: var(--border-3d-dark);
            border-radius: 12px;
            box-shadow: var(--shadow-medium), var(--shadow-inset);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .btn-3d:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-heavy), var(--shadow-inset);
        }

        .btn-3d:active {
            transform: translateY(0);
            box-shadow: var(--shadow-light), inset 0 4px 8px 0 rgba(0, 0, 0, 0.1);
        }

        .btn-3d::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.3), transparent);
            border-radius: 12px 12px 0 0;
            pointer-events: none;
        }

        /* Primary Button 3D */
        .btn-primary-3d {
            background: var(--primary-gradient);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--shadow-medium), var(--shadow-inset);
        }

        .btn-primary-3d:hover {
            background: linear-gradient(135deg, #5a67d8 0%, #6b46c1 100%);
            transform: translateY(-2px);
        }

        /* Search Box 3D */
        .search-box-3d {
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            border: var(--border-3d-dark);
            border-radius: 16px;
            box-shadow: var(--shadow-medium), var(--shadow-inset);
            transition: all 0.3s ease;
        }

        .search-box-3d:focus {
            box-shadow: var(--shadow-heavy), var(--shadow-inset), 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        /* User Pills 3D */
        .user-pill-3d {
            background: linear-gradient(145deg, #ffffff, #f1f5f9);
            border: var(--border-3d-dark);
            border-radius: 20px;
            box-shadow: var(--shadow-light), var(--shadow-inset);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .user-pill-3d:hover {
            transform: translateY(-1px) scale(1.02);
            box-shadow: var(--shadow-medium), var(--shadow-inset);
        }

        .user-pill-3d.active {
            background: var(--primary-gradient);
            color: white;
            box-shadow: var(--shadow-medium), var(--shadow-inset);
        }

        .user-pill-3d::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50%;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.2), transparent);
            border-radius: 20px 20px 0 0;
            pointer-events: none;
        }

        /* Activity Cards 3D */
        .activity-card-3d {
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            border: var(--border-3d-dark);
            border-radius: 16px;
            box-shadow: var(--shadow-medium), var(--shadow-inset);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .activity-card-3d:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-heavy), var(--shadow-inset);
        }

        /* Time Slot 3D */
        .time-slot-3d {
            background: linear-gradient(145deg, #f8fafc, #e2e8f0);
            border: var(--border-3d-dark);
            border-radius: 12px;
            box-shadow: var(--shadow-light), var(--shadow-inset);
            transition: all 0.2s ease;
        }

        .time-slot-3d:hover {
            box-shadow: var(--shadow-medium), var(--shadow-inset);
        }

        /* Work Section 3D */
        .work-section-3d {
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            border: var(--border-3d-dark);
            border-radius: 8px;
            box-shadow: var(--shadow-light), var(--shadow-inset);
            transition: all 0.2s ease;
        }

        .work-section-3d:hover {
            box-shadow: var(--shadow-medium), var(--shadow-inset);
        }

        /* Modal 3D */
        .modal-3d {
            background: var(--card-gradient);
            border: var(--border-3d);
            border-radius: 24px;
            box-shadow: var(--shadow-heavy);
            backdrop-filter: blur(20px);
        }

        /* Calendar Grid 3D */
        .calendar-day-3d {
            background: linear-gradient(145deg, #ffffff, #f8fafc);
            border: var(--border-3d-dark);
            border-radius: 12px;
            box-shadow: var(--shadow-light), var(--shadow-inset);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .calendar-day-3d:hover {
            transform: translateY(-1px);
            box-shadow: var(--shadow-medium), var(--shadow-inset);
        }

        .calendar-day-3d.today {
            background: var(--primary-gradient);
            color: white;
            box-shadow: var(--shadow-medium), var(--shadow-inset);
        }

        /* Header 3D */
        .header-3d {
            background: var(--card-gradient);
            border-bottom: var(--border-3d);
            box-shadow: var(--shadow-light);
        }

        /* Icon Button 3D */
        .icon-btn-3d {
            background: linear-gradient(145deg, #ffffff, #f1f5f9);
            border: var(--border-3d-dark);
            border-radius: 50%;
            box-shadow: var(--shadow-light), var(--shadow-inset);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .icon-btn-3d:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: var(--shadow-medium), var(--shadow-inset);
        }

        .icon-btn-3d:active {
            transform: translateY(0) scale(0.95);
            box-shadow: var(--shadow-light), inset 0 4px 8px 0 rgba(0, 0, 0, 0.1);
        }

        /* Add User Button 3D */
        .add-user-btn-3d {
            background: var(--success-gradient);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            box-shadow: var(--shadow-medium), var(--shadow-inset);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .add-user-btn-3d:hover {
            transform: translateY(-2px) scale(1.1);
            box-shadow: var(--shadow-heavy), var(--shadow-inset);
        }

        /* Notification 3D */
        .notification-3d {
            background: var(--card-gradient);
            border: var(--border-3d);
            border-radius: 16px;
            box-shadow: var(--shadow-heavy);
            backdrop-filter: blur(20px);
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .container-3d {
                border-radius: 16px;
                margin: 8px;
            }
            
            .btn-3d {
                border-radius: 10px;
            }
            
            .user-pill-3d {
                border-radius: 16px;
            }
        }

        /* Animation keyframes */
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-4px); }
        }

        @keyframes pulse-3d {
            0%, 100% { box-shadow: var(--shadow-medium), var(--shadow-inset); }
            50% { box-shadow: var(--shadow-heavy), var(--shadow-inset); }
        }

        .floating {
            animation: float 3s ease-in-out infinite;
        }

        .pulse-3d {
            animation: pulse-3d 2s ease-in-out infinite;
        }

        /* Icon animations for new icon pack */
        @keyframes lightning {
            0%, 100% { 
                transform: scale(1) rotate(0deg);
                filter: brightness(1) drop-shadow(0 0 5px rgba(255, 255, 0, 0.3));
            }
            25% { 
                transform: scale(1.1) rotate(-2deg);
                filter: brightness(1.3) drop-shadow(0 0 10px rgba(255, 255, 0, 0.6));
            }
            50% { 
                transform: scale(1.2) rotate(0deg);
                filter: brightness(1.5) drop-shadow(0 0 15px rgba(255, 255, 0, 0.8));
            }
            75% { 
                transform: scale(1.1) rotate(2deg);
                filter: brightness(1.3) drop-shadow(0 0 10px rgba(255, 255, 0, 0.6));
            }
        }

        @keyframes rocket {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg) scale(1);
                filter: drop-shadow(0 0 5px rgba(0, 150, 255, 0.3));
            }
            25% { 
                transform: translateY(-3px) rotate(-1deg) scale(1.05);
                filter: drop-shadow(0 0 8px rgba(0, 150, 255, 0.5));
            }
            50% { 
                transform: translateY(-6px) rotate(0deg) scale(1.1);
                filter: drop-shadow(0 0 12px rgba(0, 150, 255, 0.7));
            }
            75% { 
                transform: translateY(-3px) rotate(1deg) scale(1.05);
                filter: drop-shadow(0 0 8px rgba(0, 150, 255, 0.5));
            }
        }

        /* Icon animation classes */
        .icon-lightning {
            animation: lightning 1.5s ease-in-out infinite;
        }

        .icon-rocket {
            animation: rocket 2s ease-in-out infinite;
        }

        /* Original styles continue below */
        /* Touch gesture optimization for mobile */
        #agendaView {
            touch-action: pan-y; /* Allow vertical scrolling but handle horizontal swipes */
        }
        #dateSelectorWheel {
            touch-action: none; /* Disable default touch behaviors for precise swipe control */
        }
        
        /* Date selector wheel improvements */
        .date-wheel-item {
            transition: all 0.3s ease;
            border-radius: 12px;
            font-weight: 500;
        }
        
        .date-wheel-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        /* Ensure date text is properly centered and visible */
        .date-wheel-item {
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1.2;
        }
        
        /* Mobile-specific date selector improvements */
        @media (max-width: 768px) {
            .date-wheel-item {
                min-width: 120px !important; /* Ensure enough space on mobile */
                font-size: 0.875rem; /* Slightly smaller text on mobile */
            }
            
            #currentDate {
                min-width: 150px !important; /* Extra space for current date */
                font-size: 1rem; /* Keep current date readable */
            }
            
            #dateWheelContainer {
                gap: 0.5rem; /* Reduce gap on mobile */
            }
            
            /* Ensure text doesn't wrap on mobile */
            .date-wheel-item {
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            /* Optimize work section labels for mobile */
            .work-section-label {
                width: 38px !important; /* Smaller on mobile */
                font-size: 0.62rem !important;
                padding: 2px 3px !important;
            }
        }
        
        /* Extra small screens */
        @media (max-width: 480px) {
            .date-wheel-item {
                min-width: 100px !important;
                font-size: 0.8rem;
                padding: 0.5rem 0.75rem;
            }
            
            #currentDate {
                min-width: 130px !important;
                font-size: 0.9rem;
            }
            
            /* Optimize work section labels for very small screens */
            .work-section-label {
                width: 35px !important; /* Even smaller on mobile */
                font-size: 0.6rem !important;
                padding: 1px 2px !important;
            }
        }
        
        /* Icon selection modal improvements */
        .icon-selection-modal {
            backdrop-filter: blur(4px);
        }
        
        .icon-selection-modal .bg-white {
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .icon-selection-modal button {
            transition: all 0.2s ease;
        }
        
        .icon-selection-modal button:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }
        
        .icon-selection-modal button:active {
            transform: scale(0.95);
        }
        
        /* Appointment details modal button fixes */
        #editAppointmentBtn,
        #deleteAppointmentFromDetailsBtn {
            pointer-events: auto !important;
            opacity: 1 !important;
            cursor: pointer !important;
            z-index: 10 !important;
            position: relative !important;
        }
        
        #editAppointmentBtn:hover,
        #deleteAppointmentFromDetailsBtn:hover {
            opacity: 0.9 !important;
            transform: translateY(-1px) !important;
        }
        
        #editAppointmentBtn:active,
        #deleteAppointmentFromDetailsBtn:active {
            transform: translateY(0) !important;
        }
        
        /* Ensure modal buttons are always clickable */
        #viewAppointmentDetailsModal .modal-3d {
            z-index: 1000 !important;
        }
        
        #viewAppointmentDetailsModal .flex.justify-between {
            z-index: 1001 !important;
            position: relative !important;
        }
        
        /* Date display styles */
        .date-display-3d {
            background: var(--card-gradient);
            border: var(--border-3d);
            border-radius: 20px;
            box-shadow: var(--shadow-heavy);
            padding: 1rem 1.5rem;
            min-width: 120px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .date-display-3d:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-heavy), 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .date-display-3d .month-abbr {
            color: var(--primary-color, #64748b);
            margin-bottom: 0.25rem;
        }
        
        .date-display-3d .day-number {
            color: var(--primary-color, #1e293b);
            line-height: 1;
            margin: 0.25rem 0;
        }
        
        .date-display-3d .day-abbr {
            color: var(--primary-color, #64748b);
            margin-top: 0.25rem;
        }
        
        /* Mobile responsive date display */
        @media (max-width: 768px) {
            .date-display-3d {
                min-width: 100px;
                padding: 0.75rem 1rem;
            }
            
            .date-display-3d .day-number {
                font-size: 2rem;
            }
        }
        
        @media (max-width: 480px) {
            .date-display-3d {
                min-width: 80px;
                padding: 0.5rem 0.75rem;
            }
            
            .date-display-3d .day-number {
                font-size: 1.75rem;
            }
        }
        .time-slot {
            display: flex;
            flex-direction: column;
            height: 80px; /* Increased height for two sections */
            border: 1px solid #e2e8f0; /* Tailwind slate-200 */
            border-radius: 0.375rem; /* Tailwind rounded-md */
            overflow: hidden; /* Contain segments */
        }
        .time-slot.has-parallel {
            height: auto; /* Allow height to expand for parallel segments */
            min-height: 80px;
        }
        .work-section {
            height: 50%;
            display: flex;
            border-bottom: 1px solid #e2e8f0;
            position: relative;
        }
        .work-section:last-child {
            border-bottom: none;
        }
        .work-section-label {
            width: 40px; /* Reduced from 60px to save space */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.65rem; /* Slightly smaller font */
            font-weight: 600; /* Bolder for better readability */
            background-color: #f8fafc;
            color: #64748b;
            border-right: 1px solid #e2e8f0;
            padding: 2px 4px; /* Minimal padding */
        }
        .work-section-content {
            flex: 1;
            display: flex;
            position: relative;
        }
        .time-segment {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; /* Tailwind text-xs */
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: pointer; /* Clickable cursor */
        }
        .free-segment {
            background-color: #f0f9ff; /* Tailwind sky-50 */
            cursor: pointer; /* Clickable */
            transition: background-color 0.2s;
            color: #0ea5e9; /* Tailwind sky-600 */
        }
        .free-segment:hover {
            background-color: #e0f2fe; /* Tailwind sky-100 */
        }
        .booked-segment {
            padding-left: 4px;
            padding-right: 4px;
            cursor: pointer; /* Clickable to view details */
        }
        .booked-segment:hover {
            filter: brightness(105%); /* Slight brightness increase on hover */
        }
        /* Text color classes based on background brightness */
        .booked-segment.dark-text { 
            color: #1f2937; /* Tailwind gray-800 */
        }
        .booked-segment.light-text { 
            color: #f9fafb; /* Tailwind gray-50 */
        }
        /* Delete button text color classes */
        .booked-segment .delete-btn.dark-text {
             color: #4b5563; /* Tailwind gray-600 */
        }
        .booked-segment .delete-btn.dark-text:hover {
            color: #dc2626; /* Tailwind red-600 */
        }
        .booked-segment .delete-btn.light-text {
            color: #e5e7eb; /* Tailwind gray-200 */
        }
        .booked-segment .delete-btn.light-text:hover {
            color: #fecaca; /* Tailwind red-200 */
        }
        
        /* Parallel segments styling */
        .parallel-container {
            height: auto !important;
            min-height: 40px;
            border-radius: 0.375rem;
            overflow: hidden;
        }
        .parallel-segment {
            height: auto !important;
            min-height: 18px;
            font-size: 0.7rem;
            padding: 2px 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        .parallel-segment:last-child {
            border-bottom: none;
        }
        .parallel-segment:hover {
            filter: brightness(110%);
        }

        /* Modal styles */
        .modal {
            display: none; /* Hidden by default */
        }
        .modal.active {
            display: flex; /* Show when active */
        }
        /* Custom scrollbar styles */
        .agenda-slots-container::-webkit-scrollbar,
        #searchResultsContainer::-webkit-scrollbar {
            width: 8px;
        }
        .agenda-slots-container::-webkit-scrollbar-track,
        #searchResultsContainer::-webkit-scrollbar-track {
            background: #f1f5f9; /* Tailwind slate-100 */
        }
        .agenda-slots-container::-webkit-scrollbar-thumb,
        #searchResultsContainer::-webkit-scrollbar-thumb {
            background: #94a3b8; /* Tailwind slate-400 */
            border-radius: 4px;
        }
        .agenda-slots-container::-webkit-scrollbar-thumb:hover,
        #searchResultsContainer::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* Tailwind slate-500 */
        }
        
        /* Improve touch scrolling on Android */
        .agenda-slots-container {
            -webkit-overflow-scrolling: touch; /* iOS smooth scrolling */
            overscroll-behavior: contain; /* Prevent overscroll effects */
            scroll-behavior: smooth; /* Smooth scrolling */
        }
        
        /* Ensure proper touch handling for agenda containers */
        #agendaSlotsContainer,
        #work1SlotsContainer,
        #work2SlotsContainer {
            touch-action: pan-y; /* Allow vertical scrolling */
        }
        
        /* Color configuration modal scroll fix */
        #colorConfigModal .modal-3d {
            max-height: 90vh; /* Limit height to viewport */
            overflow-y: auto; /* Enable vertical scrolling */
            -webkit-overflow-scrolling: touch; /* iOS smooth scrolling */
            overscroll-behavior: contain; /* Prevent overscroll effects */
        }
        
        /* Ensure color modal content is scrollable on mobile */
        #colorConfigModal {
            align-items: flex-start; /* Align to top instead of center */
            padding-top: 2rem; /* Add top padding */
            padding-bottom: 2rem; /* Add bottom padding */
        }
        
        /* Improve touch scrolling for color modal */
        #colorConfigModal .modal-3d {
            scroll-behavior: smooth; /* Smooth scrolling */
        }
        
        /* Mobile-specific improvements for color modal */
        @media (max-width: 768px) {
            #colorConfigModal .modal-3d {
                max-height: 95vh; /* Use more screen space on mobile */
                margin: 1rem; /* Add margin for better touch experience */
            }
            
            #colorConfigModal {
                padding: 1rem; /* Reduce padding on mobile */
            }
            
            /* Make color pickers more touch-friendly */
            #colorConfigModal input[type="color"] {
                min-height: 44px; /* iOS minimum touch target */
                min-width: 44px;
            }
            
            /* Improve touch targets for sliders */
            #colorConfigModal .relative div[id$="Spectrum"] {
                min-height: 44px; /* Larger touch target */
            }
            
            /* Add scroll indicator for mobile */
            #colorConfigModal .modal-3d::after {
                content: '';
                position: sticky;
                bottom: 0;
                left: 0;
                right: 0;
                height: 20px;
                background: linear-gradient(transparent, rgba(255,255,255,0.8));
                pointer-events: none;
                z-index: 10;
            }
        }
        /* Style for details content in modal */
        .details-content {
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            max-height: 150px; /* Reduced height to ensure buttons are visible */
            overflow-y: auto; /* Add scroll if needed */
            background-color: #f9fafb; /* Tailwind gray-50 */
            border: 1px solid #e5e7eb; /* Tailwind gray-200 */
            padding: 8px;
            border-radius: 0.25rem; /* Tailwind rounded-sm */
        }
        
        /* Ensure appointment details modal buttons are always visible */
        #viewAppointmentDetailsModal .modal-3d {
            max-height: 90vh; /* Limit modal height */
            overflow-y: auto; /* Allow scrolling if needed */
            display: flex;
            flex-direction: column;
        }
        
        #viewAppointmentDetailsModal .flex.justify-between {
            margin-top: auto; /* Push buttons to bottom */
            flex-shrink: 0; /* Prevent buttons from shrinking */
            padding-top: 1rem; /* Add space above buttons */
        }
        
        /* Force button visibility and proper sizing */
        #viewAppointmentDetailsModal button {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
            min-height: 40px !important;
            min-width: 80px !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            border: none !important;
            border-radius: 6px !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
            z-index: 1000 !important;
            position: relative !important;
            pointer-events: auto !important;
            user-select: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
        }
        
        /* Ensure buttons are always on top */
        #viewAppointmentDetailsModal .flex.justify-between {
            position: relative !important;
            z-index: 1001 !important;
        }
        
        /* Prevent any overlay from blocking clicks */
        #viewAppointmentDetailsModal .modal-3d {
            position: relative !important;
            z-index: 1000 !important;
        }
        
        /* Ensure modal backdrop doesn't interfere */
        #viewAppointmentDetailsModal {
            z-index: 999 !important;
        }
        
        /* Add/edit modal z-index */
        #addAppointmentModal {
            z-index: 1000 !important;
        }
        
        /* Ensure modals don't interfere with each other */
        .modal {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
        }
        
        /* Modal button fixes for add/edit modal */
        #addAppointmentModal button {
            pointer-events: auto !important;
            opacity: 1 !important;
            cursor: pointer !important;
            z-index: 1001 !important;
            position: relative !important;
        }
        
        #addAppointmentModal #cancelAddAppointment,
        #addAppointmentModal #saveAppointment {
            display: inline-block !important;
            visibility: visible !important;
            min-height: 40px !important;
            min-width: 80px !important;
            font-size: 14px !important;
            font-weight: 600 !important;
            border: none !important;
            border-radius: 6px !important;
            transition: all 0.2s ease !important;
        }
        
        /* Specific button colors and hover effects */
        #editAppointmentBtn {
            background-color: #eab308 !important; /* yellow-500 */
            color: white !important;
        }
        
        #editAppointmentBtn:hover {
            background-color: #ca8a04 !important; /* yellow-600 */
            transform: translateY(-1px) !important;
        }
        
        #deleteAppointmentFromDetailsBtn {
            background-color: #ef4444 !important; /* red-500 */
            color: white !important;
        }
        
        #deleteAppointmentFromDetailsBtn:hover {
            background-color: #dc2626 !important; /* red-600 */
            transform: translateY(-1px) !important;
        }
        
        
        #closeViewAppointmentDetails {
            background-color: #3b82f6 !important; /* blue-500 */
            color: white !important;
        }
        
        #closeViewAppointmentDetails:hover {
            background-color: #2563eb !important; /* blue-600 */
            transform: translateY(-1px) !important;
        }
        /* Style for search result items */
        .search-result-item {
            border: 1px solid #e5e7eb; /* Tailwind gray-200 */
            border-radius: 0.375rem; /* Tailwind rounded-md */
            padding: 0.75rem; /* Tailwind p-3 */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .search-result-item:hover {
            background-color: #f9fafb; /* Tailwind gray-50 */
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 antialiased">

    <div id="app-container" class="container mx-auto p-4 max-w-4xl">

        <div class="mb-6 p-6 container-3d">
            <div class="flex justify-between items-center mb-3">
                <div class="flex flex-col space-y-3">
                    <div class="flex items-center">
                        <h3 class="text-lg font-semibold text-slate-700">Agenda</h3>
                    </div>
                    
                    <!-- User Pills Selector with Add Button -->
                    <div class="flex flex-wrap gap-2 items-center">
                    <div id="userPillsContainer" class="flex flex-wrap gap-2 items-center">
                        <!-- User pills will be populated here -->
                    </div>
                        <button id="addUserBtn" class="p-3 add-user-btn-3d transition-colors" title="Agregar Usuario">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                            </svg>
                        </button>
                </div>
                </div>
                <button id="configBtn" class="p-3 icon-btn-3d transition-colors" title="Configuración">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.019-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z" />
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                    </svg>
                </button>
                <button id="searchIconBtn" aria-label="Abrir búsqueda de citas" class="p-3 icon-btn-3d transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
                    </svg>
                </button>
            </div>
            <div id="searchBarContainer" class="hidden"> 
                <div class="flex flex-col sm:flex-row items-stretch space-y-3 sm:space-y-0 sm:space-x-3">
                    <input type="text" id="searchInput" placeholder="Buscar por título..." class="flex-grow p-2 border border-slate-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500">
                    <button id="searchAppointmentBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 inline-block mr-1">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
                        </svg>
                        Buscar
                    </button>
                </div>
            </div>
        </div>

        <div class="mb-6 flex justify-center space-x-4">
            <button id="showMonthViewBtn" class="btn-primary-3d font-semibold py-3 px-6 transition duration-150 ease-in-out">Vista Mensual</button>
            <button id="showAgendaViewBtn" class="btn-primary-3d font-semibold py-3 px-6 transition duration-150 ease-in-out" style="background: var(--success-gradient);">Vista Agenda (Hoy)</button>
        </div>

        <div id="monthView" class="container-3d p-6">
            <div class="flex justify-between items-center mb-4">
                <button id="prevMonthBtn" class="text-blue-500 hover:text-blue-700 p-2 rounded-full transition">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                    </svg>
                </button>
                <h2 id="currentMonthYear" class="text-2xl font-bold text-slate-700"></h2>
                <button id="nextMonthBtn" class="text-blue-500 hover:text-blue-700 p-2 rounded-full transition">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                    </svg>
                </button>
            </div>
            <div id="calendarGrid" class="grid grid-cols-7 gap-1 text-center">
                </div>
        </div>

        <div id="agendaView" class="hidden container-3d p-6 mt-6">
            <!-- Date Selector Wheel -->
            <div id="dateSelectorWheel" class="flex justify-center items-center mb-6 p-3 md:p-4 activity-card-3d">
                <div id="currentDateDisplay" class="date-display-3d text-center">
                    <div class="month-abbr text-sm font-medium opacity-70"></div>
                    <div class="day-number text-3xl font-bold"></div>
                    <div class="day-abbr text-sm font-medium opacity-70"></div>
                </div>
            </div>
            <!-- Dual Schedule Container -->
            <div id="dualScheduleContainer" class="hidden">
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div class="text-center">
                        <h4 class="text-md font-semibold text-slate-600 mb-2">💼 Trabajo 1</h4>
                        <div class="flex border-b pb-2 mb-2">
                            <div class="w-1/4 font-semibold text-slate-600 pl-2">Hora</div>
                            <div class="w-3/4 font-semibold text-slate-600 pl-2">Actividad</div>
                        </div>
                        <div id="work1SlotsContainer" class="space-y-1 max-h-[60vh] overflow-y-auto agenda-slots-container pr-2">
                            <!-- Work 1 slots will be populated here -->
                        </div>
                    </div>
                    <div class="text-center">
                        <h4 class="text-md font-semibold text-slate-600 mb-2">🔧 Trabajo 2</h4>
                        <div class="flex border-b pb-2 mb-2">
                            <div class="w-1/4 font-semibold text-slate-600 pl-2">Hora</div>
                            <div class="w-3/4 font-semibold text-slate-600 pl-2">Actividad</div>
                        </div>
                        <div id="work2SlotsContainer" class="space-y-1 max-h-[60vh] overflow-y-auto agenda-slots-container pr-2">
                            <!-- Work 2 slots will be populated here -->
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Single Schedule Container -->
            <div id="singleScheduleContainer" class="activity-card-3d p-4">
                <div class="flex border-b pb-2 mb-2">
                    <div class="w-1/6 font-semibold text-slate-600 pl-2">Hora</div>
                    <div class="w-5/6 font-semibold text-slate-600 pl-2">Actividad</div>
                </div>
                
                <!-- Work Type Legend -->
                <div class="flex justify-center space-x-6 mb-4 text-sm">
                    <div class="flex items-center cursor-pointer hover:bg-slate-100 transition-colors rounded p-2" onclick="showIconSelectionModal('work1')" title="Haz clic para cambiar el icono">
                        <span class="mr-2 icon-lightning" id="work1LegendIcon">⚡</span>
                        <span class="text-slate-600">Trabajo 1</span>
                    </div>
                    <div class="flex items-center cursor-pointer hover:bg-slate-100 transition-colors rounded p-2" onclick="showIconSelectionModal('work2')" title="Haz clic para cambiar el icono">
                        <span class="mr-2 icon-rocket" id="work2LegendIcon">🚀</span>
                        <span class="text-slate-600">Trabajo 2</span>
                    </div>
                </div>
                <div id="agendaSlotsContainer" class="space-y-1 max-h-[70vh] overflow-y-auto agenda-slots-container pr-2">
                    <!-- Time slots will be populated here -->
                </div>
            </div>
        </div>
    </div>

    <div id="addAppointmentModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="modal-3d p-6 w-full max-w-md">
            <h3 id="modalTitle" class="text-xl font-semibold mb-4 text-slate-700">Añadir Nueva Cita</h3>
            
            <!-- Date selector (only shown when editing) -->
            <div id="appointmentDateContainer" class="mb-4 hidden">
                <label for="appointmentDate" class="block text-sm font-medium text-slate-600 mb-1">Fecha:</label>
                <input type="date" id="appointmentDate" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
            </div>
            
            <!-- User transfer selector (only shown when editing) -->
            <div id="appointmentUserContainer" class="mb-4 hidden">
                <label for="appointmentUser" class="block text-sm font-medium text-slate-600 mb-1">Transferir a Usuario:</label>
                <select id="appointmentUser" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white">
                    <option value="">Mantener en usuario actual</option>
                    <!-- User options will be populated here -->
                </select>
            </div>
            
            <div class="mb-4">
                <label for="appointmentTitle" class="block text-sm font-medium text-slate-600 mb-1">Título de la Cita:</label>
                <input type="text" id="appointmentTitle" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
            </div>
            
            <div class="mb-4">
                <label for="appointmentWorkType" class="block text-sm font-medium text-slate-600 mb-1">Tipo de Trabajo:</label>
                <select id="appointmentWorkType" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white">
                    <option value="work1">💼 Trabajo 1</option>
                    <option value="work2">🔧 Trabajo 2</option>
                    <option value="personal">👤 Personal</option>
                    <option value="meeting">👥 Reunión</option>
                </select>
            </div>
            
            <div class="flex space-x-3 mb-4">
                <div class="w-1/2">
                    <label for="appointmentStartHour" class="block text-sm font-medium text-slate-600 mb-1">Hora Inicio:</label>
                    <select id="appointmentStartHour" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white">
                        </select>
                </div>
                <div class="w-1/2">
                    <label for="appointmentStartMinute" class="block text-sm font-medium text-slate-600 mb-1">Minuto Inicio:</label>
                    <select id="appointmentStartMinute" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white">
                        </select>
                </div>
            </div>

            <div class="mb-4">
                <label for="appointmentDuration" class="block text-sm font-medium text-slate-600 mb-1">Duración (minutos):</label>
                <div class="flex items-center space-x-2">
                    <input type="number" id="appointmentDuration" min="1" value="30" class="flex-1 p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                    <button type="button" id="quickDuration30" class="px-3 py-2 text-sm bg-blue-100 hover:bg-blue-200 text-blue-700 font-medium rounded-md transition-colors duration-150 border border-blue-300">
                        30min
                    </button>
                    <button type="button" id="quickDuration60" class="px-3 py-2 text-sm bg-green-100 hover:bg-green-200 text-green-700 font-medium rounded-md transition-colors duration-150 border border-green-300">
                        60min
                    </button>
                </div>
            </div>
            <div class="mb-4">
                <label for="appointmentDetails" class="block text-sm font-medium text-slate-600 mb-1">Detalles (opcional):</label>
                <textarea id="appointmentDetails" rows="3" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500"></textarea>
            </div>
            <p id="appointmentTimeInfo" class="text-sm text-slate-500 mb-4"></p>
            <div class="flex justify-end space-x-3">
                <button id="cancelAddAppointment" class="btn-3d font-medium py-2 px-4 transition" onclick="handleCancelAppointment(event)">Cancelar</button>
                <button id="saveAppointment" class="btn-primary-3d font-semibold py-2 px-4 transition" onclick="handleSaveAppointment(event)">Guardar Cita</button>
            </div>
        </div>
    </div>

    <div id="viewAppointmentDetailsModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="modal-3d p-6 w-full max-w-md">
            <h3 id="viewAppointmentTitle" class="text-xl font-semibold mb-2 text-slate-700"></h3>
            <p id="viewAppointmentTime" class="text-sm text-slate-500 mb-1"></p>
            <p id="viewAppointmentDuration" class="text-sm text-slate-500 mb-3"></p>
            <h4 class="text-md font-semibold text-slate-600 mb-1">Detalles:</h4>
            <div id="viewAppointmentDetailsContent" class="details-content mb-4 text-sm text-slate-700"></div>
            <div class="flex justify-between items-center"> 
                <div>
                    <button id="editAppointmentBtn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-md transition mr-2" onclick="handleEditAppointment(event)">Editar</button>
                    <button id="deleteAppointmentFromDetailsBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md transition" onclick="handleDeleteAppointment(event)">Eliminar</button>
                </div>
                <button id="closeViewAppointmentDetails" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition" onclick="handleCloseDetails(event)">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="searchResultsModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg max-h-[80vh] flex flex-col">
            <h3 class="text-xl font-semibold mb-4 text-slate-700">Resultados de la Búsqueda</h3>
            <div id="searchResultsContainer" class="flex-grow overflow-y-auto space-y-3 mb-4 pr-2">
                </div>
            <div class="flex justify-end">
                <button id="closeSearchResultsModal" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-md transition">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- Add User Modal -->
    <div id="addUserModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="modal-3d p-6 w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4 text-slate-700">Agregar Nuevo Usuario</h3>
            <div class="mb-4">
                <label for="newUserName" class="block text-sm font-medium text-slate-600 mb-1">Nombre del Usuario:</label>
                <input type="text" id="newUserName" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="Ej: María, Juan, etc.">
            </div>
            <div class="mb-4">
                <label for="newUserColor" class="block text-sm font-medium text-slate-600 mb-1">Color de Identificación:</label>
                <div class="flex space-x-2">
                    <input type="color" id="newUserColor" value="#3b82f6" class="w-12 h-10 border border-slate-300 rounded-md cursor-pointer">
                    <div class="flex-1 p-2 border border-slate-300 rounded-md bg-slate-50 text-slate-600 text-sm">
                        Selecciona un color para identificar fácilmente este usuario
                    </div>
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="cancelAddUser" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-medium py-2 px-4 rounded-md transition">Cancelar</button>
                <button id="saveNewUser" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition">Agregar Usuario</button>
            </div>
        </div>
    </div>

    <!-- Edit User Modal -->
    <div id="editUserModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="modal-3d p-6 w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4 text-slate-700">Editar Usuario</h3>
            <div class="mb-4">
                <label for="editUserName" class="block text-sm font-medium text-slate-600 mb-1">Nombre del Usuario:</label>
                <input type="text" id="editUserName" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="Ej: María, Juan, etc.">
            </div>
            <div class="mb-4">
                <label for="editUserColor" class="block text-sm font-medium text-slate-600 mb-1">Color de Identificación:</label>
                <div class="flex space-x-2">
                    <input type="color" id="editUserColor" value="#3b82f6" class="w-12 h-10 border border-slate-300 rounded-md cursor-pointer">
                    <div class="flex-1 p-2 border border-slate-300 rounded-md bg-slate-50 text-slate-600 text-sm">
                        Selecciona un color para identificar fácilmente este usuario
                    </div>
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="cancelEditUser" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-medium py-2 px-4 rounded-md transition">Cancelar</button>
                <button id="saveEditUser" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition">Guardar Cambios</button>
            </div>
        </div>
    </div>

    <!-- Delete User Confirmation Modal -->
    <div id="deleteUserModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="modal-3d p-6 w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4 text-slate-700">Eliminar Usuario</h3>
            <div class="mb-4">
                <div class="flex items-center space-x-3 mb-3">
                    <div id="deleteUserIndicator" class="w-4 h-4 rounded-full"></div>
                    <span id="deleteUserName" class="text-lg font-medium text-slate-700"></span>
                </div>
                <p class="text-slate-600 text-sm">
                    ¿Estás seguro de que quieres eliminar este usuario? Esta acción eliminará permanentemente:
                </p>
                <ul class="list-disc list-inside text-slate-600 text-sm mt-2 ml-4">
                    <li>Todas las citas del usuario</li>
                    <li>El historial de duraciones utilizadas</li>
                    <li>La configuración personal del usuario</li>
                </ul>
                <p class="text-red-600 text-sm font-medium mt-3">
                    ⚠️ Esta acción no se puede deshacer.
                </p>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="cancelDeleteUser" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-medium py-2 px-4 rounded-md transition">Cancelar</button>
                <button id="confirmDeleteUser" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md transition">Eliminar Usuario</button>
            </div>
        </div>
    </div>

    <!-- Color Configuration Modal -->
    <div id="colorConfigModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="modal-3d p-6 w-full max-w-5xl">
            <h3 class="text-xl font-semibold mb-6 text-slate-700">Configuración de Colores</h3>
            
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <!-- Left Column: Gradient Background Configuration -->
                <div class="space-y-6">
                    <h4 class="text-lg font-semibold text-slate-600 mb-4">Gradiente de Fondo</h4>
                    
                    <!-- Color 1 Configuration -->
                    <div class="space-y-3">
                        <label class="block text-sm font-medium text-slate-600">Color Inicial</label>
                        <div class="flex items-center space-x-4">
                            <div class="relative">
                                <div id="color1Preview" class="w-16 h-16 rounded-lg border-2 border-slate-300 cursor-pointer" style="background: #667eea;"></div>
                                <input type="color" id="color1Picker" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" value="#667eea">
                            </div>
                            <div class="flex-1 space-y-2">
                                <div class="relative">
                                    <div id="color1Spectrum" class="w-full h-8 rounded-lg border border-slate-300 cursor-pointer" style="background: linear-gradient(to right, #ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080);"></div>
                                    <div id="color1Marker" class="absolute top-0 w-1 h-full bg-white border border-gray-400 rounded cursor-pointer" style="left: 60%;"></div>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-xs text-slate-500">HEX</label>
                                    <input type="text" id="color1Hex" class="flex-1 p-1 border border-slate-300 rounded text-center font-mono text-xs" value="#667eea">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Color 2 Configuration -->
                    <div class="space-y-3">
                        <label class="block text-sm font-medium text-slate-600">Color Final</label>
                        <div class="flex items-center space-x-4">
                            <div class="relative">
                                <div id="color2Preview" class="w-16 h-16 rounded-lg border-2 border-slate-300 cursor-pointer" style="background: #764ba2;"></div>
                                <input type="color" id="color2Picker" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" value="#764ba2">
                            </div>
                            <div class="flex-1 space-y-2">
                                <div class="relative">
                                    <div id="color2Spectrum" class="w-full h-8 rounded-lg border border-slate-300 cursor-pointer" style="background: linear-gradient(to right, #ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080);"></div>
                                    <div id="color2Marker" class="absolute top-0 w-1 h-full bg-white border border-gray-400 rounded cursor-pointer" style="left: 80%;"></div>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-xs text-slate-500">HEX</label>
                                    <input type="text" id="color2Hex" class="flex-1 p-1 border border-slate-300 rounded text-center font-mono text-xs" value="#764ba2">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Gradient Preview -->
                    <div class="space-y-3">
                        <label class="block text-sm font-medium text-slate-600">Vista Previa</label>
                        <div id="gradientPreview" class="w-full h-24 rounded-lg border-2 border-slate-300 shadow-sm" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
                    </div>

                    <!-- Button Color Configuration -->
                    <div class="space-y-4">
                        <label class="block text-sm font-medium text-slate-600">Colores de Botones</label>
                        
                        <!-- Button Color 1 -->
                        <div class="space-y-2">
                            <label class="block text-sm font-medium text-slate-500">Color Inicial de Botones</label>
                            <div class="flex items-center space-x-3">
                                <input type="color" id="buttonColor1Picker" class="w-12 h-8 border border-slate-300 rounded cursor-pointer">
                                <div class="flex-1 relative">
                                    <div id="buttonColor1Spectrum" class="w-full h-8 rounded-lg cursor-pointer border border-slate-300" style="background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000);"></div>
                                    <div id="buttonColor1Marker" class="absolute top-0 w-2 h-8 bg-white border border-slate-400 rounded cursor-pointer" style="left: 0%;"></div>
                                </div>
                                <input type="text" id="buttonColor1Hex" class="w-20 px-2 py-1 text-sm border border-slate-300 rounded" placeholder="#000000">
                            </div>
                        </div>
                        
                        <!-- Button Color 2 -->
                        <div class="space-y-2">
                            <label class="block text-sm font-medium text-slate-500">Color Final de Botones</label>
                            <div class="flex items-center space-x-3">
                                <input type="color" id="buttonColor2Picker" class="w-12 h-8 border border-slate-300 rounded cursor-pointer">
                                <div class="flex-1 relative">
                                    <div id="buttonColor2Spectrum" class="w-full h-8 rounded-lg cursor-pointer border border-slate-300" style="background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00, #00ffff, #0000ff, #ff00ff, #ff0000);"></div>
                                    <div id="buttonColor2Marker" class="absolute top-0 w-2 h-8 bg-white border border-slate-400 rounded cursor-pointer" style="left: 0%;"></div>
                                </div>
                                <input type="text" id="buttonColor2Hex" class="w-20 px-2 py-1 text-sm border border-slate-300 rounded" placeholder="#000000">
                            </div>
                        </div>
                        
                        <!-- Button Gradient Preview -->
                        <div class="space-y-2">
                            <label class="block text-sm font-medium text-slate-500">Vista Previa de Botones</label>
                            <div id="buttonGradientPreview" class="w-full h-16 rounded-lg border-2 border-slate-300 shadow-sm flex items-center justify-center text-white font-semibold" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                                Botón de Ejemplo
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Column: Text Color Configuration -->
                <div class="space-y-6">
                    <h4 class="text-lg font-semibold text-slate-600 mb-4">Colores de Texto</h4>
                    
                    <!-- Primary Text Color -->
                    <div class="space-y-3">
                        <label class="block text-sm font-medium text-slate-600">Color Principal</label>
                        <div class="flex items-center space-x-4">
                            <div class="relative">
                                <div id="primaryTextPreview" class="w-16 h-16 rounded-lg border-2 border-slate-300 cursor-pointer bg-slate-800 flex items-center justify-center">
                                    <span class="text-white text-sm font-medium">Aa</span>
                                </div>
                                <input type="color" id="primaryTextPicker" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" value="#1f2937">
                            </div>
                            <div class="flex-1 space-y-2">
                                <div class="relative">
                                    <div id="primaryTextSpectrum" class="w-full h-8 rounded-lg border border-slate-300 cursor-pointer" style="background: linear-gradient(to right, #ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080);"></div>
                                    <div id="primaryTextMarker" class="absolute top-0 w-1 h-full bg-white border border-gray-400 rounded cursor-pointer" style="left: 20%;"></div>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-xs text-slate-500">HEX</label>
                                    <input type="text" id="primaryTextHex" class="flex-1 p-1 border border-slate-300 rounded text-center font-mono text-xs" value="#1f2937">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Secondary Text Color -->
                    <div class="space-y-3">
                        <label class="block text-sm font-medium text-slate-600">Color Secundario</label>
                        <div class="flex items-center space-x-4">
                            <div class="relative">
                                <div id="secondaryTextPreview" class="w-16 h-16 rounded-lg border-2 border-slate-300 cursor-pointer bg-slate-500 flex items-center justify-center">
                                    <span class="text-white text-sm font-medium">Aa</span>
                                </div>
                                <input type="color" id="secondaryTextPicker" class="absolute inset-0 w-full h-full opacity-0 cursor-pointer" value="#6b7280">
                            </div>
                            <div class="flex-1 space-y-2">
                                <div class="relative">
                                    <div id="secondaryTextSpectrum" class="w-full h-8 rounded-lg border border-slate-300 cursor-pointer" style="background: linear-gradient(to right, #ff0000, #ff8000, #ffff00, #80ff00, #00ff00, #00ff80, #00ffff, #0080ff, #0000ff, #8000ff, #ff00ff, #ff0080);"></div>
                                    <div id="secondaryTextMarker" class="absolute top-0 w-1 h-full bg-white border border-gray-400 rounded cursor-pointer" style="left: 30%;"></div>
                                </div>
                                <div class="flex items-center space-x-2">
                                    <label class="text-xs text-slate-500">HEX</label>
                                    <input type="text" id="secondaryTextHex" class="flex-1 p-1 border border-slate-300 rounded text-center font-mono text-xs" value="#6b7280">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Text Theme Presets -->
                    <div class="space-y-3">
                        <label class="block text-sm font-medium text-slate-600">Temas de Texto</label>
                        <div class="grid grid-cols-2 gap-3">
                            <button class="text-preset-btn p-3 rounded-lg border-2 border-transparent hover:border-blue-300 transition-colors" data-text-preset="dark">
                                <div class="w-full h-8 rounded mb-2 bg-slate-800 flex items-center justify-center">
                                    <span class="text-white text-sm font-medium">Texto Oscuro</span>
                                </div>
                                <span class="text-xs text-slate-600">Oscuro</span>
                            </button>
                            <button class="text-preset-btn p-3 rounded-lg border-2 border-transparent hover:border-blue-300 transition-colors" data-text-preset="light">
                                <div class="w-full h-8 rounded mb-2 bg-slate-200 flex items-center justify-center">
                                    <span class="text-slate-800 text-sm font-medium">Texto Claro</span>
                                </div>
                                <span class="text-xs text-slate-600">Claro</span>
                            </button>
                        </div>
                    </div>

                    <!-- Live Preview -->
                    <div class="space-y-3">
                        <label class="block text-sm font-medium text-slate-600">Vista Previa del Texto</label>
                        <div id="textPreview" class="p-4 rounded-lg border border-slate-300 shadow-sm" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                            <h5 class="text-lg font-semibold mb-2" style="color: #1f2937;">Título Principal</h5>
                            <p class="text-sm mb-2" style="color: #6b7280;">Texto secundario con información adicional</p>
                            <button class="px-3 py-1 rounded text-sm font-medium shadow-sm" style="background: rgba(255,255,255,0.2); color: #1f2937;">Botón de Ejemplo</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Action Buttons -->
            <div class="flex justify-between mt-8 pt-6 border-t border-slate-200">
                <div class="flex space-x-3">
                    <button id="resetColors" class="btn-3d px-4 py-2 text-sm">Restablecer</button>
                    <button id="applyColors" class="btn-primary-3d px-4 py-2 text-sm">Aplicar Cambios</button>
                </div>
                <button id="closeColorConfig" class="btn-primary-3d px-4 py-2 text-sm">Cerrar</button>
            </div>
        </div>
    </div>

    <script>
        // Global button handlers - must be defined at global scope
        function handleSaveAppointment(event) {
            console.log('=== handleSaveAppointment called ===');
            console.log('Event:', event);
            console.log('Event target:', event.target);
            console.log('Current appointment context:', window.currentAppointmentContext);
            
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            try {
                if (typeof window.saveCurrentAppointment === 'function') {
                    window.saveCurrentAppointment();
                    console.log('saveCurrentAppointment executed successfully');
                } else {
                    console.error('saveCurrentAppointment function not found');
                }
            } catch (error) {
                console.error('Error in saveCurrentAppointment:', error);
            }
        }
        
        function handleCancelAppointment(event) {
            console.log('=== handleCancelAppointment called ===');
            console.log('Event:', event);
            console.log('Event target:', event.target);
            
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            try {
                if (typeof window.closeAddAppointmentModal === 'function') {
                    window.closeAddAppointmentModal();
                    console.log('closeAddAppointmentModal executed successfully');
                } else {
                    console.error('closeAddAppointmentModal function not found');
                }
            } catch (error) {
                console.error('Error in closeAddAppointmentModal:', error);
            }
        }
        
        function handleEditAppointment(event) {
            console.log('=== handleEditAppointment called ===');
            console.log('Event:', event);
            console.log('Event target:', event.target);
            console.log('Appointment context for details:', window.appointmentContextForDetails);
            
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            try {
                if (window.appointmentContextForDetails) { 
                    const apptData = window.appointmentContextForDetails.data;
                    const apptDateKey = window.appointmentContextForDetails.dateKey; 
                    
                    if (typeof window.parseDateKey === 'function' && typeof window.openAddAppointmentModal === 'function') {
                        const dateOfAppointment = window.parseDateKey(apptDateKey); 
                        window.openAddAppointmentModal(dateOfAppointment, apptData.startHour, apptData.startMinute, 0, apptData);
                        window.closeViewAppointmentDetailsModal();
                        console.log('Edit appointment executed successfully');
                    } else {
                        console.error('Required functions not found');
                    }
                } else {
                    console.log('No appointmentContextForDetails available');
                }
            } catch (error) {
                console.error('Error in handleEditAppointment:', error);
            }
        }
        
        function handleDeleteAppointment(event) {
            console.log('=== handleDeleteAppointment called ===');
            console.log('Event:', event);
            console.log('Event target:', event.target);
            console.log('Appointment context for details:', window.appointmentContextForDetails);
            
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            try {
                if (window.appointmentContextForDetails) {
                    if (typeof window.handleDeleteAppointmentFromDetails === 'function') {
                        window.handleDeleteAppointmentFromDetails(window.appointmentContextForDetails.data, window.appointmentContextForDetails.dateKey);
                        console.log('Delete appointment executed successfully');
                    } else {
                        console.error('handleDeleteAppointmentFromDetails function not found');
                    }
                } else {
                    console.log('No appointmentContextForDetails available');
                }
            } catch (error) {
                console.error('Error in handleDeleteAppointment:', error);
            }
        }
        
        function handleCloseDetails(event) {
            console.log('=== handleCloseDetails called ===');
            console.log('Event:', event);
            console.log('Event target:', event.target);
            
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            
            try {
                if (typeof window.closeViewAppointmentDetailsModal === 'function') {
                    window.closeViewAppointmentDetailsModal();
                    console.log('closeViewAppointmentDetailsModal executed successfully');
                } else {
                    console.error('closeViewAppointmentDetailsModal function not found');
                }
            } catch (error) {
                console.error('Error in closeViewAppointmentDetailsModal:', error);
            }
        }
        
        // Make functions globally available
        window.handleSaveAppointment = handleSaveAppointment;
        window.handleCancelAppointment = handleCancelAppointment;
        window.handleEditAppointment = handleEditAppointment;
        window.handleDeleteAppointment = handleDeleteAppointment;
        window.handleCloseDetails = handleCloseDetails;
        
        console.log('Global button handlers defined');
        
        // --- Navigation System for Android Back Button ---
        let navigationStack = [];
        let currentView = 'agenda'; // 'agenda', 'month', 'modal'
        
        function pushNavigationState(view, data = null) {
            navigationStack.push({ view, data, timestamp: Date.now() });
            currentView = view;
            console.log('Navigation pushed:', view, 'Stack:', navigationStack.length);
        }
        
        function popNavigationState() {
            if (navigationStack.length > 1) {
                navigationStack.pop();
                const previousState = navigationStack[navigationStack.length - 1];
                currentView = previousState.view;
                console.log('Navigation popped to:', previousState.view);
                return previousState;
            }
            return null;
        }
        
        function handleBackNavigation() {
            console.log('Back button pressed, current view:', currentView);
            
            // Handle modal states first
            if (currentView === 'modal') {
                // Close any open modals
                const addModal = document.getElementById('addAppointmentModal');
                const detailsModal = document.getElementById('viewAppointmentDetailsModal');
                const colorModal = document.getElementById('colorConfigModal');
                const searchModal = document.getElementById('searchResultsModal');
                
                if (addModal && addModal.classList.contains('active')) {
                    console.log('Closing add/edit modal');
                    closeAddAppointmentModal();
                    return true;
                }
                
                if (detailsModal && detailsModal.classList.contains('active')) {
                    console.log('Closing details modal');
                    closeViewAppointmentDetailsModal();
                    return true;
                }
                
                if (colorModal && colorModal.classList.contains('active')) {
                    console.log('Closing color config modal');
                    closeColorConfigModal();
                    return true;
                }
                
                if (searchModal && searchModal.classList.contains('active')) {
                    console.log('Closing search modal');
                    closeSearchResultsModal();
                    return true;
                }
            }
            
            // Handle view navigation
            const previousState = popNavigationState();
            if (previousState) {
                switch (previousState.view) {
                    case 'agenda':
                        console.log('Navigating back to agenda view');
                        renderAgendaView();
                        updateActiveButtons('agenda');
                        break;
                    case 'month':
                        console.log('Navigating back to month view');
                        renderMonthView();
                        updateActiveButtons('month');
                        break;
                    default:
                        console.log('Navigating back to agenda view (default)');
                        renderAgendaView();
                        updateActiveButtons('agenda');
                        break;
                }
                return true;
            }
            
            // If no previous state, show confirmation to exit
            console.log('No previous state, showing exit confirmation');
            if (confirm('¿Estás seguro de que quieres salir de la aplicación?')) {
                return false; // Allow default behavior (exit app)
            }
            return true; // Prevent default behavior
        }
        
        // Handle Android back button
        window.addEventListener('popstate', function(event) {
            console.log('Popstate event detected');
            event.preventDefault();
            
            if (!handleBackNavigation()) {
                // If handleBackNavigation returns false, allow default behavior
                window.history.back();
            }
        });
        
        // Handle hardware back button on Android
        document.addEventListener('backbutton', function(event) {
            console.log('Hardware back button detected');
            event.preventDefault();
            
            if (!handleBackNavigation()) {
                // If handleBackNavigation returns false, allow default behavior
                navigator.app.exitApp();
            }
        }, false);
        
        // Push initial state
        pushNavigationState('agenda');
        
        console.log('Navigation system initialized');
        
        // --- Application State ---
        let currentDisplayDate = new Date(); // Date for month view
        let selectedAgendaDate = new Date(); // Date for agenda view
        selectedAgendaDate.setHours(0, 0, 0, 0); // Normalize to midnight
        // Multi-user management
        let currentUserId = localStorage.getItem('currentUserId') || 'default';
        let users = JSON.parse(localStorage.getItem('users')) || { 'default': { name: 'Usuario Principal', color: '#3b82f6' } };
        
        // Theme management
        let currentTheme = localStorage.getItem('currentTheme') || 'default';
        let currentTextTheme = localStorage.getItem('currentTextTheme') || 'dark';
        
        // Theme definitions
        const themes = {
            default: {
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
                name: 'Predeterminado'
            },
            ocean: {
                background: 'linear-gradient(135deg, #0ea5e9 0%, #3b82f6 100%)',
                name: 'Océano'
            },
            sunset: {
                background: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
                name: 'Atardecer'
            },
            forest: {
                background: 'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
                name: 'Bosque'
            },
            dark: {
                background: 'linear-gradient(135deg, #2d3748 0%, #4a5568 100%)',
                name: 'Oscuro'
            },
            minimal: {
                background: 'linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%)',
                name: 'Mínimo'
            }
        };
        
        // Appointments stored per user: { userId: { "YYYY-MM-DD": [ { id, title, startHour, startMinute, duration, color, details, workType } ] } }
        let appointments = JSON.parse(localStorage.getItem('appointments')) || {};
        
        // Work types configuration
        const defaultWorkTypes = {
            'work1': { name: 'Trabajo 1', color: '#3b82f6', icon: '⚡' },
            'work2': { name: 'Trabajo 2', color: '#10b981', icon: '🚀' },
            'personal': { name: 'Personal', color: '#f59e0b', icon: '👤' },
            'meeting': { name: 'Reunión', color: '#8b5cf6', icon: '👥' }
        };
        
        // Load work types from localStorage or use defaults
        const workTypes = JSON.parse(localStorage.getItem('workTypes')) || defaultWorkTypes;
        
        // Force update to new default icons
        workTypes['work1'].icon = '⚡';
        workTypes['work2'].icon = '🚀';
        localStorage.setItem('workTypes', JSON.stringify(workTypes));
        
        // Duration usage tracking per user: { userId: { duration: count } }
        let durationUsage = JSON.parse(localStorage.getItem('durationUsage')) || {};
        
        // Color palette for appointments
        const distinctColors = [
            '#EF5350', '#42A5F5', '#66BB6A', '#FFA726', '#AB47BC', 
            '#29B6F6', '#FFEE58', '#26A69A', '#EC407A', '#7E57C2'
        ];
        // Function to determine if a color is light (needs dark text)
        function isColorLight(hexColor) {
            if (!hexColor || hexColor.length < 7) return true; // Default to dark text if color is invalid
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return yiq >= 128;
        }
        let nextColorIndex = parseInt(localStorage.getItem('nextColorIndex') || '0');

        // --- DOM Element References ---
        const monthViewEl = document.getElementById('monthView');
        const agendaViewEl = document.getElementById('agendaView');
        const currentMonthYearEl = document.getElementById('currentMonthYear');
        const calendarGridEl = document.getElementById('calendarGrid');
        const agendaSlotsContainerEl = document.getElementById('agendaSlotsContainer');
        const work1SlotsContainerEl = document.getElementById('work1SlotsContainer');
        const work2SlotsContainerEl = document.getElementById('work2SlotsContainer');
        const dualScheduleContainerEl = document.getElementById('dualScheduleContainer');
        const singleScheduleContainerEl = document.getElementById('singleScheduleContainer');
        // Date Selector Wheel Elements
        const dateSelectorWheelEl = document.getElementById('dateSelectorWheel');
        // Add/Edit Modal Elements
        const addAppointmentModalEl = document.getElementById('addAppointmentModal');
        const modalTitleEl = document.getElementById('modalTitle'); 
        const appointmentDateContainer = document.getElementById('appointmentDateContainer');
        const appointmentDateInput = document.getElementById('appointmentDate');
        const appointmentUserContainer = document.getElementById('appointmentUserContainer');
        const appointmentUserSelect = document.getElementById('appointmentUser');
        const appointmentTitleInput = document.getElementById('appointmentTitle');
        const appointmentWorkTypeSelect = document.getElementById('appointmentWorkType');
        const appointmentStartHourSelect = document.getElementById('appointmentStartHour'); 
        const appointmentStartMinuteSelect = document.getElementById('appointmentStartMinute');
        const appointmentDurationInput = document.getElementById('appointmentDuration');
        const appointmentDetailsInput = document.getElementById('appointmentDetails');
        const appointmentTimeInfoEl = document.getElementById('appointmentTimeInfo');
        const saveAppointmentBtn = document.getElementById('saveAppointment');
        // View Details Modal Elements
        const viewAppointmentDetailsModalEl = document.getElementById('viewAppointmentDetailsModal');
        const viewAppointmentTitleEl = document.getElementById('viewAppointmentTitle');
        const viewAppointmentTimeEl = document.getElementById('viewAppointmentTime');
        const viewAppointmentDurationEl = document.getElementById('viewAppointmentDuration');
        const viewAppointmentDetailsContentEl = document.getElementById('viewAppointmentDetailsContent');
        const editAppointmentBtn = document.getElementById('editAppointmentBtn'); 
        const deleteAppointmentFromDetailsBtn = document.getElementById('deleteAppointmentFromDetailsBtn'); 
        // Search Elements
        const searchIconBtn = document.getElementById('searchIconBtn');
        const searchBarContainer = document.getElementById('searchBarContainer');
        const searchInput = document.getElementById('searchInput');
        const searchAppointmentBtn = document.getElementById('searchAppointmentBtn');
        const searchResultsModalEl = document.getElementById('searchResultsModal');
        const searchResultsContainerEl = document.getElementById('searchResultsContainer');
        const closeSearchResultsModalBtn = document.getElementById('closeSearchResultsModal');
        // User Management Elements
        const userPillsContainer = document.getElementById('userPillsContainer');
        const addUserBtn = document.getElementById('addUserBtn');
        const addUserModalEl = document.getElementById('addUserModal');
        const newUserNameInput = document.getElementById('newUserName');
        const newUserColorInput = document.getElementById('newUserColor');
        const saveNewUserBtn = document.getElementById('saveNewUser');
        const cancelAddUserBtn = document.getElementById('cancelAddUser');
        // Edit User Elements
        const editUserModalEl = document.getElementById('editUserModal');
        const editUserNameInput = document.getElementById('editUserName');
        const editUserColorInput = document.getElementById('editUserColor');
        const saveEditUserBtn = document.getElementById('saveEditUser');
        const cancelEditUserBtn = document.getElementById('cancelEditUser');
        // Delete User Elements
        const deleteUserModalEl = document.getElementById('deleteUserModal');
        const deleteUserIndicator = document.getElementById('deleteUserIndicator');
        const deleteUserName = document.getElementById('deleteUserName');
        const confirmDeleteUserBtn = document.getElementById('confirmDeleteUser');
        const cancelDeleteUserBtn = document.getElementById('cancelDeleteUser');

        // --- Context Variables ---
        // Stores context for adding/editing an appointment
        // { date, initialHour, initialMinute, currentSelectedHour, currentSelectedMinute, currentMaxDuration, editingAppointmentId, originalDateKey }
        let currentAppointmentContext = null; 
        // Stores context for the appointment being viewed in the details modal
        // { data: appointmentData, dateKey: key }
        let appointmentContextForDetails = null;
        
        // Make variables globally available
        window.currentAppointmentContext = currentAppointmentContext;
        window.appointmentContextForDetails = appointmentContextForDetails;
        
        // Touch gesture variables for mobile swipe navigation
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        let touchStartTime = 0;
        const minSwipeDistance = 50; // Minimum distance for a swipe gesture
        
        // User management context
        let userBeingEdited = null;
        let userBeingDeleted = null; 

        // --- Core Application Logic ---

        // Renders the month view calendar
        function renderMonthView() {
            // Update navigation stack
            if (currentView !== 'month') {
                pushNavigationState('month');
            }
            
            monthViewEl.classList.remove('hidden');
            agendaViewEl.classList.add('hidden');
            const year = currentDisplayDate.getFullYear();
            const month = currentDisplayDate.getMonth();
            currentMonthYearEl.textContent = `${currentDisplayDate.toLocaleString('es-ES', { month: 'long' })} ${year}`;
            // Clear previous grid and add headers
            calendarGridEl.innerHTML = `
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">DOM</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">LUN</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">MAR</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">MIÉ</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">JUE</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">VIE</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">SÁB</div>
            `;
            // Calculate calendar grid parameters
            const firstDayOfMonth = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const today = new Date();
            today.setHours(0,0,0,0); // Normalize today to midnight for comparison
            // Add empty cells for days before the 1st of the month
            for (let i = 0; i < firstDayOfMonth; i++) {
                calendarGridEl.appendChild(document.createElement('div'));
            }
            // Add cells for each day of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayCell = document.createElement('div');
                dayCell.textContent = day;
                dayCell.classList.add('py-2', 'sm:py-3', 'cursor-pointer', 'hover:bg-blue-100', 'rounded-full', 'transition-colors', 'duration-150', 'flex', 'items-center', 'justify-center', 'text-sm', 'sm:text-base');
                const cellDate = new Date(year, month, day);
                // Highlight today's date
                if (cellDate.getTime() === today.getTime()) {
                    dayCell.classList.add('bg-blue-500', 'text-white', 'font-semibold');
                    dayCell.classList.remove('hover:bg-blue-100');
                } else {
                    dayCell.classList.add('text-slate-700');
                }
                // Add dot indicator if there are appointments on this day
                const dateKey = formatDateKey(cellDate);
                const userAppointments = getCurrentUserAppointments();
                if (userAppointments[dateKey] && userAppointments[dateKey].length > 0) {
                    const dot = document.createElement('span');
                    dot.classList.add('h-1.5', 'w-1.5', 'bg-green-500', 'rounded-full', 'ml-1', 'inline-block', 'align-middle');
                     if (cellDate.getTime() === today.getTime()) { // Use white dot on today's highlight
                        dot.classList.remove('bg-green-500');
                        dot.classList.add('bg-white');
                    }
                    dayCell.appendChild(dot);
                }
                // Add click listener to switch to agenda view for this day
                dayCell.addEventListener('click', () => {
                    selectedAgendaDate = new Date(year, month, day);
                    selectedAgendaDate.setHours(0,0,0,0);
                    renderAgendaView();
                });
                calendarGridEl.appendChild(dayCell);
            }
        }

        // Renders the daily agenda view
        function renderAgendaView() {
            // Update navigation stack
            if (currentView !== 'agenda') {
                pushNavigationState('agenda');
            }
            
            monthViewEl.classList.add('hidden');
            agendaViewEl.classList.remove('hidden');
            updateDateSelectorWheel(); // Update the date selector wheel
            
            const dateKey = formatDateKey(selectedAgendaDate);
            const userAppointments = getCurrentUserAppointments();
            const dailyAppointments = (userAppointments[dateKey] || []).sort((a, b) => {
                if (a.startHour === b.startHour) return a.startMinute - b.startMinute;
                return a.startHour - b.startHour;
            });
            
            // Hide the dual container and show the single container
                dualScheduleContainerEl.classList.add('hidden');
                singleScheduleContainerEl.classList.remove('hidden');
                
            // Clear the main agenda container
            agendaSlotsContainerEl.innerHTML = '';
            
            // Create a row for each hour (0-23)
            for (let hour = 0; hour < 24; hour++) {
                const hourRow = document.createElement('div');
                hourRow.classList.add('flex', 'items-stretch', 'min-h-[80px]', 'border-b', 'border-slate-200');
                
                // Hour Label Column
                const hourLabel = document.createElement('div');
                hourLabel.classList.add('w-1/6', 'py-2', 'pr-2', 'text-sm', 'text-slate-600', 'flex', 'items-center', 'border-r', 'border-slate-200', 'bg-slate-50');
                hourLabel.textContent = `${String(hour).padStart(2, '0')}:00`;
                hourRow.appendChild(hourLabel);
                
                // Time Slot Bar Column (contains both work sections)
                const timeSlotBar = document.createElement('div');
                timeSlotBar.classList.add('w-5/6', 'pl-2', 'py-1');
                timeSlotBar.classList.add('time-slot', 'time-slot-3d');
                
                // Populate the time slot bar with both work sections
                populateTimeSlotBar(timeSlotBar, hour, dailyAppointments);
                
                hourRow.appendChild(timeSlotBar);
                agendaSlotsContainerEl.appendChild(hourRow);
            }
        }


        // Updates the date selector wheel with current, previous, and next dates
        function updateDateSelectorWheel() {
            const monthAbbr = selectedAgendaDate.toLocaleDateString('es-ES', { month: 'short' });
            const dayNumber = selectedAgendaDate.getDate();
            const dayAbbr = selectedAgendaDate.toLocaleDateString('es-ES', { weekday: 'short' });
            
            // Update the new date display
            const monthElement = document.querySelector('.month-abbr');
            const dayElement = document.querySelector('.day-number');
            const dayAbbrElement = document.querySelector('.day-abbr');
            
            if (monthElement) monthElement.textContent = monthAbbr;
            if (dayElement) dayElement.textContent = dayNumber;
            if (dayAbbrElement) dayAbbrElement.textContent = dayAbbr;
            
            // Apply theme colors
            applyDateDisplayTheme();
        }
        
        // Apply theme colors to date display
        function applyDateDisplayTheme() {
            const dateDisplay = document.querySelector('.date-display-3d');
            if (!dateDisplay) return;
            
            // Get current theme colors
            const primaryColor = localStorage.getItem('primaryTextColor') || '#1f2937';
            const secondaryColor = localStorage.getItem('secondaryTextColor') || '#6b7280';
            
            // Apply colors to date display elements
            const monthAbbr = dateDisplay.querySelector('.month-abbr');
            const dayNumber = dateDisplay.querySelector('.day-number');
            const dayAbbr = dateDisplay.querySelector('.day-abbr');
            
            if (monthAbbr) monthAbbr.style.color = secondaryColor;
            if (dayNumber) dayNumber.style.color = primaryColor;
            if (dayAbbr) dayAbbr.style.color = secondaryColor;
            
            // Apply background gradient if custom theme is active
            const customTheme = localStorage.getItem('customTheme');
            if (customTheme) {
                const theme = JSON.parse(customTheme);
                dateDisplay.style.background = `linear-gradient(135deg, ${theme.color1} 0%, ${theme.color2} 100%)`;
                
                // Adjust text colors for better contrast
                if (monthAbbr) monthAbbr.style.color = 'rgba(255, 255, 255, 0.8)';
                if (dayNumber) dayNumber.style.color = 'white';
                if (dayAbbr) dayAbbr.style.color = 'rgba(255, 255, 255, 0.8)';
            } else {
                // Reset to default gradient
                dateDisplay.style.background = 'var(--card-gradient)';
            }
        }
        
        // Navigate to a different date
        function navigateToDate(targetDate) {
            selectedAgendaDate = new Date(targetDate);
            selectedAgendaDate.setHours(0, 0, 0, 0);
            renderAgendaView();
        }
        
        // Touch gesture handling functions
        function handleTouchStart(event) {
            // Only handle touch events when agenda view is active
            if (agendaViewEl.classList.contains('hidden')) return;
            
            const firstTouch = event.touches[0];
            touchStartX = firstTouch.clientX;
            touchStartY = firstTouch.clientY;
            
            // Store initial touch time for better gesture detection
            touchStartTime = Date.now();
        }
        
        function handleTouchMove(event) {
            // Only prevent default for horizontal swipes, allow vertical scrolling
            if (!agendaViewEl.classList.contains('hidden')) {
                const currentTouch = event.touches[0];
                const deltaX = Math.abs(currentTouch.clientX - touchStartX);
                const deltaY = Math.abs(currentTouch.clientY - touchStartY);
                
                // Only prevent default if it's clearly a horizontal swipe
                // Allow vertical scrolling by not preventing default for vertical movements
                if (deltaX > deltaY && deltaX > 10) {
                    event.preventDefault();
                }
            }
        }
        
        function handleTouchEnd(event) {
            // Only handle touch events when agenda view is active
            if (agendaViewEl.classList.contains('hidden')) return;
            
            const lastTouch = event.changedTouches[0];
            touchEndX = lastTouch.clientX;
            touchEndY = lastTouch.clientY;
            
            handleSwipeGesture();
        }
        
        function handleSwipeGesture() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            const deltaTime = Date.now() - touchStartTime;
            
            // Check if it's a horizontal swipe (more horizontal than vertical and significant distance)
            // Also check that the gesture was quick enough to be intentional
            if (Math.abs(deltaX) > Math.abs(deltaY) && 
                Math.abs(deltaX) > minSwipeDistance && 
                deltaTime < 500) { // Max 500ms for swipe gesture
                if (deltaX > 0) {
                    // Swipe right - go to previous date
                    const prevDate = new Date(selectedAgendaDate);
                    prevDate.setDate(prevDate.getDate() - 1);
                    navigateToDate(prevDate);
                } else {
                    // Swipe left - go to next date
                    const nextDate = new Date(selectedAgendaDate);
                    nextDate.setDate(nextDate.getDate() + 1);
                    navigateToDate(nextDate);
                }
            }
        }

        // Populates a single hour's time slot bar with two work sections
        function populateTimeSlotBar(timeSlotBar, hour, dailyAppointments) {
            // Clear any existing content
            timeSlotBar.innerHTML = '';
            
            // Create Work 1 section
            const work1Section = createWorkSection('work1', hour, dailyAppointments);
            timeSlotBar.appendChild(work1Section);
            
            // Create Work 2 section
            const work2Section = createWorkSection('work2', hour, dailyAppointments);
            timeSlotBar.appendChild(work2Section);
        }

        // Creates a work section (Work 1 or Work 2) for a specific hour
        function createWorkSection(workType, hour, dailyAppointments) {
            const workSection = document.createElement('div');
            workSection.classList.add('work-section', 'work-section-3d');
            workSection.dataset.workType = workType;
            workSection.dataset.hour = hour;
            
            // Create label
            const label = document.createElement('div');
            label.classList.add('work-section-label');
            label.textContent = workType === 'work1' ? 'T1' : 'T2';
            workSection.appendChild(label);
            
            // Create content area
            const content = document.createElement('div');
            content.classList.add('work-section-content');
            
            // Filter appointments for this work type
            const workAppointments = dailyAppointments.filter(appt => appt.workType === workType);
            
            // Find appointments that overlap with this hour
            const appointmentsInThisHour = [];
            workAppointments.forEach(appt => {
                const apptStartTotalMinutes = appt.startHour * 60 + appt.startMinute;
                const apptEndTotalMinutes = apptStartTotalMinutes + appt.duration;
                const hourStartTotalMinutes = hour * 60;
                const hourEndTotalMinutes = (hour + 1) * 60;
                
                // Check for overlap
                if (apptStartTotalMinutes < hourEndTotalMinutes && apptEndTotalMinutes > hourStartTotalMinutes) {
                    // Calculate the portion of the appointment within this hour
                    const startMinuteInSlot = Math.max(0, apptStartTotalMinutes - hourStartTotalMinutes);
                    const endMinuteInSlot = Math.min(60, apptEndTotalMinutes - hourStartTotalMinutes);
                    const durationInSlot = endMinuteInSlot - startMinuteInSlot;
                    if (durationInSlot > 0) {
                        appointmentsInThisHour.push({...appt, displayStartMinute: startMinuteInSlot, displayDuration: durationInSlot});
                    }
                }
            });
            
            // Sort appointments by start time
            appointmentsInThisHour.sort((a,b) => a.displayStartMinute - b.displayStartMinute);
            
            // Create segments for this work section
            let currentMinuteInHour = 0;
            
            appointmentsInThisHour.forEach(appt => {
                // Add free segment before this appointment if there's a gap
                if (appt.displayStartMinute > currentMinuteInHour) {
                    const freeDuration = appt.displayStartMinute - currentMinuteInHour;
                    content.appendChild(createTimeSegment(hour, currentMinuteInHour, freeDuration, true, null, workType));
                }
                
                // Add the appointment segment
                content.appendChild(createTimeSegment(hour, appt.displayStartMinute, appt.displayDuration, false, appt, workType));
                
                currentMinuteInHour = appt.displayStartMinute + appt.displayDuration;
            });
            
            // Add remaining free segment at the end of the hour if needed
            if (currentMinuteInHour < 60) {
                const freeDuration = 60 - currentMinuteInHour;
                content.appendChild(createTimeSegment(hour, currentMinuteInHour, freeDuration, true, null, workType));
            }
            
            workSection.appendChild(content);
            return workSection;
        }

        // Groups appointments that occur simultaneously
        function groupSimultaneousAppointments(appointments) {
            const blocks = [];
            let currentBlock = null;
            
            appointments.forEach(appt => {
                if (!currentBlock) {
                    // Start new block
                    currentBlock = {
                        startMinute: appt.displayStartMinute,
                        endMinute: appt.displayStartMinute + appt.displayDuration,
                        duration: appt.displayDuration,
                        appointments: [appt]
                    };
                } else {
                    // Check if this appointment overlaps with current block
                    const apptEndMinute = appt.displayStartMinute + appt.displayDuration;
                    if (appt.displayStartMinute < currentBlock.endMinute && apptEndMinute > currentBlock.startMinute) {
                        // Overlaps - add to current block
                        currentBlock.appointments.push(appt);
                        currentBlock.startMinute = Math.min(currentBlock.startMinute, appt.displayStartMinute);
                        currentBlock.endMinute = Math.max(currentBlock.endMinute, apptEndMinute);
                        currentBlock.duration = currentBlock.endMinute - currentBlock.startMinute;
                    } else {
                        // No overlap - finish current block and start new one
                        blocks.push(currentBlock);
                        currentBlock = {
                            startMinute: appt.displayStartMinute,
                            endMinute: appt.displayStartMinute + appt.displayDuration,
                            duration: appt.displayDuration,
                            appointments: [appt]
                        };
                    }
                }
            });
            
            if (currentBlock) {
                blocks.push(currentBlock);
            }
            
            return blocks;
        }

        // Creates parallel segments for simultaneous appointments
        function createParallelTimeSegment(hour, startMinuteOffset, durationMinutes, appointments) {
            const container = document.createElement('div');
            container.classList.add('time-segment', 'parallel-container');
            container.style.width = `${(durationMinutes / 60) * 100}%`;
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.gap = '1px';
            
            // Create individual segments for each appointment
            appointments.forEach((appointmentData, index) => {
                const segment = document.createElement('div');
                segment.classList.add('time-segment', 'parallel-segment');
                segment.style.flex = '1';
                segment.style.minHeight = '18px'; // Minimum height for readability
                
                // Apply appointment styling
                const bgColor = appointmentData.color || '#EF5350';
                segment.style.backgroundColor = bgColor;
                
                // Adjust text color based on background brightness
                if (isColorLight(bgColor)) {
                    segment.classList.add('dark-text');
                    segment.classList.remove('light-text');
                } else {
                    segment.classList.add('light-text');
                    segment.classList.remove('dark-text');
                }
                
                // Add work type icon and title
                if (appointmentData.workType && workTypes[appointmentData.workType]) {
                    const workTypeIcon = workTypes[appointmentData.workType].icon;
                    segment.textContent = `${workTypeIcon} ${appointmentData.title}`;
                } else {
                    segment.textContent = appointmentData.title;
                }
                
                // Tooltip with full details
                const startTimeStr = `${String(appointmentData.startHour).padStart(2, '0')}:${String(appointmentData.startMinute).padStart(2, '0')}`;
                const endTimeStr = formatEndTime(appointmentData.startHour, appointmentData.startMinute, appointmentData.duration);
                const workTypeName = appointmentData.workType && workTypes[appointmentData.workType] ? workTypes[appointmentData.workType].name : 'Sin tipo';
                segment.title = `${appointmentData.title} (${workTypeName}) - ${startTimeStr} a ${endTimeStr} (${appointmentData.duration}m). Haz clic para ver detalles.`;
                
                // Click listener to open the view details modal
                segment.addEventListener('click', (e) => {
                    e.stopPropagation();
                    openViewAppointmentDetailsModal(appointmentData, formatDateKey(selectedAgendaDate));
                });
                
                // Add delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '&times;';
                deleteBtn.classList.add('delete-btn');
                deleteBtn.style.position = 'absolute';
                deleteBtn.style.right = '2px';
                deleteBtn.style.top = '2px';
                deleteBtn.style.background = 'rgba(0,0,0,0.3)';
                deleteBtn.style.border = 'none';
                deleteBtn.style.borderRadius = '50%';
                deleteBtn.style.width = '16px';
                deleteBtn.style.height = '16px';
                deleteBtn.style.fontSize = '12px';
                deleteBtn.style.cursor = 'pointer';
                deleteBtn.style.color = 'white';
                deleteBtn.style.display = 'none';
                
                // Show delete button on hover
                segment.addEventListener('mouseenter', () => {
                    deleteBtn.style.display = 'block';
                });
                segment.addEventListener('mouseleave', () => {
                    deleteBtn.style.display = 'none';
                });
                
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm(`¿Eliminar cita "${appointmentData.title}"?`)) {
                        deleteAppointment(appointmentData.id, formatDateKey(selectedAgendaDate));
                    }
                });
                
                segment.style.position = 'relative';
                segment.appendChild(deleteBtn);
                container.appendChild(segment);
            });
            
            return container;
        }

        // Available icons for work types
        const availableIcons = [
            '💼', '🔧', '📝', '📊', '📈', '📋', '📌', '📎', '✂️', '📏',
            '🔍', '💡', '⚡', '🔥', '⭐', '🌟', '💎', '🎯', '🏆', '🎖️',
            '👤', '👥', '👨‍💼', '👩‍💼', '👨‍🔧', '👩‍🔧', '👨‍⚕️', '👩‍⚕️', '👨‍🎓', '👩‍🎓',
            '🏥', '🏢', '🏭', '🏪', '🏬', '🏫', '🏩', '🏨', '🏦', '🏧',
            '🚗', '🚕', '🚙', '🚌', '🚎', '🏎️', '🚓', '🚑', '🚒', '🚐',
            '📱', '💻', '🖥️', '⌨️', '🖱️', '🖨️', '📞', '☎️', '📠', '📺',
            '🎨', '🎭', '🎪', '🎯', '🎲', '🎮', '🕹️', '🎸', '🎹', '🎺',
            '🍎', '🍊', '🍋', '🍌', '🍉', '🍇', '🍓', '🍈', '🍒', '🍑',
            '⚽', '🏀', '🏈', '⚾', '🎾', '🏐', '🏉', '🎱', '🏓', '🏸'
        ];

        // Show icon selection modal
        function showIconSelectionModal(workType) {
            // Remove any existing modal first
            const existingModal = document.querySelector('.icon-selection-modal');
            if (existingModal) {
                existingModal.remove();
            }
            
            const modal = document.createElement('div');
            modal.classList.add('icon-selection-modal', 'fixed', 'inset-0', 'bg-black', 'bg-opacity-50', 'flex', 'items-center', 'justify-center', 'z-50');
            
            const modalContent = document.createElement('div');
            modalContent.classList.add('bg-white', 'rounded-lg', 'p-6', 'max-w-2xl', 'w-full', 'mx-4', 'max-h-96', 'overflow-y-auto');
            
            modalContent.innerHTML = `
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold">Seleccionar Icono para ${workTypes[workType].name}</h3>
                    <button class="text-gray-500 hover:text-gray-700 text-xl" onclick="closeIconModal()">&times;</button>
                </div>
                <div class="grid grid-cols-10 gap-2" id="iconGrid">
                    ${availableIcons.map(icon => `
                        <button class="p-2 text-2xl hover:bg-gray-100 rounded border-2 border-transparent hover:border-blue-300 transition-colors" 
                                onclick="selectIcon('${workType}', '${icon}')" 
                                title="${icon}">
                            ${icon}
                        </button>
                    `).join('')}
                </div>
            `;
            
            modal.appendChild(modalContent);
            document.body.appendChild(modal);
            
            // Close modal when clicking outside
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    closeIconModal();
                }
            });
            
            // Prevent body scroll when modal is open
            document.body.style.overflow = 'hidden';
        }
        
        // Close icon selection modal
        function closeIconModal() {
            const modal = document.querySelector('.icon-selection-modal');
            if (modal) {
                modal.remove();
                // Restore body scroll
                document.body.style.overflow = '';
            }
        }

        // Select icon for work type
        function selectIcon(workType, icon) {
            // Update workTypes configuration
            workTypes[workType].icon = icon;
            
            // Save to localStorage
            localStorage.setItem('workTypes', JSON.stringify(workTypes));
            
            // Update the display
            updateWorkTypeIcons();
            
            // Close modal properly
            closeIconModal();
            
            // Show success message
            showNotification(`Icono actualizado para ${workTypes[workType].name}: ${icon}`);
        }

        // Update work type icons in the interface
        function updateWorkTypeIcons() {
            // Update legend icons
            const work1LegendIcon = document.getElementById('work1LegendIcon');
            const work2LegendIcon = document.getElementById('work2LegendIcon');
            
            if (work1LegendIcon) {
                work1LegendIcon.textContent = workTypes['work1'].icon;
                work1LegendIcon.className = 'mr-2 icon-lightning';
            }
            if (work2LegendIcon) {
                work2LegendIcon.textContent = workTypes['work2'].icon;
                work2LegendIcon.className = 'mr-2 icon-rocket';
            }
            
            // Update header icons in dual schedule view
            const work1Header = document.querySelector('#dualScheduleContainer h4:first-child');
            const work2Header = document.querySelector('#dualScheduleContainer h4:last-child');
            
            if (work1Header) {
                work1Header.innerHTML = `${workTypes['work1'].icon} Trabajo 1`;
            }
            if (work2Header) {
                work2Header.innerHTML = `${workTypes['work2'].icon} Trabajo 2`;
            }
            
            // Update select options
            const work1Option = document.querySelector('option[value="work1"]');
            const work2Option = document.querySelector('option[value="work2"]');
            
            if (work1Option) {
                work1Option.innerHTML = `${workTypes['work1'].icon} Trabajo 1`;
            }
            if (work2Option) {
                work2Option.innerHTML = `${workTypes['work2'].icon} Trabajo 2`;
            }
            
            // Update appointment segments
            document.querySelectorAll('.booked-segment').forEach(segment => {
                const workTypeIcon = segment.querySelector('.work-type-icon');
                if (workTypeIcon) {
                    const workType = workTypeIcon.dataset.workType;
                    if (workType && workTypes[workType]) {
                        workTypeIcon.textContent = workTypes[workType].icon;
                        
                        // Update animation classes
                        workTypeIcon.className = 'work-type-icon';
                        if (workType === 'work1') {
                            workTypeIcon.classList.add('icon-lightning');
                        } else if (workType === 'work2') {
                            workTypeIcon.classList.add('icon-rocket');
                        }
                    }
                }
            });
            
            // Force re-render of agenda view to update all icons
            if (!document.getElementById('agendaView').classList.contains('hidden')) {
                renderAgendaView();
            }
        }

        // Show notification
        function showNotification(message) {
            const notification = document.createElement('div');
            notification.classList.add('fixed', 'top-4', 'right-4', 'bg-green-500', 'text-white', 'px-4', 'py-2', 'rounded-lg', 'shadow-lg', 'z-50');
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Color spectrum slider functions
        function setupColorSpectrumSlider(spectrumId, markerId, colorId) {
            const spectrum = document.getElementById(spectrumId);
            const marker = document.getElementById(markerId);
            const preview = document.getElementById(`${colorId}Preview`);
            const hexInput = document.getElementById(`${colorId}Hex`);
            const picker = document.getElementById(`${colorId}Picker`);
            
            if (!spectrum || !marker) return;
            
            // Click on spectrum to select color
            spectrum.addEventListener('click', (e) => {
                const rect = spectrum.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percentage = (x / rect.width) * 100;
                
                // Convert percentage to hue (0-360)
                const hue = (percentage / 100) * 360;
                const color = hslToHex(hue, 100, 50);
                
                updateColorFromSlider(colorId, color, percentage);
            });
            
            // Drag marker
            let isDragging = false;
            
            marker.addEventListener('mousedown', (e) => {
                isDragging = true;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const rect = spectrum.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percentage = Math.max(0, Math.min(100, (x / rect.width) * 100));
                
                const hue = (percentage / 100) * 360;
                const color = hslToHex(hue, 100, 50);
                
                updateColorFromSlider(colorId, color, percentage);
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
            
            // Update from color picker
            if (picker) {
                picker.addEventListener('input', (e) => {
                    const color = e.target.value;
                    const hue = hexToHue(color);
                    const percentage = (hue / 360) * 100;
                    updateColorFromSlider(colorId, color, percentage);
                });
            }
            
            // Update from hex input
            if (hexInput) {
                hexInput.addEventListener('input', (e) => {
                    if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
                        const color = e.target.value;
                        const hue = hexToHue(color);
                        const percentage = (hue / 360) * 100;
                        updateColorFromSlider(colorId, color, percentage);
                    }
                });
                
                // Also update preview on blur (when user finishes typing)
                hexInput.addEventListener('blur', (e) => {
                    if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
                        const color = e.target.value;
                        const hue = hexToHue(color);
                        const percentage = (hue / 360) * 100;
                        updateColorFromSlider(colorId, color, percentage);
                    }
                });
            }
        }
        
        function updateColorFromSlider(colorId, color, percentage) {
            const preview = document.getElementById(`${colorId}Preview`);
            const hexInput = document.getElementById(`${colorId}Hex`);
            const picker = document.getElementById(`${colorId}Picker`);
            const marker = document.getElementById(`${colorId}Marker`);
            
            if (preview) preview.style.background = color;
            if (hexInput) hexInput.value = color;
            if (picker) picker.value = color;
            if (marker) marker.style.left = `${percentage}%`;
            
            // Update previews
            if (colorId === 'color1' || colorId === 'color2') {
                updateGradientPreview();
            }
            if (colorId === 'primaryText' || colorId === 'secondaryText') {
                updateTextPreview();
            }
            if (colorId === 'buttonColor1' || colorId === 'buttonColor2') {
                updateButtonGradientPreview();
            }
        }
        
        function hslToHex(h, s, l) {
            h = h / 360;
            s = s / 100;
            l = l / 100;
            
            const hue2rgb = (p, q, t) => {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1/6) return p + (q - p) * 6 * t;
                if (t < 1/2) return q;
                if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                return p;
            };
            
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            
            const toHex = (c) => {
                const hex = Math.round(c * 255).toString(16);
                return hex.length === 1 ? '0' + hex : hex;
            };
            
            return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
        }
        
        function hexToHue(hex) {
            const rgb = hexToRgb(hex);
            if (!rgb) return 0;
            
            const { r, g, b } = rgb;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const diff = max - min;
            
            let h = 0;
            if (diff !== 0) {
                if (max === r) {
                    h = ((g - b) / diff) % 6;
                } else if (max === g) {
                    h = (b - r) / diff + 2;
                } else {
                    h = (r - g) / diff + 4;
                }
            }
            
            return (h * 60 + 360) % 360;
        }

        // Advanced Theme management functions
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }

        function updateColorPreview(colorId, hex) {
            const preview = document.getElementById(`${colorId}Preview`);
            const picker = document.getElementById(`${colorId}Picker`);
            const rgb = hexToRgb(hex);
            
            if (preview) preview.style.background = hex;
            if (picker) picker.value = hex;
            
            if (rgb) {
                document.getElementById(`${colorId}R`).value = rgb.r;
                document.getElementById(`${colorId}G`).value = rgb.g;
                document.getElementById(`${colorId}B`).value = rgb.b;
                document.getElementById(`${colorId}Hex`).value = hex;
            }
        }

        function updateGradientPreview() {
            const color1 = document.getElementById('color1Hex').value;
            const color2 = document.getElementById('color2Hex').value;
            const gradientPreview = document.getElementById('gradientPreview');
            const textPreview = document.getElementById('textPreview');
            
            const gradient = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
            
            if (gradientPreview) gradientPreview.style.background = gradient;
            if (textPreview) textPreview.style.background = gradient;
        }

        function updateButtonGradientPreview() {
            const color1 = document.getElementById('buttonColor1Hex').value;
            const color2 = document.getElementById('buttonColor2Hex').value;
            const preview = document.getElementById('buttonGradientPreview');
            
            if (preview && color1 && color2) {
                const gradient = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
                preview.style.background = gradient;
            }
        }

        function updateTextPreview() {
            const primaryColor = document.getElementById('primaryTextHex').value;
            const secondaryColor = document.getElementById('secondaryTextHex').value;
            const textPreview = document.getElementById('textPreview');
            
            if (textPreview) {
                const title = textPreview.querySelector('h5');
                const subtitle = textPreview.querySelector('p');
                const button = textPreview.querySelector('button');
                
                if (title) {
                    title.style.setProperty('color', primaryColor, 'important');
                }
                if (subtitle) {
                    subtitle.style.setProperty('color', secondaryColor, 'important');
                }
                if (button) {
                    button.style.setProperty('color', primaryColor, 'important');
                }
            }
        }

        function applyTheme(themeName) {
            currentTheme = themeName;
            localStorage.setItem('currentTheme', currentTheme);
            
            const theme = themes[themeName];
            if (theme) {
                document.body.style.background = theme.background;
                
                // Update color inputs if modal is open
                if (document.getElementById('colorConfigModal').classList.contains('active')) {
                    const colors = theme.background.match(/#[a-fA-F0-9]{6}/g);
                    if (colors && colors.length >= 2) {
                        updateColorPreview('color1', colors[0]);
                        updateColorPreview('color2', colors[1]);
                        updateGradientPreview();
                    }
                }
                
                // Update active buttons with new theme colors
                setTimeout(() => {
                    updateActiveButtons();
                }, 100);
            }
        }

        function applyCustomTheme(color1, color2) {
            const customBackground = `linear-gradient(135deg, ${color1} 0%, ${color2} 100%)`;
            document.body.style.background = customBackground;
            
            // Save custom theme
            localStorage.setItem('customTheme', JSON.stringify({ color1, color2 }));
            currentTheme = 'custom';
            localStorage.setItem('currentTheme', currentTheme);
            
            // Update active buttons with new custom colors
            setTimeout(() => {
                updateActiveButtons();
            }, 100);
        }

        function applyTextColors(primaryColor, secondaryColor) {
            // Apply text colors to the interface
            const style = document.getElementById('customTextStyles') || document.createElement('style');
            style.id = 'customTextStyles';
            style.textContent = `
                /* Text colors */
                .text-slate-700, .text-slate-600, h1, h2, h3, h4, h5, h6 { 
                    color: ${primaryColor} !important; 
                }
                .text-slate-500, .text-slate-400, p, span { 
                    color: ${secondaryColor} !important; 
                }
                
                /* Date display colors */
                .date-display-3d .month-abbr,
                .date-display-3d .day-abbr {
                    color: ${secondaryColor} !important;
                }
                .date-display-3d .day-number {
                    color: ${primaryColor} !important;
                }
                
                /* Active/Selected buttons */
                .btn-primary-3d, 
                button[class*="bg-blue"], 
                button[class*="bg-purple"],
                .date-wheel-item[class*="bg-blue"],
                .date-wheel-item[class*="bg-purple"],
                button.active,
                .active button {
                    background: var(--button-gradient) !important;
                    color: white !important;
                }
                
                /* Specific button states that should change */
                #showMonthViewBtn.active,
                #showAgendaViewBtn.active,
                .date-wheel-item.active,
                button[data-selected="true"] {
                    background: var(--button-gradient) !important;
                    color: white !important;
                }
                
                /* User pills active state */
                .user-pill-3d.active {
                    background: var(--button-gradient) !important;
                    color: white !important;
                }
                
                /* Calendar day today */
                .calendar-day-3d.today {
                    background: var(--primary-gradient) !important;
                    color: white !important;
                }
                
                /* Work section labels */
                .work-section-label {
                    color: ${secondaryColor} !important;
                }
                
                /* Time labels */
                .time-slot .hour-label {
                    color: ${secondaryColor} !important;
                }
                
                /* Modal titles */
                .modal h3, .modal h4 {
                    color: ${primaryColor} !important;
                }
                
                /* Form labels */
                label {
                    color: ${secondaryColor} !important;
                }
                
                /* Input placeholders */
                input::placeholder, textarea::placeholder {
                    color: ${secondaryColor} !important;
                    opacity: 0.7;
                }
                
                /* Modal buttons that should adopt theme colors - Higher specificity */
                button#quickDuration30, button#quickDuration60 {
                    background: var(--primary-gradient) !important;
                    color: white !important;
                    border: var(--border-3d-dark) !important;
                }
                
                button#quickDuration30:hover, button#quickDuration60:hover {
                    background: var(--primary-gradient-hover) !important;
                    transform: translateY(-1px) !important;
                    box-shadow: var(--shadow-medium) !important;
                }
                
                /* Override Tailwind classes specifically */
                button#quickDuration30.bg-blue-100,
                button#quickDuration30.hover\\:bg-blue-200,
                button#quickDuration60.bg-green-100,
                button#quickDuration60.hover\\:bg-green-200 {
                    background: var(--primary-gradient) !important;
                    color: white !important;
                }
                
                /* Modal action buttons - Higher specificity */
                button#cancelAddAppointment {
                    background: linear-gradient(145deg, #ffffff, #f1f5f9) !important;
                    color: ${primaryColor} !important;
                    border: var(--border-3d-dark) !important;
                }
                
                button#saveAppointment {
                    background: var(--primary-gradient) !important;
                    color: white !important;
                    border: var(--border-3d-dark) !important;
                }
                
                button#cancelAddAppointment:hover {
                    background: linear-gradient(145deg, #f8fafc, #e2e8f0) !important;
                    transform: translateY(-1px) !important;
                    box-shadow: var(--shadow-medium) !important;
                }
                
                button#saveAppointment:hover {
                    background: var(--primary-gradient-hover) !important;
                    transform: translateY(-1px) !important;
                    box-shadow: var(--shadow-medium) !important;
                }
            `;
            document.head.appendChild(style);
            
            // Save text colors
            localStorage.setItem('primaryTextColor', primaryColor);
            localStorage.setItem('secondaryTextColor', secondaryColor);
        }

        function resetTheme() {
            applyTheme('default');
            applyTextColors('#1f2937', '#6b7280');
            applyButtonColors('#667eea', '#764ba2');
            localStorage.removeItem('customTheme');
            localStorage.removeItem('primaryTextColor');
            localStorage.removeItem('secondaryTextColor');
            localStorage.removeItem('buttonColors');
            showNotification('Tema restablecido al predeterminado');
        }

        function openColorConfigModal() {
            // Update navigation stack
            pushNavigationState('modal');
            
            document.getElementById('colorConfigModal').classList.add('active');
            
            // Initialize color spectrum sliders
            setupColorSpectrumSlider('color1Spectrum', 'color1Marker', 'color1');
            setupColorSpectrumSlider('color2Spectrum', 'color2Marker', 'color2');
            setupColorSpectrumSlider('primaryTextSpectrum', 'primaryTextMarker', 'primaryText');
            setupColorSpectrumSlider('secondaryTextSpectrum', 'secondaryTextMarker', 'secondaryText');
            
            // Initialize button color spectrum sliders
            setupColorSpectrumSlider('buttonColor1Spectrum', 'buttonColor1Marker', 'buttonColor1');
            setupColorSpectrumSlider('buttonColor2Spectrum', 'buttonColor2Marker', 'buttonColor2');
            
            // Load current colors
            const customTheme = JSON.parse(localStorage.getItem('customTheme'));
            const primaryTextColor = localStorage.getItem('primaryTextColor') || '#1f2937';
            const secondaryTextColor = localStorage.getItem('secondaryTextColor') || '#6b7280';
            const buttonColors = JSON.parse(localStorage.getItem('buttonColors')) || { color1: '#667eea', color2: '#764ba2' };
            
            if (customTheme) {
                updateColorFromSlider('color1', customTheme.color1, (hexToHue(customTheme.color1) / 360) * 100);
                updateColorFromSlider('color2', customTheme.color2, (hexToHue(customTheme.color2) / 360) * 100);
            } else {
                const currentBg = document.body.style.background;
                const colors = currentBg.match(/#[a-fA-F0-9]{6}/g);
                if (colors && colors.length >= 2) {
                    updateColorFromSlider('color1', colors[0], (hexToHue(colors[0]) / 360) * 100);
                    updateColorFromSlider('color2', colors[1], (hexToHue(colors[1]) / 360) * 100);
                }
            }
            
            // Load button colors
            updateColorFromSlider('buttonColor1', buttonColors.color1, (hexToHue(buttonColors.color1) / 360) * 100);
            updateColorFromSlider('buttonColor2', buttonColors.color2, (hexToHue(buttonColors.color2) / 360) * 100);
            
            updateColorFromSlider('primaryText', primaryTextColor, (hexToHue(primaryTextColor) / 360) * 100);
            updateColorFromSlider('secondaryText', secondaryTextColor, (hexToHue(secondaryTextColor) / 360) * 100);
            
            // Force update text preview after a short delay to ensure DOM is ready
            setTimeout(() => {
                updateTextPreview();
                updateButtonGradientPreview();
            }, 100);
        }

        function closeColorConfigModal() {
            document.getElementById('colorConfigModal').classList.remove('active');
            
            // Update navigation stack
            popNavigationState();
        }

        function updateActiveButtons() {
            // Update active button states with current theme colors
            const activeButtons = document.querySelectorAll('.btn-primary-3d, button.active, .active button, .user-pill-3d.active, .date-wheel-item.active');
            
            // Get button colors from localStorage
            const buttonColors = JSON.parse(localStorage.getItem('buttonColors')) || { color1: '#667eea', color2: '#764ba2' };
            const gradient = `linear-gradient(135deg, ${buttonColors.color1} 0%, ${buttonColors.color2} 100%)`;
            
            activeButtons.forEach(button => {
                if (button.classList.contains('active') || 
                    button.id === 'showMonthViewBtn' || 
                    button.id === 'showAgendaViewBtn' ||
                    button.classList.contains('date-wheel-item') ||
                    button.classList.contains('user-pill-3d')) {
                    button.style.background = gradient;
                    button.style.color = 'white';
                    
                    // Remove conflicting Tailwind classes for date-wheel-item
                    if (button.classList.contains('date-wheel-item')) {
                        button.classList.remove('bg-blue-50', 'bg-green-50', 'border-blue-300', 'border-green-300', 'text-slate-700', 'text-green-700');
                    }
                }
            });
            
            // Force update modal buttons by removing conflicting classes and applying styles directly
            const modalButtons = document.querySelectorAll('#quickDuration30, #quickDuration60, #saveAppointment, #saveNewUser, #addUserBtn');
            modalButtons.forEach(button => {
                // Remove conflicting Tailwind classes
                button.classList.remove('bg-blue-100', 'bg-green-100', 'hover:bg-blue-200', 'hover:bg-green-200', 'text-blue-700', 'text-green-700', 'bg-blue-500', 'hover:bg-blue-600');
                
                // Apply theme colors directly
                button.style.background = gradient;
                button.style.color = 'white';
                button.style.border = 'var(--border-3d-dark)';
            });
            
            // Update cancel buttons specifically
            const cancelButtons = document.querySelectorAll('#cancelAddAppointment, #cancelAddUser');
            cancelButtons.forEach(button => {
                button.classList.remove('bg-slate-200', 'hover:bg-slate-300', 'text-slate-700');
                button.style.background = 'linear-gradient(145deg, #ffffff, #f1f5f9)';
                button.style.color = buttonColors.color1; // Use button color for text
                button.style.border = 'var(--border-3d-dark)';
            });
        }

        function applyAllChanges() {
            const color1 = document.getElementById('color1Hex').value;
            const color2 = document.getElementById('color2Hex').value;
            const primaryText = document.getElementById('primaryTextHex').value;
            const secondaryText = document.getElementById('secondaryTextHex').value;
            const buttonColor1 = document.getElementById('buttonColor1Hex').value;
            const buttonColor2 = document.getElementById('buttonColor2Hex').value;
            
            applyCustomTheme(color1, color2);
            applyTextColors(primaryText, secondaryText);
            applyButtonColors(buttonColor1, buttonColor2);
            
            // Force update all buttons multiple times to ensure they adopt the theme
            setTimeout(() => {
                updateActiveButtons();
                // Force update modal buttons specifically
                forceUpdateModalButtons();
            }, 100);
            
            // Additional update after a longer delay to ensure all styles are applied
            setTimeout(() => {
                updateActiveButtons();
                forceUpdateModalButtons();
            }, 300);
            
            showNotification('Configuración de colores aplicada');
            closeColorConfigModal();
        }
        
        function applyButtonColors(color1, color2) {
            // Save button colors
            localStorage.setItem('buttonColors', JSON.stringify({ color1, color2 }));
            
            // Update CSS variables for button gradients
            const style = document.getElementById('customButtonStyles') || document.createElement('style');
            style.id = 'customButtonStyles';
            style.textContent = `
                :root {
                    --button-gradient: linear-gradient(135deg, ${color1} 0%, ${color2} 100%);
                    --button-gradient-hover: linear-gradient(135deg, ${color1}dd 0%, ${color2}dd 100%);
                }
                
                /* Apply button colors to all relevant buttons */
                .btn-primary-3d,
                .user-pill-3d.active,
                .date-wheel-item.active,
                button.active,
                #quickDuration30,
                #quickDuration60,
                #saveAppointment,
                #saveNewUser,
                #addUserBtn {
                    background: var(--button-gradient) !important;
                    color: white !important;
                }
                
                /* Cancel button gets a lighter version */
                #cancelAddAppointment,
                #cancelAddUser {
                    background: linear-gradient(145deg, #ffffff, #f1f5f9) !important;
                    color: ${color1} !important;
                    border: var(--border-3d-dark) !important;
                }
                
                .btn-primary-3d:hover,
                .user-pill-3d.active:hover,
                .date-wheel-item.active:hover,
                button.active:hover,
                #quickDuration30:hover,
                #quickDuration60:hover,
                #saveAppointment:hover,
                #saveNewUser:hover,
                #addUserBtn:hover {
                    background: var(--button-gradient-hover) !important;
                }
                
                #cancelAddAppointment:hover,
                #cancelAddUser:hover {
                    background: linear-gradient(145deg, #f8fafc, #e2e8f0) !important;
                    transform: translateY(-1px) !important;
                    box-shadow: var(--shadow-medium) !important;
                }
            `;
            document.head.appendChild(style);
        }
        
        // Force update modal buttons specifically
        function forceUpdateModalButtons() {
            // Get button colors from localStorage
            const buttonColors = JSON.parse(localStorage.getItem('buttonColors')) || { color1: '#667eea', color2: '#764ba2' };
            const gradient = `linear-gradient(135deg, ${buttonColors.color1} 0%, ${buttonColors.color2} 100%)`;
            
            // Force update duration buttons
            const durationButtons = document.querySelectorAll('#quickDuration30, #quickDuration60');
            durationButtons.forEach(button => {
                button.classList.remove('bg-blue-100', 'bg-green-100', 'hover:bg-blue-200', 'hover:bg-green-200', 'text-blue-700', 'text-green-700');
                button.style.setProperty('background', gradient, 'important');
                button.style.setProperty('color', 'white', 'important');
                button.style.setProperty('border', 'var(--border-3d-dark)', 'important');
            });
            
            // Force update save buttons
            const saveButtons = document.querySelectorAll('#saveAppointment, #saveNewUser');
            saveButtons.forEach(button => {
                button.classList.remove('bg-blue-500', 'hover:bg-blue-600');
                button.style.setProperty('background', gradient, 'important');
                button.style.setProperty('color', 'white', 'important');
                button.style.setProperty('border', 'var(--border-3d-dark)', 'important');
            });
            
            // Force update cancel buttons
            const cancelButtons = document.querySelectorAll('#cancelAddAppointment, #cancelAddUser');
            cancelButtons.forEach(button => {
                button.classList.remove('bg-slate-200', 'hover:bg-slate-300', 'text-slate-700');
                button.style.setProperty('background', 'linear-gradient(145deg, #ffffff, #f1f5f9)', 'important');
                button.style.setProperty('color', buttonColors.color1, 'important');
                button.style.setProperty('border', 'var(--border-3d-dark)', 'important');
            });
            
            // Force update add user button
            const addUserButton = document.getElementById('addUserBtn');
            if (addUserButton) {
                addUserButton.style.setProperty('background', gradient, 'important');
                addUserButton.style.setProperty('color', 'white', 'important');
            }
            
            // Force update user pills and date wheel items
            const userPills = document.querySelectorAll('.user-pill-3d.active');
            userPills.forEach(pill => {
                pill.style.setProperty('background', gradient, 'important');
                pill.style.setProperty('color', 'white', 'important');
            });
            
            const dateWheelItems = document.querySelectorAll('.date-wheel-item.active');
            dateWheelItems.forEach(item => {
                // Remove conflicting Tailwind classes
                item.classList.remove('bg-blue-50', 'bg-green-50', 'border-blue-300', 'border-green-300', 'text-slate-700', 'text-green-700');
                
                // Apply button gradient
                item.style.setProperty('background', gradient, 'important');
                item.style.setProperty('color', 'white', 'important');
            });
        }

        function generateUniqueColor(appointmentId) {
            // Create a hash from the appointment ID
            let hash = 0;
            for (let i = 0; i < appointmentId.length; i++) {
                const char = appointmentId.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            
            // Use the hash to generate consistent colors
            const hue = Math.abs(hash) % 360; // Hue from 0-360
            const saturation = 70 + (Math.abs(hash) % 30); // Saturation 70-100%
            const lightness = 50 + (Math.abs(hash) % 20); // Lightness 50-70%
            
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }
        function createTimeSegment(hour, startMinuteOffset, durationMinutes, isFree, appointmentData, workType = null) {
            const segment = document.createElement('div');
            segment.classList.add('time-segment');
            segment.style.width = `${(durationMinutes / 60) * 100}%`; // Width proportional to duration

            if (isFree) {
                segment.classList.add('free-segment');
                if (durationMinutes > 10) segment.textContent = `${durationMinutes}m libres`; // Show text if space allows
                segment.title = `Añadir cita a las ${String(hour).padStart(2, '0')}:${String(startMinuteOffset).padStart(2, '0')} (${durationMinutes}m disponibles)`;
                // Click listener to open the add modal
                segment.addEventListener('click', () => {
                    const maxDurationPossible = calculateContiguousFreeTime(selectedAgendaDate, hour, startMinuteOffset, null, workType);
                    openAddAppointmentModal(selectedAgendaDate, hour, startMinuteOffset, maxDurationPossible, null, workType);
                });
            } else { // Booked segment
                segment.classList.add('booked-segment');
                // Generate unique color based on appointment ID
                const uniqueColor = appointmentData.color || generateUniqueColor(appointmentData.id);
                segment.style.backgroundColor = uniqueColor; 
                // Adjust text color based on background brightness
                if (isColorLight(uniqueColor)) {
                    segment.classList.add('dark-text'); segment.classList.remove('light-text');
                } else {
                    segment.classList.add('light-text'); segment.classList.remove('dark-text');
                }
                segment.textContent = appointmentData.title; // Display title
                // Add work type icon if available
                if (appointmentData.workType && workTypes[appointmentData.workType]) {
                    const workTypeIcon = workTypes[appointmentData.workType].icon;
                    const iconSpan = document.createElement('span');
                    iconSpan.classList.add('work-type-icon');
                    
                    // Add specific animation based on work type
                    if (appointmentData.workType === 'work1') {
                        iconSpan.classList.add('icon-lightning');
                    } else if (appointmentData.workType === 'work2') {
                        iconSpan.classList.add('icon-rocket');
                    }
                    
                    iconSpan.dataset.workType = appointmentData.workType;
                    iconSpan.textContent = workTypeIcon;
                    iconSpan.style.marginRight = '4px';
                    segment.insertBefore(iconSpan, segment.firstChild);
                }
                // Tooltip with full details
                const startTimeStr = `${String(appointmentData.startHour).padStart(2, '0')}:${String(appointmentData.startMinute).padStart(2, '0')}`;
                const endTimeStr = formatEndTime(appointmentData.startHour, appointmentData.startMinute, appointmentData.duration);
                const workTypeName = appointmentData.workType && workTypes[appointmentData.workType] ? workTypes[appointmentData.workType].name : 'Sin tipo';
                segment.title = `${appointmentData.title} (${workTypeName}) - ${startTimeStr} a ${endTimeStr} (${appointmentData.duration}m). Haz clic para ver detalles.`;
                // Click listener to open the view details modal
                segment.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    openViewAppointmentDetailsModal(appointmentData, formatDateKey(selectedAgendaDate)); // Pass dateKey
                });
                // Add delete button ('x') directly on the segment
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '&times;'; // 'x' symbol
                deleteBtn.classList.add('ml-1', 'delete-btn', 'opacity-70', 'hover:opacity-100', 'font-bold', 'text-xs', 'p-0.5', 'rounded-full');
                // Apply text color class to delete button as well
                if (isColorLight(uniqueColor)) deleteBtn.classList.add('dark-text');
                else deleteBtn.classList.add('light-text');
                deleteBtn.title = 'Eliminar cita';
                deleteBtn.style.lineHeight = '1'; 
                // Click listener for the delete button
                deleteBtn.onclick = (e) => {
                    e.stopPropagation(); // Prevent opening details modal
                    console.log('Click en botón X:', appointmentData.id, formatDateKey(selectedAgendaDate)); 
                    if (confirm(`¿Eliminar cita "${appointmentData.title}"?`)) {
                        deleteAppointment(appointmentData.id, formatDateKey(selectedAgendaDate));
                    }
                };
                // Only show delete button if segment is wide enough
                if (durationMinutes > 20 && segment.offsetWidth > 30) { // Heuristic check
                    segment.appendChild(deleteBtn);
                }
            }
            return segment;
        }

        // Calculates the maximum contiguous free time starting from a specific point
        function calculateContiguousFreeTime(targetDate, startHour, startMinute, editingApptId = null, workType = null) {
            const dateKey = formatDateKey(targetDate);
            const userAppointments = getCurrentUserAppointments();
            // Get appointments for the day, excluding the one being edited (if any)
            let dailyAppts = (userAppointments[dateKey] || [])
                .filter(appt => appt.id !== editingApptId);
            
            // If workType is specified, only consider appointments of that work type
            if (workType) {
                dailyAppts = dailyAppts.filter(appt => appt.workType === workType);
            }
            
            dailyAppts = dailyAppts.slice().sort((a, b) => (a.startHour * 60 + a.startMinute) - (b.startHour * 60 + b.startMinute));
            
            const checkFromMinuteOfDay = startHour * 60 + startMinute;
            // Find the next appointment that starts at or after the check time
            let nextBlockingAppt = dailyAppts.find(appt => (appt.startHour * 60 + appt.startMinute) >= checkFromMinuteOfDay);
            
            // Calculate free minutes until the next appointment or end of day
            return nextBlockingAppt ? (nextBlockingAppt.startHour * 60 + nextBlockingAppt.startMinute) - checkFromMinuteOfDay : (24 * 60) - checkFromMinuteOfDay;
        }

        // Formats the end time given start time and duration
        function formatEndTime(startHour, startMinute, duration) {
            let endTotalMinutes = startHour * 60 + startMinute + duration;
            let endHour = Math.floor(endTotalMinutes / 60) % 24; // Handle crossing midnight
            let endMinute = endTotalMinutes % 60;
            return `${String(endHour).padStart(2, '0')}:${String(endMinute).padStart(2, '0')}`;
        }

        // Populates the hour and minute select dropdowns in the add/edit modal
        function populateTimeSelects() {
            appointmentStartHourSelect.innerHTML = '';
            for (let i = 0; i < 24; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = String(i).padStart(2, '0');
                appointmentStartHourSelect.appendChild(option);
            }
            appointmentStartMinuteSelect.innerHTML = '';
            // Using 5-minute increments for minutes dropdown
            for (let i = 0; i < 60; i += 5) { 
                const option = document.createElement('option');
                option.value = i;
                option.textContent = String(i).padStart(2, '0');
                appointmentStartMinuteSelect.appendChild(option);
            }
        }

        // Updates the time info text and max duration in the add/edit modal
        function updateAppointmentTimeInfo() {
            if (!currentAppointmentContext) return;
            const selectedHour = parseInt(appointmentStartHourSelect.value);
            const selectedMinute = parseInt(appointmentStartMinuteSelect.value);
            
            // Get the target date (either from date input if editing, or from context)
            let targetDate = currentAppointmentContext.date;
            if (currentAppointmentContext.editingAppointmentId && appointmentDateInput.value) {
                targetDate = createDateFromString(appointmentDateInput.value);
            }
            
            // Determine target user for calculation
            let targetUserId = currentUserId;
            if (currentAppointmentContext.editingAppointmentId && appointmentUserSelect.value) {
                targetUserId = appointmentUserSelect.value;
            }
            
            // Update context with currently selected time
            currentAppointmentContext.currentSelectedHour = selectedHour;
            currentAppointmentContext.currentSelectedMinute = selectedMinute;
            currentAppointmentContext.currentTargetDate = targetDate;
            
            // Recalculate max duration based on selected time, date, user, and work type
            const selectedWorkType = appointmentWorkTypeSelect.value;
            currentAppointmentContext.currentMaxDuration = calculateContiguousFreeTimeForUser(
                targetDate, 
                selectedHour, 
                selectedMinute,
                currentAppointmentContext.editingAppointmentId, // Pass ID if editing
                targetUserId,
                selectedWorkType
            );
            // Update the max attribute of the duration input
            appointmentDurationInput.max = currentAppointmentContext.currentMaxDuration;
            // Adjust duration value if it exceeds the new max
            if (parseInt(appointmentDurationInput.value) > currentAppointmentContext.currentMaxDuration && currentAppointmentContext.currentMaxDuration > 0) {
                appointmentDurationInput.value = currentAppointmentContext.currentMaxDuration;
            } else if (currentAppointmentContext.currentMaxDuration <= 0 && !currentAppointmentContext.editingAppointmentId) { 
                 appointmentDurationInput.value = 1; // Prevent 0 or negative duration if no space
            }
            // Update the info text
            const userInfo = targetUserId !== currentUserId ? ` (Usuario: ${users[targetUserId]?.name || 'Desconocido'})` : '';
            appointmentTimeInfoEl.textContent = `Cita para el ${targetDate.toLocaleDateString('es-ES')} a las ${String(selectedHour).padStart(2, '0')}:${String(selectedMinute).padStart(2, '0')}. Duración máxima: ${currentAppointmentContext.currentMaxDuration > 0 ? currentAppointmentContext.currentMaxDuration : 0} min.${userInfo}`;
        }
        
        // Helper function to create a date from YYYY-MM-DD string without timezone issues
        function createDateFromString(dateString) {
            const [year, month, day] = dateString.split('-').map(Number);
            return new Date(year, month - 1, day); // month is 0-indexed in Date constructor
        }
        
        // Calculate contiguous free time for a specific user
        function calculateContiguousFreeTimeForUser(date, startHour, startMinute, excludeAppointmentId = null, userId = null, workType = null) {
            const targetUserId = userId || currentUserId;
            const userAppointments = appointments[targetUserId] || {};
            const dateKey = formatDateKey(date);
            let dayAppointments = userAppointments[dateKey] || [];
            
            // If workType is specified, only consider appointments of that work type
            if (workType) {
                dayAppointments = dayAppointments.filter(appt => appt.workType === workType);
            }
            
            const startTime = startHour * 60 + startMinute;
            const endTime = 24 * 60; // End of day
            
            // Filter out the excluded appointment
            const relevantAppointments = dayAppointments.filter(appt => appt.id !== excludeAppointmentId);
            
            // Sort appointments by start time
            relevantAppointments.sort((a, b) => {
                const aStart = a.startHour * 60 + a.startMinute;
                const bStart = b.startHour * 60 + b.startMinute;
                return aStart - bStart;
            });
            
            // Find the first appointment that starts after our start time
            for (const appt of relevantAppointments) {
                const apptStart = appt.startHour * 60 + appt.startMinute;
                if (apptStart > startTime) {
                    return apptStart - startTime;
                }
            }
            
            // No appointments found after start time, return remaining time
            return endTime - startTime;
        }
        
        // Opens the Add/Edit modal, pre-filling data if editing
        function openAddAppointmentModal(date, hour, minute, maxDurationPossible, appointmentToEditData = null, workType = null) {
            // Update navigation stack
            pushNavigationState('modal');
            
            populateTimeSelects(); // Ensure selects are populated
            if (appointmentToEditData) { // Edit Mode
                currentAppointmentContext = { 
                    date: date, // Date object of the appointment
                    initialHour: appointmentToEditData.startHour, 
                    initialMinute: appointmentToEditData.startMinute,
                    currentSelectedHour: appointmentToEditData.startHour,
                    currentSelectedMinute: appointmentToEditData.startMinute,
                    editingAppointmentId: appointmentToEditData.id,
                    originalDateKey: formatDateKey(date), // Store original date key
                    originalUserId: currentUserId // Store original user ID
                };
                // Sync with global context
                window.currentAppointmentContext = currentAppointmentContext;
                // Set modal title and button text for editing
                modalTitleEl.textContent = "Editar Cita";
                saveAppointmentBtn.textContent = "Actualizar Cita";
                
                // Show date and user selectors for editing
                appointmentDateContainer.classList.remove('hidden');
                appointmentUserContainer.classList.remove('hidden');
                appointmentDateInput.value = formatDateKey(date);
                
                // Populate user selector
                populateUserSelector();
                appointmentUserSelect.value = ''; // Default to current user
                
                // Pre-fill form fields
                appointmentTitleInput.value = appointmentToEditData.title;
                appointmentWorkTypeSelect.value = appointmentToEditData.workType || 'work1';
                appointmentStartHourSelect.value = appointmentToEditData.startHour;
                appointmentStartMinuteSelect.value = appointmentToEditData.startMinute;
                appointmentDurationInput.value = appointmentToEditData.duration;
                appointmentDetailsInput.value = appointmentToEditData.details || '';
                // Calculate initial max duration excluding the current appointment
                currentAppointmentContext.currentMaxDuration = calculateContiguousFreeTime(date, appointmentToEditData.startHour, appointmentToEditData.startMinute, appointmentToEditData.id, appointmentToEditData.workType);
            } else { // Add Mode
                // Check if there are already simultaneous appointments at this time
                const dateKey = formatDateKey(date);
                const userAppointments = getCurrentUserAppointments();
                const dayAppointments = userAppointments[dateKey] || [];
                const hasWork1 = dayAppointments.some(appt => appt.workType === 'work1');
                const hasWork2 = dayAppointments.some(appt => appt.workType === 'work2');
                
                currentAppointmentContext = { 
                    date: date, initialHour: hour, initialMinute: minute,
                    currentSelectedHour: hour, currentSelectedMinute: minute,
                    currentMaxDuration: maxDurationPossible, // This will be recalculated with correct workType
                    editingAppointmentId: null,
                    originalDateKey: null,
                    originalUserId: null,
                    hasSimultaneousWork: hasWork1 && hasWork2,
                    initialWorkType: workType // Store the initial work type
                };
                // Sync with global context
                window.currentAppointmentContext = currentAppointmentContext;
                // Set modal title and button text for adding
                modalTitleEl.textContent = "Añadir Nueva Cita";
                saveAppointmentBtn.textContent = "Guardar Cita";
                
                // Hide date and user selectors for adding
                appointmentDateContainer.classList.add('hidden');
                appointmentUserContainer.classList.add('hidden');
                
                // Clear form fields
                appointmentTitleInput.value = '';
                appointmentWorkTypeSelect.value = workType || 'work1'; // Use passed workType or default to Trabajo 1
                appointmentDetailsInput.value = ''; 
                // Set initial time and duration
                appointmentStartHourSelect.value = hour;
                appointmentStartMinuteSelect.value = minute;
                appointmentDurationInput.value = Math.min(30, maxDurationPossible > 0 ? maxDurationPossible : 30); // Default 30min or max
                currentAppointmentContext.currentMaxDuration = maxDurationPossible; // Already calculated
            }
            
            // Set the max attribute for duration input
            appointmentDurationInput.max = currentAppointmentContext.currentMaxDuration > 0 ? currentAppointmentContext.currentMaxDuration : 1;
                updateAppointmentTimeInfo(); // Update info text with correct workType calculation
            addAppointmentModalEl.classList.add('active'); // Show modal
            
            // Add save button handler as backup
            setTimeout(() => {
                addSaveButtonHandler();
            }, 100);
            appointmentTitleInput.focus(); // Focus on title input
            
            // Force update modal buttons to ensure they adopt the current theme
            setTimeout(() => {
                updateActiveButtons();
                forceUpdateModalButtons();
            }, 50);
            
            // Additional update to ensure button colors are applied
            setTimeout(() => {
                const buttonColors = JSON.parse(localStorage.getItem('buttonColors')) || { color1: '#667eea', color2: '#764ba2' };
                const gradient = `linear-gradient(135deg, ${buttonColors.color1} 0%, ${buttonColors.color2} 100%)`;
                
                // Force apply button colors to modal buttons
                const durationButtons = document.querySelectorAll('#quickDuration30, #quickDuration60');
                durationButtons.forEach(button => {
                    button.style.setProperty('background', gradient, 'important');
                    button.style.setProperty('color', 'white', 'important');
                });
                
                const saveButton = document.getElementById('saveAppointment');
                if (saveButton) {
                    saveButton.style.setProperty('background', gradient, 'important');
                    saveButton.style.setProperty('color', 'white', 'important');
                }
                
                const cancelButton = document.getElementById('cancelAddAppointment');
                if (cancelButton) {
                    cancelButton.style.setProperty('background', 'linear-gradient(145deg, #ffffff, #f1f5f9)', 'important');
                    cancelButton.style.setProperty('color', buttonColors.color1, 'important');
                }
            }, 100);
        }
        
        // Populate user selector for transfer
        function populateUserSelector() {
            appointmentUserSelect.innerHTML = '<option value="">Mantener en usuario actual</option>';
            Object.entries(users).forEach(([userId, userData]) => {
                if (userId !== currentUserId) { // Don't show current user
                    const option = document.createElement('option');
                    option.value = userId;
                    option.textContent = userData.name;
                    appointmentUserSelect.appendChild(option);
                }
            });
        }

        // Direct button handlers for modal actions
        function handleSaveAppointment(event) {
            console.log('handleSaveAppointment called directly');
            event.preventDefault();
            event.stopPropagation();
            
            try {
                saveCurrentAppointment();
                console.log('saveCurrentAppointment executed successfully');
            } catch (error) {
                console.error('Error in saveCurrentAppointment:', error);
            }
        }
        
        function handleCancelAppointment(event) {
            console.log('handleCancelAppointment called directly');
            event.preventDefault();
            event.stopPropagation();
            
            try {
                closeAddAppointmentModal();
                console.log('closeAddAppointmentModal executed successfully');
            } catch (error) {
                console.error('Error in closeAddAppointmentModal:', error);
            }
        }
        
        function handleEditAppointment(event) {
            console.log('handleEditAppointment called directly');
            event.preventDefault();
            event.stopPropagation();
            
            try {
                if (appointmentContextForDetails) { 
                    const apptData = appointmentContextForDetails.data;
                    const apptDateKey = appointmentContextForDetails.dateKey; 
                    const dateOfAppointment = parseDateKey(apptDateKey); 
                    openAddAppointmentModal(dateOfAppointment, apptData.startHour, apptData.startMinute, 0, apptData);
                    closeViewAppointmentDetailsModal();
                    console.log('Edit appointment executed successfully');
                } else {
                    console.log('No appointmentContextForDetails available');
                }
            } catch (error) {
                console.error('Error in handleEditAppointment:', error);
            }
        }
        
        function handleDeleteAppointment(event) {
            console.log('handleDeleteAppointment called directly');
            event.preventDefault();
            event.stopPropagation();
            
            try {
                if (appointmentContextForDetails) {
                    handleDeleteAppointmentFromDetails(appointmentContextForDetails.data, appointmentContextForDetails.dateKey);
                    console.log('Delete appointment executed successfully');
                } else {
                    console.log('No appointmentContextForDetails available');
                }
            } catch (error) {
                console.error('Error in handleDeleteAppointment:', error);
            }
        }
        
        function handleCloseDetails(event) {
            console.log('handleCloseDetails called directly');
            event.preventDefault();
            event.stopPropagation();
            
            try {
                closeViewAppointmentDetailsModal();
                console.log('closeViewAppointmentDetailsModal executed successfully');
            } catch (error) {
                console.error('Error in closeViewAppointmentDetailsModal:', error);
            }
        }
        
        // Closes the Add/Edit modal
        function closeAddAppointmentModal() {
            console.log('Closing add/edit modal');
            addAppointmentModalEl.classList.remove('active');
            currentAppointmentContext = null; // Clear context
            window.currentAppointmentContext = null; // Sync with global context
            
            // Update navigation stack
            popNavigationState();
            
            // Ensure modal is completely hidden
            setTimeout(() => {
                addAppointmentModalEl.style.display = 'none';
                addAppointmentModalEl.style.visibility = 'hidden';
                addAppointmentModalEl.style.opacity = '0';
                
                // Force re-render
                addAppointmentModalEl.offsetHeight;
                
                // Reset styles
                addAppointmentModalEl.style.display = '';
                addAppointmentModalEl.style.visibility = '';
                addAppointmentModalEl.style.opacity = '';
                
                console.log('Add/edit modal closed successfully');
            }, 100);
        }
        
        // Add direct click handler for save button as backup
        function addSaveButtonHandler() {
            const saveBtn = document.getElementById('saveAppointment');
            if (saveBtn) {
                saveBtn.onclick = function(e) {
                    console.log('Save button clicked via onclick');
                    console.log('Button element:', e.target);
                    console.log('Button text:', e.target.textContent);
                    console.log('Current appointment context:', currentAppointmentContext);
                    e.preventDefault();
                    e.stopPropagation();
                    
                    try {
                        saveCurrentAppointment();
                        console.log('saveCurrentAppointment executed successfully via onclick');
                    } catch (error) {
                        console.error('Error in saveCurrentAppointment via onclick:', error);
                    }
                };
                console.log('Save button onclick handler added');
            }
        }

        // Saves a new appointment or updates an existing one
        function saveCurrentAppointment() {
            console.log('=== saveCurrentAppointment function called ===');
            console.log('currentAppointmentContext:', currentAppointmentContext);
            console.log('window.currentAppointmentContext:', window.currentAppointmentContext);
            
            if (!currentAppointmentContext) {
                console.log('No currentAppointmentContext, returning early');
                return;
            }
            
            console.log('Proceeding with save...');
            // Get data from form
            const title = appointmentTitleInput.value.trim();
            const workType = appointmentWorkTypeSelect.value;
            const duration = parseInt(appointmentDurationInput.value, 10);
            const details = appointmentDetailsInput.value.trim();
            // Get selected start time from context (updated by selects)
            const startHour = currentAppointmentContext.currentSelectedHour;
            const startMinute = currentAppointmentContext.currentSelectedMinute;
            
            // Get target date (either from date input if editing, or from context)
            let targetDate = currentAppointmentContext.date;
            if (currentAppointmentContext.editingAppointmentId && appointmentDateInput.value) {
                targetDate = createDateFromString(appointmentDateInput.value);
            }
            const targetDateKey = formatDateKey(targetDate);

            // --- Validations ---
            if (!title) {
                alert('Por favor, introduce un título para la cita.');
                appointmentTitleInput.focus(); return;
            }
            if (isNaN(duration) || duration <= 0) {
                alert('Por favor, introduce una duración válida en minutos.');
                appointmentDurationInput.focus(); return;
            }
            // Validate duration against the max calculated for the selected start time
            if (duration > currentAppointmentContext.currentMaxDuration) {
                alert(`La duración (${duration}m) no puede exceder los ${currentAppointmentContext.currentMaxDuration} minutos disponibles para la hora de inicio seleccionada.`);
                appointmentDurationInput.focus(); return;
            }
            
            // Ensure the date key exists in user appointments object
            const userAppointments = getCurrentUserAppointments();
            if (!userAppointments[targetDateKey]) userAppointments[targetDateKey] = [];
            
            // Determine target user for validation
            let validationUserId = currentUserId;
            if (currentAppointmentContext.editingAppointmentId && appointmentUserSelect.value) {
                validationUserId = appointmentUserSelect.value;
            }
            
            // Get target user appointments for conflict check
            const targetUserAppointments = appointments[validationUserId] || {};
            if (!targetUserAppointments[targetDateKey]) targetUserAppointments[targetDateKey] = [];
            
            // --- Conflict Check (Allow simultaneous work of same type) ---
            const newApptStart = startHour * 60 + startMinute;
            const newApptEnd = newApptStart + duration;
            for (const existingAppt of targetUserAppointments[targetDateKey]) {
                // Skip checking against itself if editing
                if (currentAppointmentContext.editingAppointmentId && existingAppt.id === currentAppointmentContext.editingAppointmentId) {
                    continue; 
                }
                const existingApptStart = existingAppt.startHour * 60 + existingAppt.startMinute;
                const existingApptEnd = existingApptStart + existingAppt.duration;
                // Check for overlap
                if (Math.max(newApptStart, existingApptStart) < Math.min(newApptEnd, existingApptEnd)) {
                    // Allow simultaneous work if it's the same work type
                    if (workType === existingAppt.workType) {
                        const workTypeName = workTypes[workType]?.name || 'Trabajo';
                        const confirmSimultaneous = confirm(`Ya tienes una cita de ${workTypeName} en este horario. ¿Deseas agregar otra cita simultánea del mismo tipo?`);
                        if (!confirmSimultaneous) {
                            return;
                        }
                    } else {
                        // Different work types - always allow coexistence with new structure
                            const existingWorkTypeName = workTypes[existingAppt.workType]?.name || 'Trabajo';
                            const newWorkTypeName = workTypes[workType]?.name || 'Trabajo';
                        const confirmDifferentWork = confirm(`Ya tienes una cita de ${existingWorkTypeName} en este horario. ¿Deseas agregar una cita de ${newWorkTypeName} en la sección separada?`);
                            if (!confirmDifferentWork) {
                            return;
                        }
                    }
                }
            }
            
            // --- Save or Update ---
            let wasEditing = false; 
            let originalDateKeyForRender = null; 
            let targetUserId = currentUserId; // Default to current user
            
            // Check if user transfer is requested (only for editing)
            if (currentAppointmentContext.editingAppointmentId && appointmentUserSelect.value) {
                targetUserId = appointmentUserSelect.value;
            }
            
            if (currentAppointmentContext.editingAppointmentId) { // Update existing appointment
                wasEditing = true;
                originalDateKeyForRender = currentAppointmentContext.originalDateKey;
                
                // Get appointments from original user
                const originalUserAppointments = appointments[currentAppointmentContext.originalUserId] || {};
                const apptIndex = originalUserAppointments[currentAppointmentContext.originalDateKey]?.findIndex(appt => appt.id === currentAppointmentContext.editingAppointmentId);
                
                if (apptIndex > -1) {
                    // Create the updated appointment data
                    const workTypeConfig = workTypes[workType] || workTypes['work1'];
                    const updatedAppointmentData = {
                        ...originalUserAppointments[currentAppointmentContext.originalDateKey][apptIndex], 
                        title: title, 
                        startHour: startHour, 
                        startMinute: startMinute,
                        duration: duration, 
                        details: details,
                        workType: workType,
                        color: generateUniqueColor(currentAppointmentContext.editingAppointmentId) // Keep existing color or generate new one
                    };
                    
                    // Get target user appointments
                    if (!appointments[targetUserId]) {
                        appointments[targetUserId] = {};
                    }
                    if (!appointments[targetUserId][targetDateKey]) {
                        appointments[targetUserId][targetDateKey] = [];
                    }
                    
                    // Add to target user/date
                    appointments[targetUserId][targetDateKey].push(updatedAppointmentData);
                    
                    // Remove from original location
                    originalUserAppointments[currentAppointmentContext.originalDateKey].splice(apptIndex, 1);
                    
                    // Clean up original date array if empty
                    if (originalUserAppointments[currentAppointmentContext.originalDateKey].length === 0) {
                        delete originalUserAppointments[currentAppointmentContext.originalDateKey];
                    }
                    
                    // Update duration usage statistics for target user
                    if (!durationUsage[targetUserId]) {
                        durationUsage[targetUserId] = {};
                    }
                    durationUsage[targetUserId][duration] = (durationUsage[targetUserId][duration] || 0) + 1;
                } else {
                    console.error("Error: No se encontró la cita para editar.");
                }
            } else { // Add new appointment
                // Generate unique ID for the new appointment
                const newAppointmentId = Date.now().toString() + Math.random().toString(36).substring(2,7);
                // Generate unique color based on the new ID
                const newColor = generateUniqueColor(newAppointmentId);
                
                // Ensure target user appointments exist
                if (!appointments[targetUserId]) {
                    appointments[targetUserId] = {};
                }
                if (!appointments[targetUserId][targetDateKey]) {
                    appointments[targetUserId][targetDateKey] = [];
                }
                
                appointments[targetUserId][targetDateKey].push({
                    id: newAppointmentId, 
                    title: title, 
                    startHour: startHour, 
                    startMinute: startMinute,
                    duration: duration, 
                    color: newColor, 
                    details: details,
                    workType: workType
                });
                // Update duration usage statistics for new appointments
                updateDurationUsage(duration);
            }

            saveAppointmentsToLocalStorage();
            const contextDateKey = targetDateKey; // Store date key before closing modal
            const contextOriginalDateKey = originalDateKeyForRender; // Store original date key if editing
            
            closeAddAppointmentModal(); // Close modal first

            // --- Re-render Views ---
            const agendaWasVisible = !agendaViewEl.classList.contains('hidden');
            renderMonthView(); // Always update month view dots

            if (agendaWasVisible) { // If agenda view was active, keep it active
                monthViewEl.classList.add('hidden');
                agendaViewEl.classList.remove('hidden');
                // Re-render agenda view if the change affected the currently selected date
                // or the original date (if editing and date changed)
                if (formatDateKey(selectedAgendaDate) === contextDateKey || 
                    (wasEditing && contextOriginalDateKey && formatDateKey(selectedAgendaDate) === contextOriginalDateKey) ) {
                    renderAgendaView();
                }
            }
        }

        // Finds appointments that occur simultaneously with the given appointment
        function findSimultaneousAppointments(targetAppointment, allAppointments) {
            const targetStart = targetAppointment.startHour * 60 + targetAppointment.startMinute;
            const targetEnd = targetStart + targetAppointment.duration;
            
            return allAppointments.filter(appt => {
                if (appt.id === targetAppointment.id) return true; // Include the target appointment itself
                
                const apptStart = appt.startHour * 60 + appt.startMinute;
                const apptEnd = apptStart + appt.duration;
                
                // Check for overlap
                return Math.max(targetStart, apptStart) < Math.min(targetEnd, apptEnd);
            });
        }

        // Debug function to check modal button visibility
        function debugModalButtons() {
          const modal = document.getElementById('viewAppointmentDetailsModal');
          const editBtn = document.getElementById('editAppointmentBtn');
          const deleteBtn = document.getElementById('deleteAppointmentFromDetailsBtn');
          const closeBtn = document.getElementById('closeViewAppointmentDetails');
          
          console.log('=== Modal Debug Info ===');
          console.log('Modal element:', modal);
          console.log('Modal classes:', modal ? modal.className : 'Not found');
          console.log('Modal display:', modal ? window.getComputedStyle(modal).display : 'Not found');
          console.log('Modal visibility:', modal ? window.getComputedStyle(modal).visibility : 'Not found');
          
          console.log('Edit button:', editBtn);
          console.log('Edit button display:', editBtn ? window.getComputedStyle(editBtn).display : 'Not found');
          console.log('Edit button visibility:', editBtn ? window.getComputedStyle(editBtn).visibility : 'Not found');
          
          console.log('Delete button:', deleteBtn);
          console.log('Delete button display:', deleteBtn ? window.getComputedStyle(deleteBtn).display : 'Not found');
          console.log('Delete button visibility:', deleteBtn ? window.getComputedStyle(deleteBtn).visibility : 'Not found');
          
          console.log('Close button:', closeBtn);
          console.log('Close button display:', closeBtn ? window.getComputedStyle(closeBtn).display : 'Not found');
          console.log('Close button visibility:', closeBtn ? window.getComputedStyle(closeBtn).visibility : 'Not found');
          console.log('=== End Debug Info ===');
        }
        
        // Opens the View Details modal
        function openViewAppointmentDetailsModal(appointmentData, dateKeyForAppointment) {
            // Update navigation stack
            pushNavigationState('modal');
            
            // Store the appointment data and its date key for edit/delete actions
            appointmentContextForDetails = { data: appointmentData, dateKey: dateKeyForAppointment }; 
            
            // Find simultaneous appointments
            const userAppointments = appointments[currentUserId] || {};
            const dayAppointments = userAppointments[dateKeyForAppointment] || [];
            const simultaneousAppointments = findSimultaneousAppointments(appointmentData, dayAppointments);
            
            // Populate modal fields
            const workTypeInfo = appointmentContextForDetails.data.workType && workTypes[appointmentContextForDetails.data.workType] 
                ? `${workTypes[appointmentContextForDetails.data.workType].icon} ${workTypes[appointmentContextForDetails.data.workType].name}` 
                : 'Sin tipo';
            
            if (simultaneousAppointments.length > 1) {
                viewAppointmentTitleEl.textContent = `${appointmentContextForDetails.data.title} (${workTypeInfo}) - Trabajo Simultáneo`;
            } else {
                viewAppointmentTitleEl.textContent = `${appointmentContextForDetails.data.title} (${workTypeInfo})`;
            }
            
            const startTimeStr = `${String(appointmentContextForDetails.data.startHour).padStart(2, '0')}:${String(appointmentContextForDetails.data.startMinute).padStart(2, '0')}`;
            const endTimeStr = formatEndTime(appointmentContextForDetails.data.startHour, appointmentContextForDetails.data.startMinute, appointmentContextForDetails.data.duration);
            viewAppointmentTimeEl.textContent = `Hora: ${startTimeStr} - ${endTimeStr}`;
            viewAppointmentDurationEl.textContent = `Duración: ${appointmentContextForDetails.data.duration} minutos`;
            
            // Show simultaneous appointments info
            if (simultaneousAppointments.length > 1) {
                const simultaneousInfo = simultaneousAppointments.map(appt => {
                    const workTypeIcon = appt.workType && workTypes[appt.workType] ? workTypes[appt.workType].icon : '📋';
                    return `${workTypeIcon} ${appt.title}`;
                }).join('\n');
                viewAppointmentDetailsContentEl.innerHTML = `
                    <div class="mb-3">
                        <strong>Trabajos Simultáneos:</strong><br>
                        <div class="ml-4 text-sm text-slate-600">${simultaneousInfo.replace(/\n/g, '<br>')}</div>
                    </div>
                    <div>
                        <strong>Detalles:</strong><br>
                        ${appointmentContextForDetails.data.details || "No hay detalles adicionales."}
                    </div>
                `;
            } else {
                viewAppointmentDetailsContentEl.textContent = appointmentContextForDetails.data.details || "No hay detalles adicionales.";
            }
            
            // Ensure buttons are enabled and clickable
            setTimeout(() => {
                const editBtn = document.getElementById('editAppointmentBtn');
                const deleteBtn = document.getElementById('deleteAppointmentFromDetailsBtn');
                const closeBtn = document.getElementById('closeViewAppointmentDetails');
                
                if (editBtn) {
                    editBtn.disabled = false;
                    editBtn.style.pointerEvents = 'auto';
                    editBtn.style.opacity = '1';
                    editBtn.style.cursor = 'pointer';
                    editBtn.style.display = 'inline-block';
                    editBtn.style.visibility = 'visible';
                    
                    // Add direct click handler as backup
                    editBtn.onclick = function(e) {
                        console.log('Edit button clicked via onclick');
                        e.preventDefault();
                        e.stopPropagation();
                        
                        if (appointmentContextForDetails) { 
                            const apptData = appointmentContextForDetails.data;
                            const apptDateKey = appointmentContextForDetails.dateKey; 
                            const dateOfAppointment = parseDateKey(apptDateKey); 
                            openAddAppointmentModal(dateOfAppointment, apptData.startHour, apptData.startMinute, 0, apptData);
                            closeViewAppointmentDetailsModal();
                        }
                    };
                    
                    console.log('Edit button enabled and visible');
                }
                
                if (deleteBtn) {
                    deleteBtn.disabled = false;
                    deleteBtn.style.pointerEvents = 'auto';
                    deleteBtn.style.opacity = '1';
                    deleteBtn.style.cursor = 'pointer';
                    deleteBtn.style.display = 'inline-block';
                    deleteBtn.style.visibility = 'visible';
                    
                    // Add direct click handler as backup
                    deleteBtn.onclick = function(e) {
                        console.log('Delete button clicked via onclick');
                        e.preventDefault();
                        e.stopPropagation();
                        
                        if (appointmentContextForDetails) {
                            handleDeleteAppointment(appointmentContextForDetails.data, appointmentContextForDetails.dateKey);
                        }
                    };
                    
                    console.log('Delete button enabled and visible');
                }
                
                if (closeBtn) {
                    closeBtn.disabled = false;
                    closeBtn.style.pointerEvents = 'auto';
                    closeBtn.style.opacity = '1';
                    closeBtn.style.cursor = 'pointer';
                    closeBtn.style.display = 'inline-block';
                    closeBtn.style.visibility = 'visible';
                    
                    // Add direct click handler as backup
                    closeBtn.onclick = function(e) {
                        console.log('Close button clicked via onclick');
                        e.preventDefault();
                        e.stopPropagation();
                        
                        closeViewAppointmentDetailsModal();
                    };
                    
                    console.log('Close button enabled and visible');
                }
                
                // Force layout recalculation
                const modal = document.getElementById('viewAppointmentDetailsModal');
                if (modal) {
                    modal.style.display = 'flex';
                    modal.style.visibility = 'visible';
                    modal.style.opacity = '1';
                }
                
                // Debug button visibility
                debugModalButtons();
                
                console.log('All button handlers attached successfully');
            }, 100);
            
            // Show the modal
            viewAppointmentDetailsModalEl.classList.add('active');
        }
        // Closes the View Details modal
        function closeViewAppointmentDetailsModal() {
            console.log('Closing view details modal');
            viewAppointmentDetailsModalEl.classList.remove('active');
            appointmentContextForDetails = null; // Clear context
            
            // Update navigation stack
            popNavigationState();
            
            // Ensure modal is completely hidden
            setTimeout(() => {
                viewAppointmentDetailsModalEl.style.display = 'none';
                viewAppointmentDetailsModalEl.style.visibility = 'hidden';
                viewAppointmentDetailsModalEl.style.opacity = '0';
                
                // Force re-render
                viewAppointmentDetailsModalEl.offsetHeight;
                
                // Reset styles
                viewAppointmentDetailsModalEl.style.display = '';
                viewAppointmentDetailsModalEl.style.visibility = '';
                viewAppointmentDetailsModalEl.style.opacity = '';
                
                console.log('View details modal closed successfully');
            }, 100);
        }
        
        // Handles the delete confirmation and calls deleteAppointment
        function handleDeleteAppointment(apptToDelete, dateKeyOfAppointment) { 
            if (!apptToDelete || !dateKeyOfAppointment) {
                 console.error("Error al eliminar: Faltan datos de la cita o la fecha.");
                 alert("Error: No se pudo identificar la cita a eliminar."); 
                 return;
            }
            // Ask for confirmation
            if (confirm(`¿Estás seguro de que quieres eliminar la cita "${apptToDelete.title}"?`)) {
                console.log('Eliminando cita:', apptToDelete.id, 'en fecha:', dateKeyOfAppointment); 
                deleteAppointment(apptToDelete.id, dateKeyOfAppointment); // Call the actual delete function
                closeViewAppointmentDetailsModal(); // Close the details modal if open
            }
        }

        // Deletes an appointment from the specified dateKey
        function deleteAppointment(appointmentId, dateKey) { 
            console.log('Función deleteAppointment llamada con ID:', appointmentId, 'y dateKey:', dateKey); 
            const userAppointments = getCurrentUserAppointments();
            if (!userAppointments[dateKey]) {
                console.warn("Intento de eliminar cita en una fecha inexistente:", dateKey);
                return; // Exit if the date key doesn't exist
            }
            const initialLength = userAppointments[dateKey].length;
            // Filter out the appointment with the matching ID
            userAppointments[dateKey] = userAppointments[dateKey].filter(appt => appt.id !== appointmentId);
            
            // Check if an appointment was actually removed
            if (userAppointments[dateKey].length < initialLength) { 
                console.log('Cita eliminada exitosamente.'); 
                // If the day's array is now empty, remove the date key entirely
                if (userAppointments[dateKey].length === 0) {
                    delete userAppointments[dateKey]; 
                }
                saveAppointmentsToLocalStorage(); // Save changes
                // --- Re-render Views ---
                const agendaWasVisible = !agendaViewEl.classList.contains('hidden');
                renderMonthView(); // Always update month view dots
                if (agendaWasVisible) { // If agenda view was active, keep it active
                    monthViewEl.classList.add('hidden');
                    agendaViewEl.classList.remove('hidden');
                    // Re-render agenda view only if the deleted appointment was on the currently selected date
                    if (formatDateKey(selectedAgendaDate) === dateKey) { 
                        renderAgendaView();
                    }
                }
            } else {
                // This shouldn't happen if the ID and dateKey were correct
                console.warn("No se pudo encontrar la cita para eliminar con ID:", appointmentId, "en la fecha", dateKey);
                 alert("Error: No se pudo encontrar la cita para eliminar."); 
            }
        }
        
        // User Management Functions
        function updateUserInterface() {
            updateUserPills();
        }
        
        function updateUserPills() {
            userPillsContainer.innerHTML = '';
            Object.entries(users).forEach(([userId, userData]) => {
                const userPillContainer = document.createElement('div');
                userPillContainer.classList.add('relative');
                
                const userPill = document.createElement('button');
                userPill.classList.add('flex', 'items-center', 'space-x-2', 'px-3', 'py-2', 'rounded-full', 'text-sm', 'font-medium', 'transition-all', 'duration-200', 'border', 'cursor-pointer', 'hover:shadow-md');
                
                // Style based on whether it's the current user
                if (userId === currentUserId) {
                    userPill.classList.add('bg-blue-500', 'text-white', 'border-blue-500', 'shadow-md');
                } else {
                    userPill.classList.add('bg-white', 'text-slate-700', 'border-slate-200', 'hover:bg-slate-50', 'hover:border-slate-300');
                }
                
                // Color indicator
                const indicator = document.createElement('div');
                indicator.classList.add('w-3', 'h-3', 'rounded-full', 'flex-shrink-0');
                indicator.style.backgroundColor = userData.color;
                
                // User name
                const name = document.createElement('span');
                name.classList.add('whitespace-nowrap');
                name.textContent = userData.name;
                
                userPill.appendChild(indicator);
                userPill.appendChild(name);
                
                // Single click handler for switching user
                userPill.addEventListener('click', (e) => {
                    // Don't switch if clicking on action menu
                    if (!e.target.closest('.user-context-menu')) {
                        switchToUser(userId);
                    }
                });
                
                // Double click handler for showing context menu
                userPill.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    showUserContextMenu(userId, userPillContainer);
                });
                
                userPillContainer.appendChild(userPill);
                userPillsContainer.appendChild(userPillContainer);
            });
        }
        
        // Show context menu for user actions
        function showUserContextMenu(userId, container) {
            // Remove any existing context menu
            const existingMenu = document.querySelector('.user-context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            const contextMenu = document.createElement('div');
            contextMenu.classList.add('user-context-menu', 'absolute', 'top-full', 'left-0', 'mt-1', 'bg-white', 'rounded-lg', 'shadow-lg', 'border', 'border-slate-200', 'py-1', 'z-50', 'min-w-[120px]');
            
            // Edit option
            const editOption = document.createElement('button');
            editOption.classList.add('w-full', 'text-left', 'px-3', 'py-2', 'text-sm', 'text-slate-700', 'hover:bg-slate-50', 'flex', 'items-center', 'space-x-2', 'transition-colors');
            editOption.innerHTML = '<span>✏️</span><span>Editar</span>';
            editOption.addEventListener('click', (e) => {
                e.stopPropagation();
                openEditUserModal(userId);
                contextMenu.remove();
            });
            
            // Delete option
            const deleteOption = document.createElement('button');
            deleteOption.classList.add('w-full', 'text-left', 'px-3', 'py-2', 'text-sm', 'text-red-600', 'hover:bg-red-50', 'flex', 'items-center', 'space-x-2', 'transition-colors');
            deleteOption.innerHTML = '<span>🗑️</span><span>Eliminar</span>';
            deleteOption.addEventListener('click', (e) => {
                e.stopPropagation();
                openDeleteUserModal(userId);
                contextMenu.remove();
            });
            
            contextMenu.appendChild(editOption);
            contextMenu.appendChild(deleteOption);
            
            container.appendChild(contextMenu);
            
            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!contextMenu.contains(e.target) && !container.contains(e.target)) {
                    contextMenu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            
            // Add event listener after a short delay to prevent immediate closing
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }
        
        function switchToUser(userId) {
            if (userId !== currentUserId) {
                currentUserId = userId;
                localStorage.setItem('currentUserId', currentUserId);
                updateUserInterface(); // This will update the pills to show the new active user
                // Re-render current view with new user's data
                if (!agendaViewEl.classList.contains('hidden')) {
                    renderAgendaView();
                } else {
                    renderMonthView();
                }
            }
        }
        
        function addNewUser() {
            const name = newUserNameInput.value.trim();
            const color = newUserColorInput.value;
            
            if (!name) {
                alert('Por favor, introduce un nombre para el usuario.');
                newUserNameInput.focus();
                return;
            }
            
            // Check if name already exists
            const existingUser = Object.values(users).find(user => user.name.toLowerCase() === name.toLowerCase());
            if (existingUser) {
                alert('Ya existe un usuario con ese nombre.');
                newUserNameInput.focus();
                return;
            }
            
            // Generate new user ID
            const newUserId = 'user_' + Date.now().toString() + Math.random().toString(36).substring(2, 7);
            
            // Add new user
            users[newUserId] = {
                name: name,
                color: color
            };
            
            // Initialize empty data for new user
            if (!appointments[newUserId]) {
                appointments[newUserId] = {};
            }
            if (!durationUsage[newUserId]) {
                durationUsage[newUserId] = {};
            }
            
            saveAppointmentsToLocalStorage();
            switchToUser(newUserId);
            closeAddUserModal();
        }
        
        function openAddUserModal() {
            newUserNameInput.value = '';
            newUserColorInput.value = '#3b82f6';
            addUserModalEl.classList.add('active');
            newUserNameInput.focus();
            
            // Force update modal buttons to ensure they adopt the current theme
            setTimeout(() => {
                updateActiveButtons();
                forceUpdateModalButtons();
            }, 50);
            
            // Additional update to ensure button colors are applied
            setTimeout(() => {
                const buttonColors = JSON.parse(localStorage.getItem('buttonColors')) || { color1: '#667eea', color2: '#764ba2' };
                const gradient = `linear-gradient(135deg, ${buttonColors.color1} 0%, ${buttonColors.color2} 100%)`;
                
                // Force apply button colors to modal buttons
                const saveButton = document.getElementById('saveNewUser');
                if (saveButton) {
                    saveButton.style.setProperty('background', gradient, 'important');
                    saveButton.style.setProperty('color', 'white', 'important');
                }
                
                const cancelButton = document.getElementById('cancelAddUser');
                if (cancelButton) {
                    cancelButton.style.setProperty('background', 'linear-gradient(145deg, #ffffff, #f1f5f9)', 'important');
                    cancelButton.style.setProperty('color', buttonColors.color1, 'important');
                }
            }, 100);
        }
        
        function closeAddUserModal() {
            addUserModalEl.classList.remove('active');
        }
        
        // Edit User Functions
        function openEditUserModal(userId) {
            const userData = users[userId];
            if (!userData) return;
            
            userBeingEdited = userId;
            editUserNameInput.value = userData.name;
            editUserColorInput.value = userData.color;
            editUserModalEl.classList.add('active');
            editUserNameInput.focus();
        }
        
        function closeEditUserModal() {
            editUserModalEl.classList.remove('active');
            userBeingEdited = null;
        }
        
        function saveEditUser() {
            if (!userBeingEdited) return;
            
            const name = editUserNameInput.value.trim();
            const color = editUserColorInput.value;
            
            if (!name) {
                alert('Por favor, introduce un nombre para el usuario.');
                editUserNameInput.focus();
                return;
            }
            
            // Check if name already exists (excluding current user)
            const existingUser = Object.entries(users).find(([userId, userData]) => 
                userId !== userBeingEdited && userData.name.toLowerCase() === name.toLowerCase()
            );
            if (existingUser) {
                alert('Ya existe un usuario con ese nombre.');
                editUserNameInput.focus();
                return;
            }
            
            // Update user data
            users[userBeingEdited] = {
                name: name,
                color: color
            };
            
            saveAppointmentsToLocalStorage();
            updateUserInterface();
            closeEditUserModal();
        }
        
        // Delete User Functions
        function openDeleteUserModal(userId) {
            const userData = users[userId];
            if (!userData) return;
            
            // Don't allow deleting the last user
            if (Object.keys(users).length <= 1) {
                alert('No puedes eliminar el último usuario. Debe haber al menos un usuario en el sistema.');
                return;
            }
            
            userBeingDeleted = userId;
            deleteUserName.textContent = userData.name;
            deleteUserIndicator.style.backgroundColor = userData.color;
            deleteUserModalEl.classList.add('active');
        }
        
        function closeDeleteUserModal() {
            deleteUserModalEl.classList.remove('active');
            userBeingDeleted = null;
        }
        
        function confirmDeleteUser() {
            if (!userBeingDeleted) return;
            
            // Delete user data
            delete users[userBeingDeleted];
            delete appointments[userBeingDeleted];
            delete durationUsage[userBeingDeleted];
            
            // If deleted user was current, switch to first available user
            if (userBeingDeleted === currentUserId) {
                const remainingUsers = Object.keys(users);
                if (remainingUsers.length > 0) {
                    currentUserId = remainingUsers[0];
                    localStorage.setItem('currentUserId', currentUserId);
                }
            }
            
            saveAppointmentsToLocalStorage();
            updateUserInterface();
            
            // Re-render current view
            if (!agendaViewEl.classList.contains('hidden')) {
                renderAgendaView();
            } else {
                renderMonthView();
            }
            
            closeDeleteUserModal();
        }

        // Saves the entire appointments object to localStorage
        function saveAppointmentsToLocalStorage() {
            localStorage.setItem('appointments', JSON.stringify(appointments));
            localStorage.setItem('nextColorIndex', nextColorIndex.toString()); // Save color index too
            localStorage.setItem('durationUsage', JSON.stringify(durationUsage)); // Save duration usage stats
            localStorage.setItem('users', JSON.stringify(users)); // Save users data
            localStorage.setItem('currentUserId', currentUserId); // Save current user
        }
        
        // Gets appointments for current user
        function getCurrentUserAppointments() {
            if (!appointments[currentUserId]) {
                appointments[currentUserId] = {};
            }
            return appointments[currentUserId];
        }
        
        // Gets duration usage for current user
        function getCurrentUserDurationUsage() {
            if (!durationUsage[currentUserId]) {
                durationUsage[currentUserId] = {};
            }
            return durationUsage[currentUserId];
        }
        
        // Updates duration usage statistics when an appointment is saved
        function updateDurationUsage(duration) {
            const userDurationUsage = getCurrentUserDurationUsage();
            if (duration && duration > 0) {
                userDurationUsage[duration] = (userDurationUsage[duration] || 0) + 1;
                durationUsage[currentUserId] = userDurationUsage;
                localStorage.setItem('durationUsage', JSON.stringify(durationUsage));
                updateQuickDurationButtons(); // Update buttons with new stats
            }
        }
        
        // Gets the two most used durations for current user
        function getMostUsedDurations() {
            const userDurationUsage = getCurrentUserDurationUsage();
            const sortedDurations = Object.entries(userDurationUsage)
                .sort(([,a], [,b]) => b - a) // Sort by count descending
                .map(([duration]) => parseInt(duration));
            
            // Default to 30 and 60 if no data exists
            const first = sortedDurations[0] || 30;
            const second = sortedDurations[1] || 60;
            
            return [first, second];
        }
        
        
        // Updates the quick duration buttons with the most used durations
        function updateQuickDurationButtons() {
            const [firstDuration, secondDuration] = getMostUsedDurations();
            const quickDuration30Btn = document.getElementById('quickDuration30');
            const quickDuration60Btn = document.getElementById('quickDuration60');
            
            if (quickDuration30Btn && quickDuration60Btn) {
                quickDuration30Btn.textContent = `${firstDuration}min`;
                quickDuration60Btn.textContent = `${secondDuration}min`;
                
                // Store the actual durations for button functionality
                quickDuration30Btn.dataset.duration = firstDuration;
                quickDuration60Btn.dataset.duration = secondDuration;
            }
        }
        // Formats a Date object into "YYYY-MM-DD" string
        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        // Parses a "YYYY-MM-DD" string back into a Date object
        function parseDateKey(dateKey) { 
            const parts = dateKey.split('-');
            // Month is 0-indexed in Date constructor
            return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
        }

        // --- Search Logic ---
        function performSearch() {
            const query = searchInput.value.trim().toLowerCase();
            if (!query) {
                searchResultsContainerEl.innerHTML = '<p class="text-slate-500">Por favor, introduce un término de búsqueda.</p>';
                openSearchResultsModal();
                return;
            }
            const allFoundAppointments = [];
            const userAppointments = getCurrentUserAppointments();
            // Iterate through all dates and appointments for current user
            Object.keys(userAppointments).forEach(dateKey => {
                userAppointments[dateKey].forEach(appt => {
                    // Check if title includes the query (case-insensitive)
                    if (appt.title.toLowerCase().includes(query)) {
                        // Add the dateKey to the found appointment object
                        allFoundAppointments.push({...appt, dateKey: dateKey }); 
                    }
                });
            });
            displaySearchResults(allFoundAppointments); // Display results
            openSearchResultsModal(); // Show results modal
        }
        function displaySearchResults(foundAppointments) {
            searchResultsContainerEl.innerHTML = ''; // Clear previous results
            if (foundAppointments.length === 0) {
                searchResultsContainerEl.innerHTML = '<p class="text-slate-500">No se encontraron citas con ese título.</p>';
                return;
            }
            // Sort results chronologically
            foundAppointments.sort((a,b) => { 
                const dateA = parseDateKey(a.dateKey).getTime();
                const dateB = parseDateKey(b.dateKey).getTime();
                if (dateA !== dateB) return dateA - dateB; // Sort by date first
                const timeA = a.startHour * 60 + a.startMinute;
                const timeB = b.startHour * 60 + b.startMinute;
                return timeA - timeB; // Then sort by time
            });
            // Create HTML elements for each result
            foundAppointments.forEach(appt => {
                const resultItem = document.createElement('div');
                resultItem.classList.add('search-result-item');
                // Title
                const titleEl = document.createElement('p');
                titleEl.classList.add('font-semibold', 'text-indigo-600', 'text-lg');
                titleEl.textContent = appt.title;
                resultItem.appendChild(titleEl);
                // Date
                const dateObj = parseDateKey(appt.dateKey); 
                const dateEl = document.createElement('p');
                dateEl.classList.add('text-sm', 'text-slate-500');
                dateEl.textContent = `Fecha: ${dateObj.toLocaleDateString('es-ES', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' })}`;
                resultItem.appendChild(dateEl);
                // Time
                const timeEl = document.createElement('p');
                timeEl.classList.add('text-sm', 'text-slate-500');
                const startTimeStr = `${String(appt.startHour).padStart(2, '0')}:${String(appt.startMinute).padStart(2, '0')}`;
                const endTimeStr = formatEndTime(appt.startHour, appt.startMinute, appt.duration);
                timeEl.textContent = `Hora: ${startTimeStr} - ${endTimeStr}`;
                resultItem.appendChild(timeEl);
                // Details Snippet (if exists)
                if (appt.details) {
                    const detailsEl = document.createElement('p');
                    detailsEl.classList.add('text-sm', 'text-slate-600', 'mt-2', 'whitespace-pre-wrap');
                    const snippetLength = 100; // Max length for snippet
                    detailsEl.textContent = `Detalles: ${appt.details.length > snippetLength ? appt.details.substring(0, snippetLength) + '...' : appt.details}`;
                    resultItem.appendChild(detailsEl);
                }
                // Click listener to open the details modal for this result
                resultItem.addEventListener('click', () => {
                    closeSearchResultsModal(); 
                    openViewAppointmentDetailsModal(appt, appt.dateKey); // Pass dateKey
                });
                searchResultsContainerEl.appendChild(resultItem);
            });
        }
        function openSearchResultsModal() {
            // Update navigation stack
            pushNavigationState('modal');
            
            searchResultsModalEl.classList.add('active');
        }
        function closeSearchResultsModal() {
            searchResultsModalEl.classList.remove('active');
            
            // Update navigation stack
            popNavigationState();
        }

        // --- Event Listeners Setup ---
        // Month Navigation
        document.getElementById('prevMonthBtn').addEventListener('click', () => {
            currentDisplayDate.setMonth(currentDisplayDate.getMonth() - 1); renderMonthView();
        });
        document.getElementById('nextMonthBtn').addEventListener('click', () => {
            currentDisplayDate.setMonth(currentDisplayDate.getMonth() + 1); renderMonthView();
        });
        // View Toggles
        document.getElementById('showMonthViewBtn').addEventListener('click', () => {
            currentDisplayDate = new Date(selectedAgendaDate); 
            renderMonthView();
            // Update button states
            setTimeout(() => {
                updateActiveButtons();
            }, 100);
        });
        document.getElementById('showAgendaViewBtn').addEventListener('click', () => {
            selectedAgendaDate = new Date(); 
            selectedAgendaDate.setHours(0,0,0,0); 
            renderAgendaView();
            // Update button states
            setTimeout(() => {
                updateActiveButtons();
            }, 100);
        });
        // Add/Edit Modal Actions
        // View Details Modal Actions
        // Use event delegation for modal buttons to ensure they work
        document.addEventListener('click', (event) => {
            // Handle edit button clicks
            if (event.target && event.target.id === 'editAppointmentBtn') {
                console.log('Edit button clicked via delegation');
                event.preventDefault();
                event.stopPropagation();
                
                if (appointmentContextForDetails) { 
                    const apptData = appointmentContextForDetails.data;
                    const apptDateKey = appointmentContextForDetails.dateKey; 
                    const dateOfAppointment = parseDateKey(apptDateKey); 
                    // Open the add/edit modal in edit mode
                    openAddAppointmentModal(dateOfAppointment, apptData.startHour, apptData.startMinute, 0, apptData);
                    closeViewAppointmentDetailsModal(); // Close details modal
                }
            }
            
            // Handle delete button clicks
            if (event.target && event.target.id === 'deleteAppointmentFromDetailsBtn') {
                console.log('Delete button clicked via delegation');
                event.preventDefault();
                event.stopPropagation();
                
                if (appointmentContextForDetails) {
                    handleDeleteAppointment(appointmentContextForDetails.data, appointmentContextForDetails.dateKey);
                }
            }
            
            // Handle close button clicks
            if (event.target && event.target.id === 'closeViewAppointmentDetails') {
                console.log('Close button clicked via delegation');
                event.preventDefault();
                event.stopPropagation();
                
                closeViewAppointmentDetailsModal();
            }
            
            // Handle add/edit modal buttons
            if (event.target && event.target.id === 'cancelAddAppointment') {
                console.log('Cancel button clicked via delegation');
                event.preventDefault();
                event.stopPropagation();
                
                closeAddAppointmentModal();
            }
            
            if (event.target && event.target.id === 'saveAppointment') {
                console.log('Save button clicked via delegation');
                console.log('Button element:', event.target);
                console.log('Button text:', event.target.textContent);
                console.log('Current appointment context:', currentAppointmentContext);
                event.preventDefault();
                event.stopPropagation();
                
                try {
                    saveCurrentAppointment();
                    console.log('saveCurrentAppointment executed successfully');
                } catch (error) {
                    console.error('Error in saveCurrentAppointment:', error);
                }
            }
        });
        // Search Actions
        searchIconBtn.addEventListener('click', () => { // Toggle search bar visibility
            searchBarContainer.classList.toggle('hidden');
            if (!searchBarContainer.classList.contains('hidden')) {
                searchInput.focus(); // Focus input when shown
            }
        });
        searchAppointmentBtn.addEventListener('click', performSearch); // Search button click
        searchInput.addEventListener('keypress', (event) => { // Search on Enter key
            if (event.key === 'Enter') performSearch();
        });
        closeSearchResultsModalBtn.addEventListener('click', closeSearchResultsModal); // Close search results
        // Update time info when start time selects change
        appointmentStartHourSelect.addEventListener('change', updateAppointmentTimeInfo);
        appointmentStartMinuteSelect.addEventListener('change', updateAppointmentTimeInfo);
        
        // Update time info when work type changes
        appointmentWorkTypeSelect.addEventListener('change', updateAppointmentTimeInfo);
        
        // Update time info when date changes (for editing)
        appointmentDateInput.addEventListener('change', updateAppointmentTimeInfo);
        
        // Update time info when user changes (for transfer)
        appointmentUserSelect.addEventListener('change', updateAppointmentTimeInfo);
        
        // User Management Event Listeners
        addUserBtn.addEventListener('click', openAddUserModal);
        saveNewUserBtn.addEventListener('click', addNewUser);
        cancelAddUserBtn.addEventListener('click', closeAddUserModal);
        
        // Edit User Event Listeners
        saveEditUserBtn.addEventListener('click', saveEditUser);
        cancelEditUserBtn.addEventListener('click', closeEditUserModal);
        
        // Delete User Event Listeners
        confirmDeleteUserBtn.addEventListener('click', confirmDeleteUser);
        cancelDeleteUserBtn.addEventListener('click', closeDeleteUserModal);
        
        // Color Configuration Event Listeners
        document.getElementById('configBtn').addEventListener('click', openColorConfigModal);
        document.getElementById('closeColorConfig').addEventListener('click', closeColorConfigModal);
        document.getElementById('applyColors').addEventListener('click', applyAllChanges);
        document.getElementById('resetColors').addEventListener('click', resetTheme);
        
        // Color picker event listeners
        ['color1', 'color2', 'primaryText', 'secondaryText', 'buttonColor1', 'buttonColor2'].forEach(colorId => {
            const picker = document.getElementById(`${colorId}Picker`);
            const hexInput = document.getElementById(`${colorId}Hex`);
            const rInput = document.getElementById(`${colorId}R`);
            const gInput = document.getElementById(`${colorId}G`);
            const bInput = document.getElementById(`${colorId}B`);
            
            if (picker) {
                picker.addEventListener('input', (e) => {
                    updateColorPreview(colorId, e.target.value);
                    if (colorId === 'color1' || colorId === 'color2') {
                        updateGradientPreview();
                    }
                    if (colorId === 'primaryText' || colorId === 'secondaryText') {
                        updateTextPreview();
                    }
                });
            }
            
            if (hexInput) {
                hexInput.addEventListener('input', (e) => {
                    if (/^#[0-9A-Fa-f]{6}$/.test(e.target.value)) {
                        updateColorPreview(colorId, e.target.value);
                        if (colorId === 'color1' || colorId === 'color2') {
                            updateGradientPreview();
                        }
                        if (colorId === 'primaryText' || colorId === 'secondaryText') {
                            updateTextPreview();
                        }
                    }
                });
            }
            
            [rInput, gInput, bInput].forEach((input, index) => {
                if (input) {
                    input.addEventListener('input', () => {
                        const r = parseInt(rInput.value) || 0;
                        const g = parseInt(gInput.value) || 0;
                        const b = parseInt(bInput.value) || 0;
                        const hex = rgbToHex(r, g, b);
                        updateColorPreview(colorId, hex);
                        if (colorId === 'color1' || colorId === 'color2') {
                            updateGradientPreview();
                        }
                        if (colorId === 'primaryText' || colorId === 'secondaryText') {
                            updateTextPreview();
                        }
                    });
                }
            });
        });
        
        // Preset theme buttons
        document.querySelectorAll('.preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.preset;
                const theme = themes[preset];
                if (theme) {
                    const colors = theme.background.match(/#[a-fA-F0-9]{6}/g);
                    if (colors && colors.length >= 2) {
                        updateColorPreview('color1', colors[0]);
                        updateColorPreview('color2', colors[1]);
                        updateGradientPreview();
                    }
                }
            });
        });
        
        // Text preset buttons
        document.querySelectorAll('.text-preset-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const preset = btn.dataset.textPreset;
                if (preset === 'dark') {
                    updateColorPreview('primaryText', '#1f2937');
                    updateColorPreview('secondaryText', '#6b7280');
                } else if (preset === 'light') {
                    updateColorPreview('primaryText', '#f9fafb');
                    updateColorPreview('secondaryText', '#e5e7eb');
                }
                updateTextPreview();
            });
        });
        
        // Close modals when clicking outside
        addUserModalEl.addEventListener('click', (event) => {
            if (event.target === addUserModalEl) {
                closeAddUserModal();
            }
        });
        
        editUserModalEl.addEventListener('click', (event) => {
            if (event.target === editUserModalEl) {
                closeEditUserModal();
            }
        });
        
        deleteUserModalEl.addEventListener('click', (event) => {
            if (event.target === deleteUserModalEl) {
                closeDeleteUserModal();
            }
        });
        
        // Color config modal click outside to close
        document.getElementById('colorConfigModal').addEventListener('click', (event) => {
            if (event.target === document.getElementById('colorConfigModal')) {
                closeColorConfigModal();
            }
        });
        
        // Date Selector Wheel Navigation
        
        // Click on date display to navigate (tap to change date)
        const currentDateDisplay = document.getElementById('currentDateDisplay');
        if (currentDateDisplay) {
            currentDateDisplay.addEventListener('click', () => {
                // Cycle through dates: today -> tomorrow -> yesterday -> today
                const today = new Date();
                const tomorrow = new Date(today);
                tomorrow.setDate(today.getDate() + 1);
                const yesterday = new Date(today);
                yesterday.setDate(today.getDate() - 1);
                
                if (selectedAgendaDate.toDateString() === today.toDateString()) {
                    navigateToDate(tomorrow);
                } else if (selectedAgendaDate.toDateString() === tomorrow.toDateString()) {
                    navigateToDate(yesterday);
                } else {
                    navigateToDate(today);
                }
            });
        }
        
        // Mouse wheel navigation on the date selector wheel
        dateSelectorWheelEl.addEventListener('wheel', (event) => {
            event.preventDefault(); // Prevent page scrolling
            const delta = event.deltaY;
            
            if (delta > 0) {
                // Scroll down - go to next date
                const nextDate = new Date(selectedAgendaDate);
                nextDate.setDate(nextDate.getDate() + 1);
                navigateToDate(nextDate);
            } else {
                // Scroll up - go to previous date
                const prevDate = new Date(selectedAgendaDate);
                prevDate.setDate(prevDate.getDate() - 1);
                navigateToDate(prevDate);
            }
        });
        
        // Touch gesture event listeners for mobile swipe navigation
        // Add touch events to the entire agenda view for better mobile experience
        agendaViewEl.addEventListener('touchstart', handleTouchStart, { passive: true });
        agendaViewEl.addEventListener('touchmove', handleTouchMove, { passive: false });
        agendaViewEl.addEventListener('touchend', handleTouchEnd, { passive: true });

        // Also add touch events specifically to the date selector wheel for more precise control
        dateSelectorWheelEl.addEventListener('touchstart', handleTouchStart, { passive: false });
        dateSelectorWheelEl.addEventListener('touchmove', handleTouchMove, { passive: false });
        dateSelectorWheelEl.addEventListener('touchend', handleTouchEnd, { passive: true });
        
        // Quick duration buttons functionality
        document.getElementById('quickDuration30').addEventListener('click', () => {
            const buttonDuration = parseInt(document.getElementById('quickDuration30').dataset.duration) || 30;
            const maxDuration = currentAppointmentContext ? currentAppointmentContext.currentMaxDuration : 1440;
            const duration = Math.min(buttonDuration, maxDuration);
            appointmentDurationInput.value = duration;
            if (currentAppointmentContext) {
                updateAppointmentTimeInfo();
            }
        });
        
        document.getElementById('quickDuration60').addEventListener('click', () => {
            const buttonDuration = parseInt(document.getElementById('quickDuration60').dataset.duration) || 60;
            const maxDuration = currentAppointmentContext ? currentAppointmentContext.currentMaxDuration : 1440;
            const duration = Math.min(buttonDuration, maxDuration);
            appointmentDurationInput.value = duration;
            if (currentAppointmentContext) {
                updateAppointmentTimeInfo();
            }
        });
        // Global keydown listener (for Escape key to close modals)
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                if (addAppointmentModalEl.classList.contains('active')) closeAddAppointmentModal();
                if (viewAppointmentDetailsModalEl.classList.contains('active')) closeViewAppointmentDetailsModal();
                if (searchResultsModalEl.classList.contains('active')) closeSearchResultsModal();
                if (document.getElementById('colorConfigModal').classList.contains('active')) closeColorConfigModal();
            }
        });
        // Click outside modals to close
        addAppointmentModalEl.addEventListener('click', (event) => { 
            if (event.target === addAppointmentModalEl) closeAddAppointmentModal();
        });
        viewAppointmentDetailsModalEl.addEventListener('click', (event) => { 
            if (event.target === viewAppointmentDetailsModalEl) closeViewAppointmentDetailsModal();
        });
        searchResultsModalEl.addEventListener('click', (event) => { 
            if (event.target === searchResultsModalEl) closeSearchResultsModal();
        });

        // --- Initialization ---
        populateTimeSelects(); // Populate time selects on load
        updateUserInterface(); // Initialize user interface
        updateQuickDurationButtons(); // Initialize quick duration buttons with most used durations
        renderMonthView(); // Initial render
        
        // Initialize theme
        if (currentTheme === 'custom') {
            const customTheme = JSON.parse(localStorage.getItem('customTheme'));
            if (customTheme) {
                applyCustomTheme(customTheme.color1, customTheme.color2);
            } else {
                applyTheme('default');
            }
        } else {
            applyTheme(currentTheme);
        }
        
        // Initialize text colors
        const primaryTextColor = localStorage.getItem('primaryTextColor') || '#1f2937';
        const secondaryTextColor = localStorage.getItem('secondaryTextColor') || '#6b7280';
        applyTextColors(primaryTextColor, secondaryTextColor);

        // Register Service Worker for PWA with Android optimizations
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js')
              .then(registration => {
                console.log('ServiceWorker registrado con éxito:', registration.scope);
                
                // Handle updates
                registration.addEventListener('updatefound', () => {
                  const newWorker = registration.installing;
                  newWorker.addEventListener('statechange', () => {
                    if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                      // New content is available, prompt user to refresh
                      if (confirm('Nueva versión disponible. ¿Recargar la página?')) {
                        window.location.reload();
                      }
                    }
                  });
                });
              })
              .catch(error => console.log('Error al registrar ServiceWorker:', error));
          });
        }

        // PWA Install Prompt for Android
        let deferredPrompt;
        let installButton;

        window.addEventListener('beforeinstallprompt', (e) => {
          console.log('PWA install prompt disponible');
          // Prevent Chrome 67 and earlier from automatically showing the prompt
          e.preventDefault();
          // Stash the event so it can be triggered later
          deferredPrompt = e;
          
          // Show install button or banner
          showInstallButton();
        });

        function showInstallButton() {
          // Create install button if it doesn't exist
          if (!installButton) {
            installButton = document.createElement('button');
            installButton.textContent = '📱 Instalar App';
            installButton.className = 'fixed bottom-4 right-4 bg-blue-500 hover:bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-all';
            installButton.style.display = 'none';
            document.body.appendChild(installButton);
            
            installButton.addEventListener('click', async () => {
              if (deferredPrompt) {
                // Show the install prompt
                deferredPrompt.prompt();
                // Wait for the user to respond to the prompt
                const { outcome } = await deferredPrompt.userChoice;
                console.log(`User response to the install prompt: ${outcome}`);
                // Clear the deferredPrompt so it can only be used once
                deferredPrompt = null;
                // Hide the install button
                installButton.style.display = 'none';
              }
            });
          }
          
          // Show the button
          installButton.style.display = 'block';
        }

        // Handle successful installation
        window.addEventListener('appinstalled', (evt) => {
          console.log('PWA instalada exitosamente');
          // Hide install button
          if (installButton) {
            installButton.style.display = 'none';
          }
          // Show success message
          showNotification('¡App instalada exitosamente!');
        });

        // Debug function to check if all required elements are present
        function debugCheckElements() {
          const requiredElements = [
            'agendaView',
            'agendaSlotsContainer', 
            'singleScheduleContainer',
            'currentDateDisplay'
          ];
          
          const missingElements = [];
          requiredElements.forEach(id => {
            const element = document.getElementById(id);
            if (!element) {
              missingElements.push(id);
            }
          });
          
          if (missingElements.length > 0) {
            console.error('Elementos faltantes:', missingElements);
            return false;
          }
          
          console.log('Todos los elementos requeridos están presentes');
          return true;
        }
        
        // Initialize the application
        // Make important functions globally available
        window.saveCurrentAppointment = saveCurrentAppointment;
        window.closeAddAppointmentModal = closeAddAppointmentModal;
        window.closeViewAppointmentDetailsModal = closeViewAppointmentDetailsModal;
        window.openAddAppointmentModal = openAddAppointmentModal;
        window.parseDateKey = parseDateKey;
        window.handleDeleteAppointmentFromDetails = handleDeleteAppointmentFromDetails;
        
        console.log('Important functions made globally available');
        
        window.addEventListener('load', () => {
          try {
            // Debug check
            if (!debugCheckElements()) {
              throw new Error('Elementos requeridos faltantes');
            }
            
            // Initialize default view
            renderAgendaView();
            
            // Update active buttons
            setTimeout(() => {
              updateActiveButtons();
            }, 100);
            
            console.log('Aplicación inicializada correctamente');
          } catch (error) {
            console.error('Error al inicializar la aplicación:', error);
            // Show error message to user
            showNotification('Error al cargar la aplicación. Recarga la página.');
          }
          
          // Check if app is already installed
          if (window.matchMedia('(display-mode: standalone)').matches) {
            console.log('App ejecutándose en modo standalone');
            // Hide install button if already installed
            if (installButton) {
              installButton.style.display = 'none';
            }
          }
        });
    </script>

</body>
</html>
