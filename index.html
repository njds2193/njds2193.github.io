<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agenda Web</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3b82f6">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }
        /* Touch gesture optimization for mobile */
        #agendaView {
            touch-action: pan-y; /* Allow vertical scrolling but handle horizontal swipes */
        }
        #dateSelectorWheel {
            touch-action: none; /* Disable default touch behaviors for precise swipe control */
        }
        .time-slot {
            display: flex;
            height: 40px; /* Fixed height for time slots */
            border: 1px solid #e2e8f0; /* Tailwind slate-200 */
            border-radius: 0.375rem; /* Tailwind rounded-md */
            overflow: hidden; /* Contain segments */
        }
        .time-segment {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; /* Tailwind text-xs */
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: default; /* Default cursor */
        }
        .free-segment {
            background-color: #f0f9ff; /* Tailwind sky-50 */
            cursor: pointer; /* Clickable */
            transition: background-color 0.2s;
            color: #0ea5e9; /* Tailwind sky-600 */
        }
        .free-segment:hover {
            background-color: #e0f2fe; /* Tailwind sky-100 */
        }
        .booked-segment {
            padding-left: 4px;
            padding-right: 4px;
            cursor: pointer; /* Clickable to view details */
        }
        .booked-segment:hover {
            filter: brightness(105%); /* Slight brightness increase on hover */
        }
        /* Text color classes based on background brightness */
        .booked-segment.dark-text { 
            color: #1f2937; /* Tailwind gray-800 */
        }
        .booked-segment.light-text { 
            color: #f9fafb; /* Tailwind gray-50 */
        }
        /* Delete button text color classes */
        .booked-segment .delete-btn.dark-text {
             color: #4b5563; /* Tailwind gray-600 */
        }
        .booked-segment .delete-btn.dark-text:hover {
            color: #dc2626; /* Tailwind red-600 */
        }
        .booked-segment .delete-btn.light-text {
            color: #e5e7eb; /* Tailwind gray-200 */
        }
        .booked-segment .delete-btn.light-text:hover {
            color: #fecaca; /* Tailwind red-200 */
        }

        /* Modal styles */
        .modal {
            display: none; /* Hidden by default */
        }
        .modal.active {
            display: flex; /* Show when active */
        }
        /* Custom scrollbar styles */
        .agenda-slots-container::-webkit-scrollbar,
        #searchResultsContainer::-webkit-scrollbar {
            width: 8px;
        }
        .agenda-slots-container::-webkit-scrollbar-track,
        #searchResultsContainer::-webkit-scrollbar-track {
            background: #f1f5f9; /* Tailwind slate-100 */
        }
        .agenda-slots-container::-webkit-scrollbar-thumb,
        #searchResultsContainer::-webkit-scrollbar-thumb {
            background: #94a3b8; /* Tailwind slate-400 */
            border-radius: 4px;
        }
        .agenda-slots-container::-webkit-scrollbar-thumb:hover,
        #searchResultsContainer::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* Tailwind slate-500 */
        }
        /* Style for details content in modal */
        .details-content {
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            max-height: 200px; /* Limit height */
            overflow-y: auto; /* Add scroll if needed */
            background-color: #f9fafb; /* Tailwind gray-50 */
            border: 1px solid #e5e7eb; /* Tailwind gray-200 */
            padding: 8px;
            border-radius: 0.25rem; /* Tailwind rounded-sm */
        }
        /* Style for search result items */
        .search-result-item {
            border: 1px solid #e5e7eb; /* Tailwind gray-200 */
            border-radius: 0.375rem; /* Tailwind rounded-md */
            padding: 0.75rem; /* Tailwind p-3 */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .search-result-item:hover {
            background-color: #f9fafb; /* Tailwind gray-50 */
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 antialiased">

    <div id="app-container" class="container mx-auto p-4 max-w-4xl">

        <div class="mb-6 p-4 bg-white rounded-xl shadow-lg">
            <div class="flex justify-between items-center mb-3">
                <div class="flex flex-col space-y-3">
                    <div class="flex items-center justify-between">
                        <h3 class="text-lg font-semibold text-slate-700">Agenda</h3>
                        <button id="addUserBtn" class="p-2 text-slate-500 hover:text-blue-600 hover:bg-blue-50 rounded-full transition-colors" title="Agregar Usuario">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" />
                            </svg>
                        </button>
                    </div>
                    
                    <!-- User Pills Selector -->
                    <div id="userPillsContainer" class="flex flex-wrap gap-2 items-center">
                        <!-- User pills will be populated here -->
                    </div>
                </div>
                <button id="searchIconBtn" aria-label="Abrir búsqueda de citas" class="p-2 text-slate-600 hover:text-indigo-600 transition-colors rounded-full hover:bg-indigo-100">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
                    </svg>
                </button>
            </div>
            <div id="searchBarContainer" class="hidden"> 
                <div class="flex flex-col sm:flex-row items-stretch space-y-3 sm:space-y-0 sm:space-x-3">
                    <input type="text" id="searchInput" placeholder="Buscar por título..." class="flex-grow p-2 border border-slate-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500">
                    <button id="searchAppointmentBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 inline-block mr-1">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
                        </svg>
                        Buscar
                    </button>
                </div>
            </div>
        </div>

        <div class="mb-6 flex justify-center space-x-4">
            <button id="showMonthViewBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out">Vista Mensual</button>
            <button id="showAgendaViewBtn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out">Vista Agenda (Hoy)</button>
        </div>

        <div id="monthView" class="bg-white p-6 rounded-xl shadow-lg">
            <div class="flex justify-between items-center mb-4">
                <button id="prevMonthBtn" class="text-blue-500 hover:text-blue-700 p-2 rounded-full transition">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                    </svg>
                </button>
                <h2 id="currentMonthYear" class="text-2xl font-bold text-slate-700"></h2>
                <button id="nextMonthBtn" class="text-blue-500 hover:text-blue-700 p-2 rounded-full transition">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                    </svg>
                </button>
            </div>
            <div id="calendarGrid" class="grid grid-cols-7 gap-1 text-center">
                </div>
        </div>

        <div id="agendaView" class="hidden bg-white p-6 rounded-xl shadow-lg mt-6">
            <h2 id="agendaDateTitle" class="text-2xl font-bold text-slate-700 mb-4 text-center">Agenda para: </h2>
            
            <!-- Date Selector Wheel -->
            <div id="dateSelectorWheel" class="flex justify-center items-center space-x-4 mb-6 p-4 bg-slate-50 rounded-lg border border-slate-200">
                <div id="prevDateBtn" class="p-2 text-slate-500 hover:text-slate-700 hover:bg-slate-200 rounded-full transition-colors cursor-pointer">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                    </svg>
                </div>
                
                <div id="dateWheelContainer" class="flex items-center space-x-2 overflow-hidden">
                    <div id="prevDate" class="date-wheel-item text-sm text-slate-500 bg-white px-3 py-2 rounded-md border border-slate-200 shadow-sm min-w-[100px] text-center">
                        <!-- Previous date will be populated here -->
                    </div>
                    <div id="currentDate" class="date-wheel-item text-base font-semibold text-slate-700 bg-blue-50 px-4 py-2 rounded-md border-2 border-blue-300 shadow-md min-w-[120px] text-center">
                        <!-- Current date will be populated here -->
                    </div>
                    <div id="nextDate" class="date-wheel-item text-sm text-slate-500 bg-white px-3 py-2 rounded-md border border-slate-200 shadow-sm min-w-[100px] text-center">
                        <!-- Next date will be populated here -->
                    </div>
                </div>
                
                <div id="nextDateBtn" class="p-2 text-slate-500 hover:text-slate-700 hover:bg-slate-200 rounded-full transition-colors cursor-pointer">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                    </svg>
                </div>
            </div>
            <div class="flex border-b pb-2 mb-2">
                <div class="w-1/4 font-semibold text-slate-600 pl-2">Hora</div>
                <div class="w-3/4 font-semibold text-slate-600 pl-2">Actividad</div>
            </div>
            <div id="agendaSlotsContainer" class="space-y-1 max-h-[70vh] overflow-y-auto agenda-slots-container pr-2">
                </div>
        </div>
    </div>

    <div id="addAppointmentModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 id="modalTitle" class="text-xl font-semibold mb-4 text-slate-700">Añadir Nueva Cita</h3>
            
            <!-- Date selector (only shown when editing) -->
            <div id="appointmentDateContainer" class="mb-4 hidden">
                <label for="appointmentDate" class="block text-sm font-medium text-slate-600 mb-1">Fecha:</label>
                <input type="date" id="appointmentDate" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
            </div>
            
            <!-- User transfer selector (only shown when editing) -->
            <div id="appointmentUserContainer" class="mb-4 hidden">
                <label for="appointmentUser" class="block text-sm font-medium text-slate-600 mb-1">Transferir a Usuario:</label>
                <select id="appointmentUser" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white">
                    <option value="">Mantener en usuario actual</option>
                    <!-- User options will be populated here -->
                </select>
            </div>
            
            <div class="mb-4">
                <label for="appointmentTitle" class="block text-sm font-medium text-slate-600 mb-1">Título de la Cita:</label>
                <input type="text" id="appointmentTitle" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
            </div>
            
            <div class="flex space-x-3 mb-4">
                <div class="w-1/2">
                    <label for="appointmentStartHour" class="block text-sm font-medium text-slate-600 mb-1">Hora Inicio:</label>
                    <select id="appointmentStartHour" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white">
                        </select>
                </div>
                <div class="w-1/2">
                    <label for="appointmentStartMinute" class="block text-sm font-medium text-slate-600 mb-1">Minuto Inicio:</label>
                    <select id="appointmentStartMinute" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white">
                        </select>
                </div>
            </div>

            <div class="mb-4">
                <label for="appointmentDuration" class="block text-sm font-medium text-slate-600 mb-1">Duración (minutos):</label>
                <div class="flex items-center space-x-2">
                    <input type="number" id="appointmentDuration" min="1" value="30" class="flex-1 p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                    <button type="button" id="quickDuration30" class="px-3 py-2 text-sm bg-blue-100 hover:bg-blue-200 text-blue-700 font-medium rounded-md transition-colors duration-150 border border-blue-300">
                        30min
                    </button>
                    <button type="button" id="quickDuration60" class="px-3 py-2 text-sm bg-green-100 hover:bg-green-200 text-green-700 font-medium rounded-md transition-colors duration-150 border border-green-300">
                        60min
                    </button>
                </div>
            </div>
            <div class="mb-4">
                <label for="appointmentDetails" class="block text-sm font-medium text-slate-600 mb-1">Detalles (opcional):</label>
                <textarea id="appointmentDetails" rows="3" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500"></textarea>
            </div>
            <p id="appointmentTimeInfo" class="text-sm text-slate-500 mb-4"></p>
            <div class="flex justify-end space-x-3">
                <button id="cancelAddAppointment" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-medium py-2 px-4 rounded-md transition">Cancelar</button>
                <button id="saveAppointment" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition">Guardar Cita</button>
            </div>
        </div>
    </div>

    <div id="viewAppointmentDetailsModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 id="viewAppointmentTitle" class="text-xl font-semibold mb-2 text-slate-700"></h3>
            <p id="viewAppointmentTime" class="text-sm text-slate-500 mb-1"></p>
            <p id="viewAppointmentDuration" class="text-sm text-slate-500 mb-3"></p>
            <h4 class="text-md font-semibold text-slate-600 mb-1">Detalles:</h4>
            <div id="viewAppointmentDetailsContent" class="details-content mb-4 text-sm text-slate-700"></div>
            <div class="flex justify-between items-center"> 
                <div>
                    <button id="editAppointmentBtn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-md transition mr-2">Editar</button>
                    <button id="deleteAppointmentFromDetailsBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md transition">Eliminar</button>
                </div>
                <button id="closeViewAppointmentDetails" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="searchResultsModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg max-h-[80vh] flex flex-col">
            <h3 class="text-xl font-semibold mb-4 text-slate-700">Resultados de la Búsqueda</h3>
            <div id="searchResultsContainer" class="flex-grow overflow-y-auto space-y-3 mb-4 pr-2">
                </div>
            <div class="flex justify-end">
                <button id="closeSearchResultsModal" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-md transition">Cerrar</button>
            </div>
        </div>
    </div>

    <!-- Add User Modal -->
    <div id="addUserModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4 text-slate-700">Agregar Nuevo Usuario</h3>
            <div class="mb-4">
                <label for="newUserName" class="block text-sm font-medium text-slate-600 mb-1">Nombre del Usuario:</label>
                <input type="text" id="newUserName" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="Ej: María, Juan, etc.">
            </div>
            <div class="mb-4">
                <label for="newUserColor" class="block text-sm font-medium text-slate-600 mb-1">Color de Identificación:</label>
                <div class="flex space-x-2">
                    <input type="color" id="newUserColor" value="#3b82f6" class="w-12 h-10 border border-slate-300 rounded-md cursor-pointer">
                    <div class="flex-1 p-2 border border-slate-300 rounded-md bg-slate-50 text-slate-600 text-sm">
                        Selecciona un color para identificar fácilmente este usuario
                    </div>
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="cancelAddUser" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-medium py-2 px-4 rounded-md transition">Cancelar</button>
                <button id="saveNewUser" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition">Agregar Usuario</button>
            </div>
        </div>
    </div>

    <!-- Edit User Modal -->
    <div id="editUserModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4 text-slate-700">Editar Usuario</h3>
            <div class="mb-4">
                <label for="editUserName" class="block text-sm font-medium text-slate-600 mb-1">Nombre del Usuario:</label>
                <input type="text" id="editUserName" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500" placeholder="Ej: María, Juan, etc.">
            </div>
            <div class="mb-4">
                <label for="editUserColor" class="block text-sm font-medium text-slate-600 mb-1">Color de Identificación:</label>
                <div class="flex space-x-2">
                    <input type="color" id="editUserColor" value="#3b82f6" class="w-12 h-10 border border-slate-300 rounded-md cursor-pointer">
                    <div class="flex-1 p-2 border border-slate-300 rounded-md bg-slate-50 text-slate-600 text-sm">
                        Selecciona un color para identificar fácilmente este usuario
                    </div>
                </div>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="cancelEditUser" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-medium py-2 px-4 rounded-md transition">Cancelar</button>
                <button id="saveEditUser" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition">Guardar Cambios</button>
            </div>
        </div>
    </div>

    <!-- Delete User Confirmation Modal -->
    <div id="deleteUserModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 class="text-xl font-semibold mb-4 text-slate-700">Eliminar Usuario</h3>
            <div class="mb-4">
                <div class="flex items-center space-x-3 mb-3">
                    <div id="deleteUserIndicator" class="w-4 h-4 rounded-full"></div>
                    <span id="deleteUserName" class="text-lg font-medium text-slate-700"></span>
                </div>
                <p class="text-slate-600 text-sm">
                    ¿Estás seguro de que quieres eliminar este usuario? Esta acción eliminará permanentemente:
                </p>
                <ul class="list-disc list-inside text-slate-600 text-sm mt-2 ml-4">
                    <li>Todas las citas del usuario</li>
                    <li>El historial de duraciones utilizadas</li>
                    <li>La configuración personal del usuario</li>
                </ul>
                <p class="text-red-600 text-sm font-medium mt-3">
                    ⚠️ Esta acción no se puede deshacer.
                </p>
            </div>
            <div class="flex justify-end space-x-3">
                <button id="cancelDeleteUser" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-medium py-2 px-4 rounded-md transition">Cancelar</button>
                <button id="confirmDeleteUser" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md transition">Eliminar Usuario</button>
            </div>
        </div>
    </div>


    <script>
        // --- Application State ---
        let currentDisplayDate = new Date(); // Date for month view
        let selectedAgendaDate = new Date(); // Date for agenda view
        selectedAgendaDate.setHours(0, 0, 0, 0); // Normalize to midnight
        // Multi-user management
        let currentUserId = localStorage.getItem('currentUserId') || 'default';
        let users = JSON.parse(localStorage.getItem('users')) || { 'default': { name: 'Usuario Principal', color: '#3b82f6' } };
        
        // Appointments stored per user: { userId: { "YYYY-MM-DD": [ { id, title, startHour, startMinute, duration, color, details } ] } }
        let appointments = JSON.parse(localStorage.getItem('appointments')) || {};
        
        // Duration usage tracking per user: { userId: { duration: count } }
        let durationUsage = JSON.parse(localStorage.getItem('durationUsage')) || {};
        
        // Color palette for appointments
        const distinctColors = [
            '#EF5350', '#42A5F5', '#66BB6A', '#FFA726', '#AB47BC', 
            '#29B6F6', '#FFEE58', '#26A69A', '#EC407A', '#7E57C2'
        ];
        // Function to determine if a color is light (needs dark text)
        function isColorLight(hexColor) {
            if (!hexColor || hexColor.length < 7) return true; // Default to dark text if color is invalid
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return yiq >= 128;
        }
        let nextColorIndex = parseInt(localStorage.getItem('nextColorIndex') || '0');

        // --- DOM Element References ---
        const monthViewEl = document.getElementById('monthView');
        const agendaViewEl = document.getElementById('agendaView');
        const currentMonthYearEl = document.getElementById('currentMonthYear');
        const calendarGridEl = document.getElementById('calendarGrid');
        const agendaSlotsContainerEl = document.getElementById('agendaSlotsContainer');
        const agendaDateTitleEl = document.getElementById('agendaDateTitle');
        // Date Selector Wheel Elements
        const dateSelectorWheelEl = document.getElementById('dateSelectorWheel');
        const prevDateBtnEl = document.getElementById('prevDateBtn');
        const nextDateBtnEl = document.getElementById('nextDateBtn');
        const prevDateEl = document.getElementById('prevDate');
        const currentDateEl = document.getElementById('currentDate');
        const nextDateEl = document.getElementById('nextDate');
        // Add/Edit Modal Elements
        const addAppointmentModalEl = document.getElementById('addAppointmentModal');
        const modalTitleEl = document.getElementById('modalTitle'); 
        const appointmentDateContainer = document.getElementById('appointmentDateContainer');
        const appointmentDateInput = document.getElementById('appointmentDate');
        const appointmentUserContainer = document.getElementById('appointmentUserContainer');
        const appointmentUserSelect = document.getElementById('appointmentUser');
        const appointmentTitleInput = document.getElementById('appointmentTitle');
        const appointmentStartHourSelect = document.getElementById('appointmentStartHour'); 
        const appointmentStartMinuteSelect = document.getElementById('appointmentStartMinute'); 
        const appointmentDurationInput = document.getElementById('appointmentDuration');
        const appointmentDetailsInput = document.getElementById('appointmentDetails'); 
        const appointmentTimeInfoEl = document.getElementById('appointmentTimeInfo');
        const saveAppointmentBtn = document.getElementById('saveAppointment');
        // View Details Modal Elements
        const viewAppointmentDetailsModalEl = document.getElementById('viewAppointmentDetailsModal');
        const viewAppointmentTitleEl = document.getElementById('viewAppointmentTitle');
        const viewAppointmentTimeEl = document.getElementById('viewAppointmentTime');
        const viewAppointmentDurationEl = document.getElementById('viewAppointmentDuration');
        const viewAppointmentDetailsContentEl = document.getElementById('viewAppointmentDetailsContent');
        const editAppointmentBtn = document.getElementById('editAppointmentBtn'); 
        const deleteAppointmentFromDetailsBtn = document.getElementById('deleteAppointmentFromDetailsBtn'); 
        // Search Elements
        const searchIconBtn = document.getElementById('searchIconBtn');
        const searchBarContainer = document.getElementById('searchBarContainer');
        const searchInput = document.getElementById('searchInput');
        const searchAppointmentBtn = document.getElementById('searchAppointmentBtn');
        const searchResultsModalEl = document.getElementById('searchResultsModal');
        const searchResultsContainerEl = document.getElementById('searchResultsContainer');
        const closeSearchResultsModalBtn = document.getElementById('closeSearchResultsModal');
        // User Management Elements
        const userPillsContainer = document.getElementById('userPillsContainer');
        const addUserBtn = document.getElementById('addUserBtn');
        const addUserModalEl = document.getElementById('addUserModal');
        const newUserNameInput = document.getElementById('newUserName');
        const newUserColorInput = document.getElementById('newUserColor');
        const saveNewUserBtn = document.getElementById('saveNewUser');
        const cancelAddUserBtn = document.getElementById('cancelAddUser');
        // Edit User Elements
        const editUserModalEl = document.getElementById('editUserModal');
        const editUserNameInput = document.getElementById('editUserName');
        const editUserColorInput = document.getElementById('editUserColor');
        const saveEditUserBtn = document.getElementById('saveEditUser');
        const cancelEditUserBtn = document.getElementById('cancelEditUser');
        // Delete User Elements
        const deleteUserModalEl = document.getElementById('deleteUserModal');
        const deleteUserIndicator = document.getElementById('deleteUserIndicator');
        const deleteUserName = document.getElementById('deleteUserName');
        const confirmDeleteUserBtn = document.getElementById('confirmDeleteUser');
        const cancelDeleteUserBtn = document.getElementById('cancelDeleteUser');

        // --- Context Variables ---
        // Stores context for adding/editing an appointment
        // { date, initialHour, initialMinute, currentSelectedHour, currentSelectedMinute, currentMaxDuration, editingAppointmentId, originalDateKey }
        let currentAppointmentContext = null; 
        // Stores context for the appointment being viewed in the details modal
        // { data: appointmentData, dateKey: key }
        let appointmentContextForDetails = null;
        
        // Touch gesture variables for mobile swipe navigation
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const minSwipeDistance = 50; // Minimum distance for a swipe gesture
        
        // User management context
        let userBeingEdited = null;
        let userBeingDeleted = null; 

        // --- Core Application Logic ---

        // Renders the month view calendar
        function renderMonthView() {
            monthViewEl.classList.remove('hidden');
            agendaViewEl.classList.add('hidden');
            const year = currentDisplayDate.getFullYear();
            const month = currentDisplayDate.getMonth();
            currentMonthYearEl.textContent = `${currentDisplayDate.toLocaleString('es-ES', { month: 'long' })} ${year}`;
            // Clear previous grid and add headers
            calendarGridEl.innerHTML = `
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">DOM</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">LUN</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">MAR</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">MIÉ</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">JUE</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">VIE</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">SÁB</div>
            `;
            // Calculate calendar grid parameters
            const firstDayOfMonth = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const today = new Date();
            today.setHours(0,0,0,0); // Normalize today to midnight for comparison
            // Add empty cells for days before the 1st of the month
            for (let i = 0; i < firstDayOfMonth; i++) {
                calendarGridEl.appendChild(document.createElement('div'));
            }
            // Add cells for each day of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayCell = document.createElement('div');
                dayCell.textContent = day;
                dayCell.classList.add('py-2', 'sm:py-3', 'cursor-pointer', 'hover:bg-blue-100', 'rounded-full', 'transition-colors', 'duration-150', 'flex', 'items-center', 'justify-center', 'text-sm', 'sm:text-base');
                const cellDate = new Date(year, month, day);
                // Highlight today's date
                if (cellDate.getTime() === today.getTime()) {
                    dayCell.classList.add('bg-blue-500', 'text-white', 'font-semibold');
                    dayCell.classList.remove('hover:bg-blue-100');
                } else {
                    dayCell.classList.add('text-slate-700');
                }
                // Add dot indicator if there are appointments on this day
                const dateKey = formatDateKey(cellDate);
                const userAppointments = getCurrentUserAppointments();
                if (userAppointments[dateKey] && userAppointments[dateKey].length > 0) {
                    const dot = document.createElement('span');
                    dot.classList.add('h-1.5', 'w-1.5', 'bg-green-500', 'rounded-full', 'ml-1', 'inline-block', 'align-middle');
                     if (cellDate.getTime() === today.getTime()) { // Use white dot on today's highlight
                        dot.classList.remove('bg-green-500');
                        dot.classList.add('bg-white');
                    }
                    dayCell.appendChild(dot);
                }
                // Add click listener to switch to agenda view for this day
                dayCell.addEventListener('click', () => {
                    selectedAgendaDate = new Date(year, month, day);
                    selectedAgendaDate.setHours(0,0,0,0);
                    renderAgendaView();
                });
                calendarGridEl.appendChild(dayCell);
            }
        }

        // Renders the daily agenda view
        function renderAgendaView() {
            monthViewEl.classList.add('hidden');
            agendaViewEl.classList.remove('hidden');
            agendaDateTitleEl.textContent = `Agenda para: ${selectedAgendaDate.toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}`;
            updateDateSelectorWheel(); // Update the date selector wheel
            agendaSlotsContainerEl.innerHTML = ''; // Clear previous slots
            const dateKey = formatDateKey(selectedAgendaDate);
            const userAppointments = getCurrentUserAppointments();
            // Get and sort appointments for the selected day
            const dailyAppointments = (userAppointments[dateKey] || []).sort((a, b) => {
                if (a.startHour === b.startHour) return a.startMinute - b.startMinute;
                return a.startHour - b.startHour;
            });
            // Create a row for each hour (0-23)
            for (let hour = 0; hour < 24; hour++) {
                const hourRow = document.createElement('div');
                hourRow.classList.add('flex', 'items-stretch', 'min-h-[40px]');
                // Hour Label Column
                const hourLabel = document.createElement('div');
                hourLabel.classList.add('w-1/4', 'py-2', 'pr-2', 'text-sm', 'text-slate-600', 'flex', 'items-center', 'border-r', 'border-slate-200');
                hourLabel.textContent = `${String(hour).padStart(2, '0')}:00`;
                hourRow.appendChild(hourLabel);
                // Time Slot Bar Column
                const slotCell = document.createElement('div');
                slotCell.classList.add('w-3/4', 'pl-2');
                const timeSlotBar = document.createElement('div');
                timeSlotBar.classList.add('time-slot');
                // Populate the time slot bar with free/booked segments
                populateTimeSlotBar(timeSlotBar, hour, dailyAppointments);
                slotCell.appendChild(timeSlotBar);
                hourRow.appendChild(slotCell);
                agendaSlotsContainerEl.appendChild(hourRow);
            }
        }
        
        // Updates the date selector wheel with current, previous, and next dates
        function updateDateSelectorWheel() {
            const today = new Date();
            const prevDate = new Date(selectedAgendaDate);
            prevDate.setDate(prevDate.getDate() - 1);
            const nextDate = new Date(selectedAgendaDate);
            nextDate.setDate(nextDate.getDate() + 1);
            
            // Update date elements
            prevDateEl.textContent = prevDate.toLocaleDateString('es-ES', { 
                weekday: 'short', 
                day: 'numeric', 
                month: 'short' 
            });
            
            currentDateEl.textContent = selectedAgendaDate.toLocaleDateString('es-ES', { 
                weekday: 'short', 
                day: 'numeric', 
                month: 'short' 
            });
            
            nextDateEl.textContent = nextDate.toLocaleDateString('es-ES', { 
                weekday: 'short', 
                day: 'numeric', 
                month: 'short' 
            });
            
            // Highlight today if it's the selected date
            if (selectedAgendaDate.toDateString() === today.toDateString()) {
                currentDateEl.classList.add('bg-green-50', 'border-green-300', 'text-green-700');
                currentDateEl.classList.remove('bg-blue-50', 'border-blue-300', 'text-slate-700');
            } else {
                currentDateEl.classList.add('bg-blue-50', 'border-blue-300', 'text-slate-700');
                currentDateEl.classList.remove('bg-green-50', 'border-green-300', 'text-green-700');
            }
        }
        
        // Navigate to a different date
        function navigateToDate(targetDate) {
            selectedAgendaDate = new Date(targetDate);
            selectedAgendaDate.setHours(0, 0, 0, 0);
            renderAgendaView();
        }
        
        // Touch gesture handling functions
        function handleTouchStart(event) {
            // Only handle touch events when agenda view is active
            if (agendaViewEl.classList.contains('hidden')) return;
            
            const firstTouch = event.touches[0];
            touchStartX = firstTouch.clientX;
            touchStartY = firstTouch.clientY;
        }
        
        function handleTouchMove(event) {
            // Prevent default scrolling when swiping on the date selector area
            if (!agendaViewEl.classList.contains('hidden')) {
                event.preventDefault();
            }
        }
        
        function handleTouchEnd(event) {
            // Only handle touch events when agenda view is active
            if (agendaViewEl.classList.contains('hidden')) return;
            
            const lastTouch = event.changedTouches[0];
            touchEndX = lastTouch.clientX;
            touchEndY = lastTouch.clientY;
            
            handleSwipeGesture();
        }
        
        function handleSwipeGesture() {
            const deltaX = touchEndX - touchStartX;
            const deltaY = touchEndY - touchStartY;
            
            // Check if it's a horizontal swipe (more horizontal than vertical)
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
                if (deltaX > 0) {
                    // Swipe right - go to previous date
                    const prevDate = new Date(selectedAgendaDate);
                    prevDate.setDate(prevDate.getDate() - 1);
                    navigateToDate(prevDate);
                } else {
                    // Swipe left - go to next date
                    const nextDate = new Date(selectedAgendaDate);
                    nextDate.setDate(nextDate.getDate() + 1);
                    navigateToDate(nextDate);
                }
            }
        }

        // Populates a single hour's time slot bar with segments
        function populateTimeSlotBar(timeSlotBar, hour, dailyAppointments) {
            let currentMinuteInHour = 0;
            const appointmentsInThisHour = [];
            // Find all appointments that overlap with this hour
            dailyAppointments.forEach(appt => {
                const apptStartTotalMinutes = appt.startHour * 60 + appt.startMinute;
                const apptEndTotalMinutes = apptStartTotalMinutes + appt.duration;
                const hourStartTotalMinutes = hour * 60;
                const hourEndTotalMinutes = (hour + 1) * 60;
                // Check for overlap
                if (apptStartTotalMinutes < hourEndTotalMinutes && apptEndTotalMinutes > hourStartTotalMinutes) {
                    // Calculate the portion of the appointment within this hour
                    const startMinuteInSlot = Math.max(0, apptStartTotalMinutes - hourStartTotalMinutes);
                    const endMinuteInSlot = Math.min(60, apptEndTotalMinutes - hourStartTotalMinutes);
                    const durationInSlot = endMinuteInSlot - startMinuteInSlot;
                    if (durationInSlot > 0) {
                        appointmentsInThisHour.push({...appt, displayStartMinute: startMinuteInSlot, displayDuration: durationInSlot});
                    }
                }
            });
            // Sort segments within the hour by start time
            appointmentsInThisHour.sort((a,b) => a.displayStartMinute - b.displayStartMinute);
            // Create and append segments (free or booked)
            appointmentsInThisHour.forEach(apptSegment => {
                // Add free segment before this appointment if there's a gap
                if (apptSegment.displayStartMinute > currentMinuteInHour) {
                    const freeDuration = apptSegment.displayStartMinute - currentMinuteInHour;
                    timeSlotBar.appendChild(createTimeSegment(hour, currentMinuteInHour, freeDuration, true, null));
                }
                // Add the booked appointment segment
                timeSlotBar.appendChild(createTimeSegment(hour, apptSegment.displayStartMinute, apptSegment.displayDuration, false, apptSegment));
                currentMinuteInHour = apptSegment.displayStartMinute + apptSegment.displayDuration;
            });
            // Add remaining free segment at the end of the hour if needed
            if (currentMinuteInHour < 60) {
                const freeDuration = 60 - currentMinuteInHour;
                timeSlotBar.appendChild(createTimeSegment(hour, currentMinuteInHour, freeDuration, true, null));
            }
        }

        // Creates a single segment (free or booked) for the time slot bar
        function createTimeSegment(hour, startMinuteOffset, durationMinutes, isFree, appointmentData) {
            const segment = document.createElement('div');
            segment.classList.add('time-segment');
            segment.style.width = `${(durationMinutes / 60) * 100}%`; // Width proportional to duration

            if (isFree) {
                segment.classList.add('free-segment');
                if (durationMinutes > 10) segment.textContent = `${durationMinutes}m libres`; // Show text if space allows
                segment.title = `Añadir cita a las ${String(hour).padStart(2, '0')}:${String(startMinuteOffset).padStart(2, '0')} (${durationMinutes}m disponibles)`;
                // Click listener to open the add modal
                segment.addEventListener('click', () => {
                    const maxDurationPossible = calculateContiguousFreeTime(selectedAgendaDate, hour, startMinuteOffset);
                    openAddAppointmentModal(selectedAgendaDate, hour, startMinuteOffset, maxDurationPossible);
                });
            } else { // Booked segment
                segment.classList.add('booked-segment');
                const bgColor = appointmentData.color || '#EF5350'; // Use assigned color or fallback
                segment.style.backgroundColor = bgColor; 
                // Adjust text color based on background brightness
                if (isColorLight(bgColor)) {
                    segment.classList.add('dark-text'); segment.classList.remove('light-text');
                } else {
                    segment.classList.add('light-text'); segment.classList.remove('dark-text');
                }
                segment.textContent = appointmentData.title; // Display title
                // Tooltip with full details
                const startTimeStr = `${String(appointmentData.startHour).padStart(2, '0')}:${String(appointmentData.startMinute).padStart(2, '0')}`;
                const endTimeStr = formatEndTime(appointmentData.startHour, appointmentData.startMinute, appointmentData.duration);
                segment.title = `${appointmentData.title} (${startTimeStr} - ${endTimeStr}, ${appointmentData.duration}m). Haz clic para ver detalles.`;
                // Click listener to open the view details modal
                segment.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    openViewAppointmentDetailsModal(appointmentData, formatDateKey(selectedAgendaDate)); // Pass dateKey
                });
                // Add delete button ('x') directly on the segment
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '&times;'; // 'x' symbol
                deleteBtn.classList.add('ml-1', 'delete-btn', 'opacity-70', 'hover:opacity-100', 'font-bold', 'text-xs', 'p-0.5', 'rounded-full');
                // Apply text color class to delete button as well
                if (isColorLight(bgColor)) deleteBtn.classList.add('dark-text');
                else deleteBtn.classList.add('light-text');
                deleteBtn.title = 'Eliminar cita';
                deleteBtn.style.lineHeight = '1'; 
                // Click listener for the delete button
                deleteBtn.onclick = (e) => {
                    e.stopPropagation(); // Prevent opening details modal
                    console.log('Click en botón X:', appointmentData.id, formatDateKey(selectedAgendaDate)); 
                    if (confirm(`¿Eliminar cita "${appointmentData.title}"?`)) {
                        deleteAppointment(appointmentData.id, formatDateKey(selectedAgendaDate));
                    }
                };
                // Only show delete button if segment is wide enough
                if (durationMinutes > 20 && segment.offsetWidth > 30) { // Heuristic check
                    segment.appendChild(deleteBtn);
                }
            }
            return segment;
        }

        // Calculates the maximum contiguous free time starting from a specific point
        function calculateContiguousFreeTime(targetDate, startHour, startMinute, editingApptId = null) {
            const dateKey = formatDateKey(targetDate);
            const userAppointments = getCurrentUserAppointments();
            // Get appointments for the day, excluding the one being edited (if any)
            const dailyAppts = (userAppointments[dateKey] || [])
                .filter(appt => appt.id !== editingApptId) 
                .slice()
                .sort((a, b) => (a.startHour * 60 + a.startMinute) - (b.startHour * 60 + b.startMinute));
            
            const checkFromMinuteOfDay = startHour * 60 + startMinute;
            // Find the next appointment that starts at or after the check time
            let nextBlockingAppt = dailyAppts.find(appt => (appt.startHour * 60 + appt.startMinute) >= checkFromMinuteOfDay);
            
            // Calculate free minutes until the next appointment or end of day
            return nextBlockingAppt ? (nextBlockingAppt.startHour * 60 + nextBlockingAppt.startMinute) - checkFromMinuteOfDay : (24 * 60) - checkFromMinuteOfDay;
        }

        // Formats the end time given start time and duration
        function formatEndTime(startHour, startMinute, duration) {
            let endTotalMinutes = startHour * 60 + startMinute + duration;
            let endHour = Math.floor(endTotalMinutes / 60) % 24; // Handle crossing midnight
            let endMinute = endTotalMinutes % 60;
            return `${String(endHour).padStart(2, '0')}:${String(endMinute).padStart(2, '0')}`;
        }

        // Populates the hour and minute select dropdowns in the add/edit modal
        function populateTimeSelects() {
            appointmentStartHourSelect.innerHTML = '';
            for (let i = 0; i < 24; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = String(i).padStart(2, '0');
                appointmentStartHourSelect.appendChild(option);
            }
            appointmentStartMinuteSelect.innerHTML = '';
            // Using 5-minute increments for minutes dropdown
            for (let i = 0; i < 60; i += 5) { 
                const option = document.createElement('option');
                option.value = i;
                option.textContent = String(i).padStart(2, '0');
                appointmentStartMinuteSelect.appendChild(option);
            }
        }

        // Updates the time info text and max duration in the add/edit modal
        function updateAppointmentTimeInfo() {
            if (!currentAppointmentContext) return;
            const selectedHour = parseInt(appointmentStartHourSelect.value);
            const selectedMinute = parseInt(appointmentStartMinuteSelect.value);
            
            // Get the target date (either from date input if editing, or from context)
            let targetDate = currentAppointmentContext.date;
            if (currentAppointmentContext.editingAppointmentId && appointmentDateInput.value) {
                targetDate = createDateFromString(appointmentDateInput.value);
            }
            
            // Determine target user for calculation
            let targetUserId = currentUserId;
            if (currentAppointmentContext.editingAppointmentId && appointmentUserSelect.value) {
                targetUserId = appointmentUserSelect.value;
            }
            
            // Update context with currently selected time
            currentAppointmentContext.currentSelectedHour = selectedHour;
            currentAppointmentContext.currentSelectedMinute = selectedMinute;
            currentAppointmentContext.currentTargetDate = targetDate;
            
            // Recalculate max duration based on selected time, date, and user
            currentAppointmentContext.currentMaxDuration = calculateContiguousFreeTimeForUser(
                targetDate, 
                selectedHour, 
                selectedMinute,
                currentAppointmentContext.editingAppointmentId, // Pass ID if editing
                targetUserId
            );
            // Update the max attribute of the duration input
            appointmentDurationInput.max = currentAppointmentContext.currentMaxDuration;
            // Adjust duration value if it exceeds the new max
            if (parseInt(appointmentDurationInput.value) > currentAppointmentContext.currentMaxDuration && currentAppointmentContext.currentMaxDuration > 0) {
                appointmentDurationInput.value = currentAppointmentContext.currentMaxDuration;
            } else if (currentAppointmentContext.currentMaxDuration <= 0 && !currentAppointmentContext.editingAppointmentId) { 
                 appointmentDurationInput.value = 1; // Prevent 0 or negative duration if no space
            }
            // Update the info text
            const userInfo = targetUserId !== currentUserId ? ` (Usuario: ${users[targetUserId]?.name || 'Desconocido'})` : '';
            appointmentTimeInfoEl.textContent = `Cita para el ${targetDate.toLocaleDateString('es-ES')} a las ${String(selectedHour).padStart(2, '0')}:${String(selectedMinute).padStart(2, '0')}. Duración máxima: ${currentAppointmentContext.currentMaxDuration > 0 ? currentAppointmentContext.currentMaxDuration : 0} min.${userInfo}`;
        }
        
        // Helper function to create a date from YYYY-MM-DD string without timezone issues
        function createDateFromString(dateString) {
            const [year, month, day] = dateString.split('-').map(Number);
            return new Date(year, month - 1, day); // month is 0-indexed in Date constructor
        }
        
        // Calculate contiguous free time for a specific user
        function calculateContiguousFreeTimeForUser(date, startHour, startMinute, excludeAppointmentId = null, userId = null) {
            const targetUserId = userId || currentUserId;
            const userAppointments = appointments[targetUserId] || {};
            const dateKey = formatDateKey(date);
            const dayAppointments = userAppointments[dateKey] || [];
            
            const startTime = startHour * 60 + startMinute;
            const endTime = 24 * 60; // End of day
            
            // Filter out the excluded appointment
            const relevantAppointments = dayAppointments.filter(appt => appt.id !== excludeAppointmentId);
            
            // Sort appointments by start time
            relevantAppointments.sort((a, b) => {
                const aStart = a.startHour * 60 + a.startMinute;
                const bStart = b.startHour * 60 + b.startMinute;
                return aStart - bStart;
            });
            
            // Find the first appointment that starts after our start time
            for (const appt of relevantAppointments) {
                const apptStart = appt.startHour * 60 + appt.startMinute;
                if (apptStart > startTime) {
                    return apptStart - startTime;
                }
            }
            
            // No appointments found after start time, return remaining time
            return endTime - startTime;
        }
        
        // Opens the Add/Edit modal, pre-filling data if editing
        function openAddAppointmentModal(date, hour, minute, maxDurationPossible, appointmentToEditData = null) {
            populateTimeSelects(); // Ensure selects are populated
            if (appointmentToEditData) { // Edit Mode
                currentAppointmentContext = { 
                    date: date, // Date object of the appointment
                    initialHour: appointmentToEditData.startHour, 
                    initialMinute: appointmentToEditData.startMinute,
                    currentSelectedHour: appointmentToEditData.startHour,
                    currentSelectedMinute: appointmentToEditData.startMinute,
                    editingAppointmentId: appointmentToEditData.id,
                    originalDateKey: formatDateKey(date), // Store original date key
                    originalUserId: currentUserId // Store original user ID
                };
                // Set modal title and button text for editing
                modalTitleEl.textContent = "Editar Cita";
                saveAppointmentBtn.textContent = "Actualizar Cita";
                
                // Show date and user selectors for editing
                appointmentDateContainer.classList.remove('hidden');
                appointmentUserContainer.classList.remove('hidden');
                appointmentDateInput.value = formatDateKey(date);
                
                // Populate user selector
                populateUserSelector();
                appointmentUserSelect.value = ''; // Default to current user
                
                // Pre-fill form fields
                appointmentTitleInput.value = appointmentToEditData.title;
                appointmentStartHourSelect.value = appointmentToEditData.startHour;
                appointmentStartMinuteSelect.value = appointmentToEditData.startMinute;
                appointmentDurationInput.value = appointmentToEditData.duration;
                appointmentDetailsInput.value = appointmentToEditData.details || '';
                // Calculate initial max duration excluding the current appointment
                currentAppointmentContext.currentMaxDuration = calculateContiguousFreeTime(date, appointmentToEditData.startHour, appointmentToEditData.startMinute, appointmentToEditData.id);
            } else { // Add Mode
                currentAppointmentContext = { 
                    date: date, initialHour: hour, initialMinute: minute,
                    currentSelectedHour: hour, currentSelectedMinute: minute,
                    currentMaxDuration: maxDurationPossible,
                    editingAppointmentId: null,
                    originalDateKey: null,
                    originalUserId: null
                };
                // Set modal title and button text for adding
                modalTitleEl.textContent = "Añadir Nueva Cita";
                saveAppointmentBtn.textContent = "Guardar Cita";
                
                // Hide date and user selectors for adding
                appointmentDateContainer.classList.add('hidden');
                appointmentUserContainer.classList.add('hidden');
                
                // Clear form fields
                appointmentTitleInput.value = '';
                appointmentDetailsInput.value = ''; 
                // Set initial time and duration
                appointmentStartHourSelect.value = hour;
                appointmentStartMinuteSelect.value = minute;
                appointmentDurationInput.value = Math.min(30, maxDurationPossible > 0 ? maxDurationPossible : 30); // Default 30min or max
                currentAppointmentContext.currentMaxDuration = maxDurationPossible; // Already calculated
            }
            
            // Set the max attribute for duration input
            appointmentDurationInput.max = currentAppointmentContext.currentMaxDuration > 0 ? currentAppointmentContext.currentMaxDuration : 1;
            updateAppointmentTimeInfo(); // Update info text
            addAppointmentModalEl.classList.add('active'); // Show modal
            appointmentTitleInput.focus(); // Focus on title input
        }
        
        // Populate user selector for transfer
        function populateUserSelector() {
            appointmentUserSelect.innerHTML = '<option value="">Mantener en usuario actual</option>';
            Object.entries(users).forEach(([userId, userData]) => {
                if (userId !== currentUserId) { // Don't show current user
                    const option = document.createElement('option');
                    option.value = userId;
                    option.textContent = userData.name;
                    appointmentUserSelect.appendChild(option);
                }
            });
        }

        // Closes the Add/Edit modal
        function closeAddAppointmentModal() {
            addAppointmentModalEl.classList.remove('active');
            currentAppointmentContext = null; // Clear context
        }

        // Saves a new appointment or updates an existing one
        function saveCurrentAppointment() {
            if (!currentAppointmentContext) return;
            // Get data from form
            const title = appointmentTitleInput.value.trim();
            const duration = parseInt(appointmentDurationInput.value, 10);
            const details = appointmentDetailsInput.value.trim();
            // Get selected start time from context (updated by selects)
            const startHour = currentAppointmentContext.currentSelectedHour;
            const startMinute = currentAppointmentContext.currentSelectedMinute;
            
            // Get target date (either from date input if editing, or from context)
            let targetDate = currentAppointmentContext.date;
            if (currentAppointmentContext.editingAppointmentId && appointmentDateInput.value) {
                targetDate = createDateFromString(appointmentDateInput.value);
            }
            const targetDateKey = formatDateKey(targetDate);

            // --- Validations ---
            if (!title) {
                alert('Por favor, introduce un título para la cita.');
                appointmentTitleInput.focus(); return;
            }
            if (isNaN(duration) || duration <= 0) {
                alert('Por favor, introduce una duración válida en minutos.');
                appointmentDurationInput.focus(); return;
            }
            // Validate duration against the max calculated for the selected start time
            if (duration > currentAppointmentContext.currentMaxDuration) {
                alert(`La duración (${duration}m) no puede exceder los ${currentAppointmentContext.currentMaxDuration} minutos disponibles para la hora de inicio seleccionada.`);
                appointmentDurationInput.focus(); return;
            }
            
            // Ensure the date key exists in user appointments object
            const userAppointments = getCurrentUserAppointments();
            if (!userAppointments[targetDateKey]) userAppointments[targetDateKey] = [];
            
            // Determine target user for validation
            let validationUserId = currentUserId;
            if (currentAppointmentContext.editingAppointmentId && appointmentUserSelect.value) {
                validationUserId = appointmentUserSelect.value;
            }
            
            // Get target user appointments for conflict check
            const targetUserAppointments = appointments[validationUserId] || {};
            if (!targetUserAppointments[targetDateKey]) targetUserAppointments[targetDateKey] = [];
            
            // --- Conflict Check ---
            const newApptStart = startHour * 60 + startMinute;
            const newApptEnd = newApptStart + duration;
            for (const existingAppt of targetUserAppointments[targetDateKey]) {
                // Skip checking against itself if editing
                if (currentAppointmentContext.editingAppointmentId && existingAppt.id === currentAppointmentContext.editingAppointmentId) {
                    continue; 
                }
                const existingApptStart = existingAppt.startHour * 60 + existingAppt.startMinute;
                const existingApptEnd = existingApptStart + existingAppt.duration;
                // Check for overlap
                if (Math.max(newApptStart, existingApptStart) < Math.min(newApptEnd, existingApptEnd)) {
                     alert('Conflicto de horario detectado. Esta cita se superpone con otra existente.'); return;
                }
            }
            
            // --- Save or Update ---
            let wasEditing = false; 
            let originalDateKeyForRender = null; 
            let targetUserId = currentUserId; // Default to current user
            
            // Check if user transfer is requested (only for editing)
            if (currentAppointmentContext.editingAppointmentId && appointmentUserSelect.value) {
                targetUserId = appointmentUserSelect.value;
            }
            
            if (currentAppointmentContext.editingAppointmentId) { // Update existing appointment
                wasEditing = true;
                originalDateKeyForRender = currentAppointmentContext.originalDateKey;
                
                // Get appointments from original user
                const originalUserAppointments = appointments[currentAppointmentContext.originalUserId] || {};
                const apptIndex = originalUserAppointments[currentAppointmentContext.originalDateKey]?.findIndex(appt => appt.id === currentAppointmentContext.editingAppointmentId);
                
                if (apptIndex > -1) {
                    // Create the updated appointment data
                    const updatedAppointmentData = {
                        ...originalUserAppointments[currentAppointmentContext.originalDateKey][apptIndex], 
                        title: title, 
                        startHour: startHour, 
                        startMinute: startMinute,
                        duration: duration, 
                        details: details 
                    };
                    
                    // Get target user appointments
                    if (!appointments[targetUserId]) {
                        appointments[targetUserId] = {};
                    }
                    if (!appointments[targetUserId][targetDateKey]) {
                        appointments[targetUserId][targetDateKey] = [];
                    }
                    
                    // Add to target user/date
                    appointments[targetUserId][targetDateKey].push(updatedAppointmentData);
                    
                    // Remove from original location
                    originalUserAppointments[currentAppointmentContext.originalDateKey].splice(apptIndex, 1);
                    
                    // Clean up original date array if empty
                    if (originalUserAppointments[currentAppointmentContext.originalDateKey].length === 0) {
                        delete originalUserAppointments[currentAppointmentContext.originalDateKey];
                    }
                    
                    // Update duration usage statistics for target user
                    if (!durationUsage[targetUserId]) {
                        durationUsage[targetUserId] = {};
                    }
                    durationUsage[targetUserId][duration] = (durationUsage[targetUserId][duration] || 0) + 1;
                } else {
                    console.error("Error: No se encontró la cita para editar.");
                }
            } else { // Add new appointment
                const newColor = distinctColors[nextColorIndex];
                nextColorIndex = (nextColorIndex + 1) % distinctColors.length;
                localStorage.setItem('nextColorIndex', nextColorIndex.toString());
                
                // Ensure target user appointments exist
                if (!appointments[targetUserId]) {
                    appointments[targetUserId] = {};
                }
                if (!appointments[targetUserId][targetDateKey]) {
                    appointments[targetUserId][targetDateKey] = [];
                }
                
                appointments[targetUserId][targetDateKey].push({
                    id: Date.now().toString() + Math.random().toString(36).substring(2,7), 
                    title: title, startHour: startHour, startMinute: startMinute,
                    duration: duration, color: newColor, details: details 
                });
                // Update duration usage statistics for new appointments
                updateDurationUsage(duration);
            }

            saveAppointmentsToLocalStorage();
            const contextDateKey = targetDateKey; // Store date key before closing modal
            const contextOriginalDateKey = originalDateKeyForRender; // Store original date key if editing
            
            closeAddAppointmentModal(); // Close modal first

            // --- Re-render Views ---
            const agendaWasVisible = !agendaViewEl.classList.contains('hidden');
            renderMonthView(); // Always update month view dots

            if (agendaWasVisible) { // If agenda view was active, keep it active
                monthViewEl.classList.add('hidden');
                agendaViewEl.classList.remove('hidden');
                // Re-render agenda view if the change affected the currently selected date
                // or the original date (if editing and date changed)
                if (formatDateKey(selectedAgendaDate) === contextDateKey || 
                    (wasEditing && contextOriginalDateKey && formatDateKey(selectedAgendaDate) === contextOriginalDateKey) ) {
                    renderAgendaView();
                }
            }
        }

        // Opens the View Details modal
        function openViewAppointmentDetailsModal(appointmentData, dateKeyForAppointment) {
            // Store the appointment data and its date key for edit/delete actions
            appointmentContextForDetails = { data: appointmentData, dateKey: dateKeyForAppointment }; 
            // Populate modal fields
            viewAppointmentTitleEl.textContent = appointmentContextForDetails.data.title;
            const startTimeStr = `${String(appointmentContextForDetails.data.startHour).padStart(2, '0')}:${String(appointmentContextForDetails.data.startMinute).padStart(2, '0')}`;
            const endTimeStr = formatEndTime(appointmentContextForDetails.data.startHour, appointmentContextForDetails.data.startMinute, appointmentContextForDetails.data.duration);
            viewAppointmentTimeEl.textContent = `Hora: ${startTimeStr} - ${endTimeStr}`;
            viewAppointmentDurationEl.textContent = `Duración: ${appointmentContextForDetails.data.duration} minutos`;
            viewAppointmentDetailsContentEl.textContent = appointmentContextForDetails.data.details || "No hay detalles adicionales.";
            // Show the modal
            viewAppointmentDetailsModalEl.classList.add('active');
        }
        // Closes the View Details modal
        function closeViewAppointmentDetailsModal() {
            viewAppointmentDetailsModalEl.classList.remove('active');
            appointmentContextForDetails = null; // Clear context
        }
        
        // Handles the delete confirmation and calls deleteAppointment
        function handleDeleteAppointment(apptToDelete, dateKeyOfAppointment) { 
            if (!apptToDelete || !dateKeyOfAppointment) {
                 console.error("Error al eliminar: Faltan datos de la cita o la fecha.");
                 alert("Error: No se pudo identificar la cita a eliminar."); 
                 return;
            }
            // Ask for confirmation
            if (confirm(`¿Estás seguro de que quieres eliminar la cita "${apptToDelete.title}"?`)) {
                console.log('Eliminando cita:', apptToDelete.id, 'en fecha:', dateKeyOfAppointment); 
                deleteAppointment(apptToDelete.id, dateKeyOfAppointment); // Call the actual delete function
                closeViewAppointmentDetailsModal(); // Close the details modal if open
            }
        }

        // Deletes an appointment from the specified dateKey
        function deleteAppointment(appointmentId, dateKey) { 
            console.log('Función deleteAppointment llamada con ID:', appointmentId, 'y dateKey:', dateKey); 
            const userAppointments = getCurrentUserAppointments();
            if (!userAppointments[dateKey]) {
                console.warn("Intento de eliminar cita en una fecha inexistente:", dateKey);
                return; // Exit if the date key doesn't exist
            }
            const initialLength = userAppointments[dateKey].length;
            // Filter out the appointment with the matching ID
            userAppointments[dateKey] = userAppointments[dateKey].filter(appt => appt.id !== appointmentId);
            
            // Check if an appointment was actually removed
            if (userAppointments[dateKey].length < initialLength) { 
                console.log('Cita eliminada exitosamente.'); 
                // If the day's array is now empty, remove the date key entirely
                if (userAppointments[dateKey].length === 0) {
                    delete userAppointments[dateKey]; 
                }
                saveAppointmentsToLocalStorage(); // Save changes
                // --- Re-render Views ---
                const agendaWasVisible = !agendaViewEl.classList.contains('hidden');
                renderMonthView(); // Always update month view dots
                if (agendaWasVisible) { // If agenda view was active, keep it active
                    monthViewEl.classList.add('hidden');
                    agendaViewEl.classList.remove('hidden');
                    // Re-render agenda view only if the deleted appointment was on the currently selected date
                    if (formatDateKey(selectedAgendaDate) === dateKey) { 
                        renderAgendaView();
                    }
                }
            } else {
                // This shouldn't happen if the ID and dateKey were correct
                console.warn("No se pudo encontrar la cita para eliminar con ID:", appointmentId, "en la fecha", dateKey);
                 alert("Error: No se pudo encontrar la cita para eliminar."); 
            }
        }
        
        // User Management Functions
        function updateUserInterface() {
            updateUserPills();
        }
        
        function updateUserPills() {
            userPillsContainer.innerHTML = '';
            Object.entries(users).forEach(([userId, userData]) => {
                const userPillContainer = document.createElement('div');
                userPillContainer.classList.add('relative');
                
                const userPill = document.createElement('button');
                userPill.classList.add('flex', 'items-center', 'space-x-2', 'px-3', 'py-2', 'rounded-full', 'text-sm', 'font-medium', 'transition-all', 'duration-200', 'border', 'cursor-pointer', 'hover:shadow-md');
                
                // Style based on whether it's the current user
                if (userId === currentUserId) {
                    userPill.classList.add('bg-blue-500', 'text-white', 'border-blue-500', 'shadow-md');
                } else {
                    userPill.classList.add('bg-white', 'text-slate-700', 'border-slate-200', 'hover:bg-slate-50', 'hover:border-slate-300');
                }
                
                // Color indicator
                const indicator = document.createElement('div');
                indicator.classList.add('w-3', 'h-3', 'rounded-full', 'flex-shrink-0');
                indicator.style.backgroundColor = userData.color;
                
                // User name
                const name = document.createElement('span');
                name.classList.add('whitespace-nowrap');
                name.textContent = userData.name;
                
                userPill.appendChild(indicator);
                userPill.appendChild(name);
                
                // Single click handler for switching user
                userPill.addEventListener('click', (e) => {
                    // Don't switch if clicking on action menu
                    if (!e.target.closest('.user-context-menu')) {
                        switchToUser(userId);
                    }
                });
                
                // Double click handler for showing context menu
                userPill.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    showUserContextMenu(userId, userPillContainer);
                });
                
                userPillContainer.appendChild(userPill);
                userPillsContainer.appendChild(userPillContainer);
            });
        }
        
        // Show context menu for user actions
        function showUserContextMenu(userId, container) {
            // Remove any existing context menu
            const existingMenu = document.querySelector('.user-context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }
            
            const contextMenu = document.createElement('div');
            contextMenu.classList.add('user-context-menu', 'absolute', 'top-full', 'left-0', 'mt-1', 'bg-white', 'rounded-lg', 'shadow-lg', 'border', 'border-slate-200', 'py-1', 'z-50', 'min-w-[120px]');
            
            // Edit option
            const editOption = document.createElement('button');
            editOption.classList.add('w-full', 'text-left', 'px-3', 'py-2', 'text-sm', 'text-slate-700', 'hover:bg-slate-50', 'flex', 'items-center', 'space-x-2', 'transition-colors');
            editOption.innerHTML = '<span>✏️</span><span>Editar</span>';
            editOption.addEventListener('click', (e) => {
                e.stopPropagation();
                openEditUserModal(userId);
                contextMenu.remove();
            });
            
            // Delete option
            const deleteOption = document.createElement('button');
            deleteOption.classList.add('w-full', 'text-left', 'px-3', 'py-2', 'text-sm', 'text-red-600', 'hover:bg-red-50', 'flex', 'items-center', 'space-x-2', 'transition-colors');
            deleteOption.innerHTML = '<span>🗑️</span><span>Eliminar</span>';
            deleteOption.addEventListener('click', (e) => {
                e.stopPropagation();
                openDeleteUserModal(userId);
                contextMenu.remove();
            });
            
            contextMenu.appendChild(editOption);
            contextMenu.appendChild(deleteOption);
            
            container.appendChild(contextMenu);
            
            // Close menu when clicking outside
            const closeMenu = (e) => {
                if (!contextMenu.contains(e.target) && !container.contains(e.target)) {
                    contextMenu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            };
            
            // Add event listener after a short delay to prevent immediate closing
            setTimeout(() => {
                document.addEventListener('click', closeMenu);
            }, 100);
        }
        
        function switchToUser(userId) {
            if (userId !== currentUserId) {
                currentUserId = userId;
                localStorage.setItem('currentUserId', currentUserId);
                updateUserInterface(); // This will update the pills to show the new active user
                // Re-render current view with new user's data
                if (!agendaViewEl.classList.contains('hidden')) {
                    renderAgendaView();
                } else {
                    renderMonthView();
                }
            }
        }
        
        function addNewUser() {
            const name = newUserNameInput.value.trim();
            const color = newUserColorInput.value;
            
            if (!name) {
                alert('Por favor, introduce un nombre para el usuario.');
                newUserNameInput.focus();
                return;
            }
            
            // Check if name already exists
            const existingUser = Object.values(users).find(user => user.name.toLowerCase() === name.toLowerCase());
            if (existingUser) {
                alert('Ya existe un usuario con ese nombre.');
                newUserNameInput.focus();
                return;
            }
            
            // Generate new user ID
            const newUserId = 'user_' + Date.now().toString() + Math.random().toString(36).substring(2, 7);
            
            // Add new user
            users[newUserId] = {
                name: name,
                color: color
            };
            
            // Initialize empty data for new user
            if (!appointments[newUserId]) {
                appointments[newUserId] = {};
            }
            if (!durationUsage[newUserId]) {
                durationUsage[newUserId] = {};
            }
            
            saveAppointmentsToLocalStorage();
            switchToUser(newUserId);
            closeAddUserModal();
        }
        
        function openAddUserModal() {
            newUserNameInput.value = '';
            newUserColorInput.value = '#3b82f6';
            addUserModalEl.classList.add('active');
            newUserNameInput.focus();
        }
        
        function closeAddUserModal() {
            addUserModalEl.classList.remove('active');
        }
        
        // Edit User Functions
        function openEditUserModal(userId) {
            const userData = users[userId];
            if (!userData) return;
            
            userBeingEdited = userId;
            editUserNameInput.value = userData.name;
            editUserColorInput.value = userData.color;
            editUserModalEl.classList.add('active');
            editUserNameInput.focus();
        }
        
        function closeEditUserModal() {
            editUserModalEl.classList.remove('active');
            userBeingEdited = null;
        }
        
        function saveEditUser() {
            if (!userBeingEdited) return;
            
            const name = editUserNameInput.value.trim();
            const color = editUserColorInput.value;
            
            if (!name) {
                alert('Por favor, introduce un nombre para el usuario.');
                editUserNameInput.focus();
                return;
            }
            
            // Check if name already exists (excluding current user)
            const existingUser = Object.entries(users).find(([userId, userData]) => 
                userId !== userBeingEdited && userData.name.toLowerCase() === name.toLowerCase()
            );
            if (existingUser) {
                alert('Ya existe un usuario con ese nombre.');
                editUserNameInput.focus();
                return;
            }
            
            // Update user data
            users[userBeingEdited] = {
                name: name,
                color: color
            };
            
            saveAppointmentsToLocalStorage();
            updateUserInterface();
            closeEditUserModal();
        }
        
        // Delete User Functions
        function openDeleteUserModal(userId) {
            const userData = users[userId];
            if (!userData) return;
            
            // Don't allow deleting the last user
            if (Object.keys(users).length <= 1) {
                alert('No puedes eliminar el último usuario. Debe haber al menos un usuario en el sistema.');
                return;
            }
            
            userBeingDeleted = userId;
            deleteUserName.textContent = userData.name;
            deleteUserIndicator.style.backgroundColor = userData.color;
            deleteUserModalEl.classList.add('active');
        }
        
        function closeDeleteUserModal() {
            deleteUserModalEl.classList.remove('active');
            userBeingDeleted = null;
        }
        
        function confirmDeleteUser() {
            if (!userBeingDeleted) return;
            
            // Delete user data
            delete users[userBeingDeleted];
            delete appointments[userBeingDeleted];
            delete durationUsage[userBeingDeleted];
            
            // If deleted user was current, switch to first available user
            if (userBeingDeleted === currentUserId) {
                const remainingUsers = Object.keys(users);
                if (remainingUsers.length > 0) {
                    currentUserId = remainingUsers[0];
                    localStorage.setItem('currentUserId', currentUserId);
                }
            }
            
            saveAppointmentsToLocalStorage();
            updateUserInterface();
            
            // Re-render current view
            if (!agendaViewEl.classList.contains('hidden')) {
                renderAgendaView();
            } else {
                renderMonthView();
            }
            
            closeDeleteUserModal();
        }

        // Saves the entire appointments object to localStorage
        function saveAppointmentsToLocalStorage() {
            localStorage.setItem('appointments', JSON.stringify(appointments));
            localStorage.setItem('nextColorIndex', nextColorIndex.toString()); // Save color index too
            localStorage.setItem('durationUsage', JSON.stringify(durationUsage)); // Save duration usage stats
            localStorage.setItem('users', JSON.stringify(users)); // Save users data
            localStorage.setItem('currentUserId', currentUserId); // Save current user
        }
        
        // Gets appointments for current user
        function getCurrentUserAppointments() {
            if (!appointments[currentUserId]) {
                appointments[currentUserId] = {};
            }
            return appointments[currentUserId];
        }
        
        // Gets duration usage for current user
        function getCurrentUserDurationUsage() {
            if (!durationUsage[currentUserId]) {
                durationUsage[currentUserId] = {};
            }
            return durationUsage[currentUserId];
        }
        
        // Updates duration usage statistics when an appointment is saved
        function updateDurationUsage(duration) {
            const userDurationUsage = getCurrentUserDurationUsage();
            if (duration && duration > 0) {
                userDurationUsage[duration] = (userDurationUsage[duration] || 0) + 1;
                durationUsage[currentUserId] = userDurationUsage;
                localStorage.setItem('durationUsage', JSON.stringify(durationUsage));
                updateQuickDurationButtons(); // Update buttons with new stats
            }
        }
        
        // Gets the two most used durations for current user
        function getMostUsedDurations() {
            const userDurationUsage = getCurrentUserDurationUsage();
            const sortedDurations = Object.entries(userDurationUsage)
                .sort(([,a], [,b]) => b - a) // Sort by count descending
                .map(([duration]) => parseInt(duration));
            
            // Default to 30 and 60 if no data exists
            const first = sortedDurations[0] || 30;
            const second = sortedDurations[1] || 60;
            
            return [first, second];
        }
        
        
        // Updates the quick duration buttons with the most used durations
        function updateQuickDurationButtons() {
            const [firstDuration, secondDuration] = getMostUsedDurations();
            const quickDuration30Btn = document.getElementById('quickDuration30');
            const quickDuration60Btn = document.getElementById('quickDuration60');
            
            if (quickDuration30Btn && quickDuration60Btn) {
                quickDuration30Btn.textContent = `${firstDuration}min`;
                quickDuration60Btn.textContent = `${secondDuration}min`;
                
                // Store the actual durations for button functionality
                quickDuration30Btn.dataset.duration = firstDuration;
                quickDuration60Btn.dataset.duration = secondDuration;
            }
        }
        // Formats a Date object into "YYYY-MM-DD" string
        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        // Parses a "YYYY-MM-DD" string back into a Date object
        function parseDateKey(dateKey) { 
            const parts = dateKey.split('-');
            // Month is 0-indexed in Date constructor
            return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
        }

        // --- Search Logic ---
        function performSearch() {
            const query = searchInput.value.trim().toLowerCase();
            if (!query) {
                searchResultsContainerEl.innerHTML = '<p class="text-slate-500">Por favor, introduce un término de búsqueda.</p>';
                openSearchResultsModal();
                return;
            }
            const allFoundAppointments = [];
            const userAppointments = getCurrentUserAppointments();
            // Iterate through all dates and appointments for current user
            Object.keys(userAppointments).forEach(dateKey => {
                userAppointments[dateKey].forEach(appt => {
                    // Check if title includes the query (case-insensitive)
                    if (appt.title.toLowerCase().includes(query)) {
                        // Add the dateKey to the found appointment object
                        allFoundAppointments.push({...appt, dateKey: dateKey }); 
                    }
                });
            });
            displaySearchResults(allFoundAppointments); // Display results
            openSearchResultsModal(); // Show results modal
        }
        function displaySearchResults(foundAppointments) {
            searchResultsContainerEl.innerHTML = ''; // Clear previous results
            if (foundAppointments.length === 0) {
                searchResultsContainerEl.innerHTML = '<p class="text-slate-500">No se encontraron citas con ese título.</p>';
                return;
            }
            // Sort results chronologically
            foundAppointments.sort((a,b) => { 
                const dateA = parseDateKey(a.dateKey).getTime();
                const dateB = parseDateKey(b.dateKey).getTime();
                if (dateA !== dateB) return dateA - dateB; // Sort by date first
                const timeA = a.startHour * 60 + a.startMinute;
                const timeB = b.startHour * 60 + b.startMinute;
                return timeA - timeB; // Then sort by time
            });
            // Create HTML elements for each result
            foundAppointments.forEach(appt => {
                const resultItem = document.createElement('div');
                resultItem.classList.add('search-result-item');
                // Title
                const titleEl = document.createElement('p');
                titleEl.classList.add('font-semibold', 'text-indigo-600', 'text-lg');
                titleEl.textContent = appt.title;
                resultItem.appendChild(titleEl);
                // Date
                const dateObj = parseDateKey(appt.dateKey); 
                const dateEl = document.createElement('p');
                dateEl.classList.add('text-sm', 'text-slate-500');
                dateEl.textContent = `Fecha: ${dateObj.toLocaleDateString('es-ES', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' })}`;
                resultItem.appendChild(dateEl);
                // Time
                const timeEl = document.createElement('p');
                timeEl.classList.add('text-sm', 'text-slate-500');
                const startTimeStr = `${String(appt.startHour).padStart(2, '0')}:${String(appt.startMinute).padStart(2, '0')}`;
                const endTimeStr = formatEndTime(appt.startHour, appt.startMinute, appt.duration);
                timeEl.textContent = `Hora: ${startTimeStr} - ${endTimeStr}`;
                resultItem.appendChild(timeEl);
                // Details Snippet (if exists)
                if (appt.details) {
                    const detailsEl = document.createElement('p');
                    detailsEl.classList.add('text-sm', 'text-slate-600', 'mt-2', 'whitespace-pre-wrap');
                    const snippetLength = 100; // Max length for snippet
                    detailsEl.textContent = `Detalles: ${appt.details.length > snippetLength ? appt.details.substring(0, snippetLength) + '...' : appt.details}`;
                    resultItem.appendChild(detailsEl);
                }
                // Click listener to open the details modal for this result
                resultItem.addEventListener('click', () => {
                    closeSearchResultsModal(); 
                    openViewAppointmentDetailsModal(appt, appt.dateKey); // Pass dateKey
                });
                searchResultsContainerEl.appendChild(resultItem);
            });
        }
        function openSearchResultsModal() {
            searchResultsModalEl.classList.add('active');
        }
        function closeSearchResultsModal() {
            searchResultsModalEl.classList.remove('active');
        }

        // --- Event Listeners Setup ---
        // Month Navigation
        document.getElementById('prevMonthBtn').addEventListener('click', () => {
            currentDisplayDate.setMonth(currentDisplayDate.getMonth() - 1); renderMonthView();
        });
        document.getElementById('nextMonthBtn').addEventListener('click', () => {
            currentDisplayDate.setMonth(currentDisplayDate.getMonth() + 1); renderMonthView();
        });
        // View Toggles
        document.getElementById('showMonthViewBtn').addEventListener('click', () => {
            currentDisplayDate = new Date(selectedAgendaDate); renderMonthView();
        });
        document.getElementById('showAgendaViewBtn').addEventListener('click', () => {
            selectedAgendaDate = new Date(); selectedAgendaDate.setHours(0,0,0,0); renderAgendaView();
        });
        // Add/Edit Modal Actions
        saveAppointmentBtn.addEventListener('click', saveCurrentAppointment);
        document.getElementById('cancelAddAppointment').addEventListener('click', closeAddAppointmentModal);
        // View Details Modal Actions
        document.getElementById('closeViewAppointmentDetails').addEventListener('click', closeViewAppointmentDetailsModal);
        editAppointmentBtn.addEventListener('click', () => { // Edit button in details modal
            if (appointmentContextForDetails) { 
                const apptData = appointmentContextForDetails.data;
                const apptDateKey = appointmentContextForDetails.dateKey; 
                const dateOfAppointment = parseDateKey(apptDateKey); 
                // Open the add/edit modal in edit mode
                openAddAppointmentModal(dateOfAppointment, apptData.startHour, apptData.startMinute, 0, apptData);
                closeViewAppointmentDetailsModal(); // Close details modal
            }
        });
        deleteAppointmentFromDetailsBtn.addEventListener('click', () => { // Delete button in details modal
             if (appointmentContextForDetails) {
                handleDeleteAppointment(appointmentContextForDetails.data, appointmentContextForDetails.dateKey);
             }
        });
        // Search Actions
        searchIconBtn.addEventListener('click', () => { // Toggle search bar visibility
            searchBarContainer.classList.toggle('hidden');
            if (!searchBarContainer.classList.contains('hidden')) {
                searchInput.focus(); // Focus input when shown
            }
        });
        searchAppointmentBtn.addEventListener('click', performSearch); // Search button click
        searchInput.addEventListener('keypress', (event) => { // Search on Enter key
            if (event.key === 'Enter') performSearch();
        });
        closeSearchResultsModalBtn.addEventListener('click', closeSearchResultsModal); // Close search results
        // Update time info when start time selects change
        appointmentStartHourSelect.addEventListener('change', updateAppointmentTimeInfo);
        appointmentStartMinuteSelect.addEventListener('change', updateAppointmentTimeInfo);
        
        // Update time info when date changes (for editing)
        appointmentDateInput.addEventListener('change', updateAppointmentTimeInfo);
        
        // Update time info when user changes (for transfer)
        appointmentUserSelect.addEventListener('change', updateAppointmentTimeInfo);
        
        // User Management Event Listeners
        addUserBtn.addEventListener('click', openAddUserModal);
        saveNewUserBtn.addEventListener('click', addNewUser);
        cancelAddUserBtn.addEventListener('click', closeAddUserModal);
        
        // Edit User Event Listeners
        saveEditUserBtn.addEventListener('click', saveEditUser);
        cancelEditUserBtn.addEventListener('click', closeEditUserModal);
        
        // Delete User Event Listeners
        confirmDeleteUserBtn.addEventListener('click', confirmDeleteUser);
        cancelDeleteUserBtn.addEventListener('click', closeDeleteUserModal);
        
        // Close modals when clicking outside
        addUserModalEl.addEventListener('click', (event) => {
            if (event.target === addUserModalEl) {
                closeAddUserModal();
            }
        });
        
        editUserModalEl.addEventListener('click', (event) => {
            if (event.target === editUserModalEl) {
                closeEditUserModal();
            }
        });
        
        deleteUserModalEl.addEventListener('click', (event) => {
            if (event.target === deleteUserModalEl) {
                closeDeleteUserModal();
            }
        });
        
        // Date Selector Wheel Navigation
        prevDateBtnEl.addEventListener('click', () => {
            const prevDate = new Date(selectedAgendaDate);
            prevDate.setDate(prevDate.getDate() - 1);
            navigateToDate(prevDate);
        });
        
        nextDateBtnEl.addEventListener('click', () => {
            const nextDate = new Date(selectedAgendaDate);
            nextDate.setDate(nextDate.getDate() + 1);
            navigateToDate(nextDate);
        });
        
        // Click on date elements to navigate
        prevDateEl.addEventListener('click', () => {
            const prevDate = new Date(selectedAgendaDate);
            prevDate.setDate(prevDate.getDate() - 1);
            navigateToDate(prevDate);
        });
        
        nextDateEl.addEventListener('click', () => {
            const nextDate = new Date(selectedAgendaDate);
            nextDate.setDate(nextDate.getDate() + 1);
            navigateToDate(nextDate);
        });
        
        // Mouse wheel navigation on the date selector wheel
        dateSelectorWheelEl.addEventListener('wheel', (event) => {
            event.preventDefault(); // Prevent page scrolling
            const delta = event.deltaY;
            
            if (delta > 0) {
                // Scroll down - go to next date
                const nextDate = new Date(selectedAgendaDate);
                nextDate.setDate(nextDate.getDate() + 1);
                navigateToDate(nextDate);
            } else {
                // Scroll up - go to previous date
                const prevDate = new Date(selectedAgendaDate);
                prevDate.setDate(prevDate.getDate() - 1);
                navigateToDate(prevDate);
            }
        });
        
        // Touch gesture event listeners for mobile swipe navigation
        // Add touch events to the entire agenda view for better mobile experience
        agendaViewEl.addEventListener('touchstart', handleTouchStart, { passive: false });
        agendaViewEl.addEventListener('touchmove', handleTouchMove, { passive: false });
        agendaViewEl.addEventListener('touchend', handleTouchEnd, { passive: true });
        
        // Also add touch events specifically to the date selector wheel for more precise control
        dateSelectorWheelEl.addEventListener('touchstart', handleTouchStart, { passive: false });
        dateSelectorWheelEl.addEventListener('touchmove', handleTouchMove, { passive: false });
        dateSelectorWheelEl.addEventListener('touchend', handleTouchEnd, { passive: true });
        
        // Quick duration buttons functionality
        document.getElementById('quickDuration30').addEventListener('click', () => {
            const buttonDuration = parseInt(document.getElementById('quickDuration30').dataset.duration) || 30;
            const maxDuration = currentAppointmentContext ? currentAppointmentContext.currentMaxDuration : 1440;
            const duration = Math.min(buttonDuration, maxDuration);
            appointmentDurationInput.value = duration;
            if (currentAppointmentContext) {
                updateAppointmentTimeInfo();
            }
        });
        
        document.getElementById('quickDuration60').addEventListener('click', () => {
            const buttonDuration = parseInt(document.getElementById('quickDuration60').dataset.duration) || 60;
            const maxDuration = currentAppointmentContext ? currentAppointmentContext.currentMaxDuration : 1440;
            const duration = Math.min(buttonDuration, maxDuration);
            appointmentDurationInput.value = duration;
            if (currentAppointmentContext) {
                updateAppointmentTimeInfo();
            }
        });
        // Global keydown listener (for Escape key to close modals)
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                if (addAppointmentModalEl.classList.contains('active')) closeAddAppointmentModal();
                if (viewAppointmentDetailsModalEl.classList.contains('active')) closeViewAppointmentDetailsModal();
                if (searchResultsModalEl.classList.contains('active')) closeSearchResultsModal();
            }
        });
        // Click outside modals to close
        addAppointmentModalEl.addEventListener('click', (event) => { 
            if (event.target === addAppointmentModalEl) closeAddAppointmentModal();
        });
        viewAppointmentDetailsModalEl.addEventListener('click', (event) => { 
            if (event.target === viewAppointmentDetailsModalEl) closeViewAppointmentDetailsModal();
        });
        searchResultsModalEl.addEventListener('click', (event) => { 
            if (event.target === searchResultsModalEl) closeSearchResultsModal();
        });

        // --- Initialization ---
        populateTimeSelects(); // Populate time selects on load
        updateUserInterface(); // Initialize user interface
        updateQuickDurationButtons(); // Initialize quick duration buttons with most used durations
        renderMonthView(); // Initial render

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js') // Use relative path
              .then(registration => console.log('ServiceWorker registrado con éxito:', registration.scope))
              .catch(error => console.log('Error al registrar ServiceWorker:', error));
          });
        }
    </script>

</body>
</html>
