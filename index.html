<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agenda Web</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3b82f6">

    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }
        .time-slot {
            display: flex;
            height: 40px; /* Fixed height for time slots */
            border: 1px solid #e2e8f0; /* Tailwind slate-200 */
            border-radius: 0.375rem; /* Tailwind rounded-md */
            overflow: hidden; /* Contain segments */
        }
        .time-segment {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; /* Tailwind text-xs */
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: default; /* Default cursor */
        }
        .free-segment {
            background-color: #f0f9ff; /* Tailwind sky-50 */
            cursor: pointer; /* Clickable */
            transition: background-color 0.2s;
            color: #0ea5e9; /* Tailwind sky-600 */
        }
        .free-segment:hover {
            background-color: #e0f2fe; /* Tailwind sky-100 */
        }
        .booked-segment {
            padding-left: 4px;
            padding-right: 4px;
            cursor: pointer; /* Clickable to view details */
        }
        .booked-segment:hover {
            filter: brightness(105%); /* Slight brightness increase on hover */
        }
        /* Text color classes based on background brightness */
        .booked-segment.dark-text { 
            color: #1f2937; /* Tailwind gray-800 */
        }
        .booked-segment.light-text { 
            color: #f9fafb; /* Tailwind gray-50 */
        }
        /* Delete button text color classes */
        .booked-segment .delete-btn.dark-text {
             color: #4b5563; /* Tailwind gray-600 */
        }
        .booked-segment .delete-btn.dark-text:hover {
            color: #dc2626; /* Tailwind red-600 */
        }
        .booked-segment .delete-btn.light-text {
            color: #e5e7eb; /* Tailwind gray-200 */
        }
        .booked-segment .delete-btn.light-text:hover {
            color: #fecaca; /* Tailwind red-200 */
        }

        /* Modal styles */
        .modal {
            display: none; /* Hidden by default */
        }
        .modal.active {
            display: flex; /* Show when active */
        }
        /* Custom scrollbar styles */
        .agenda-slots-container::-webkit-scrollbar,
        #searchResultsContainer::-webkit-scrollbar {
            width: 8px;
        }
        .agenda-slots-container::-webkit-scrollbar-track,
        #searchResultsContainer::-webkit-scrollbar-track {
            background: #f1f5f9; /* Tailwind slate-100 */
        }
        .agenda-slots-container::-webkit-scrollbar-thumb,
        #searchResultsContainer::-webkit-scrollbar-thumb {
            background: #94a3b8; /* Tailwind slate-400 */
            border-radius: 4px;
        }
        .agenda-slots-container::-webkit-scrollbar-thumb:hover,
        #searchResultsContainer::-webkit-scrollbar-thumb:hover {
            background: #64748b; /* Tailwind slate-500 */
        }
        /* Style for details content in modal */
        .details-content {
            white-space: pre-wrap; /* Preserve whitespace and line breaks */
            max-height: 200px; /* Limit height */
            overflow-y: auto; /* Add scroll if needed */
            background-color: #f9fafb; /* Tailwind gray-50 */
            border: 1px solid #e5e7eb; /* Tailwind gray-200 */
            padding: 8px;
            border-radius: 0.25rem; /* Tailwind rounded-sm */
        }
        /* Style for search result items */
        .search-result-item {
            border: 1px solid #e5e7eb; /* Tailwind gray-200 */
            border-radius: 0.375rem; /* Tailwind rounded-md */
            padding: 0.75rem; /* Tailwind p-3 */
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .search-result-item:hover {
            background-color: #f9fafb; /* Tailwind gray-50 */
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 antialiased">

    <div id="app-container" class="container mx-auto p-4 max-w-4xl">

        <div class="mb-6 p-4 bg-white rounded-xl shadow-lg">
            <div class="flex justify-between items-center mb-3">
                <h3 class="text-lg font-semibold text-slate-700">Agenda</h3>
                <button id="searchIconBtn" aria-label="Abrir búsqueda de citas" class="p-2 text-slate-600 hover:text-indigo-600 transition-colors rounded-full hover:bg-indigo-100">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
                    </svg>
                </button>
            </div>
            <div id="searchBarContainer" class="hidden"> 
                <div class="flex flex-col sm:flex-row items-stretch space-y-3 sm:space-y-0 sm:space-x-3">
                    <input type="text" id="searchInput" placeholder="Buscar por título..." class="flex-grow p-2 border border-slate-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500">
                    <button id="searchAppointmentBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-5 h-5 inline-block mr-1">
                            <path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" />
                        </svg>
                        Buscar
                    </button>
                </div>
            </div>
        </div>

        <div class="mb-6 flex justify-center space-x-4">
            <button id="showMonthViewBtn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out">Vista Mensual</button>
            <button id="showAgendaViewBtn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-4 rounded-lg shadow transition duration-150 ease-in-out">Vista Agenda (Hoy)</button>
        </div>

        <div id="monthView" class="bg-white p-6 rounded-xl shadow-lg">
            <div class="flex justify-between items-center mb-4">
                <button id="prevMonthBtn" class="text-blue-500 hover:text-blue-700 p-2 rounded-full transition">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                    </svg>
                </button>
                <h2 id="currentMonthYear" class="text-2xl font-bold text-slate-700"></h2>
                <button id="nextMonthBtn" class="text-blue-500 hover:text-blue-700 p-2 rounded-full transition">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                    </svg>
                </button>
            </div>
            <div id="calendarGrid" class="grid grid-cols-7 gap-1 text-center">
                </div>
        </div>

        <div id="agendaView" class="hidden bg-white p-6 rounded-xl shadow-lg mt-6">
            <h2 id="agendaDateTitle" class="text-2xl font-bold text-slate-700 mb-6 text-center">Agenda para: </h2>
            <div class="flex border-b pb-2 mb-2">
                <div class="w-1/4 font-semibold text-slate-600 pl-2">Hora</div>
                <div class="w-3/4 font-semibold text-slate-600 pl-2">Actividad</div>
            </div>
            <div id="agendaSlotsContainer" class="space-y-1 max-h-[70vh] overflow-y-auto agenda-slots-container pr-2">
                </div>
        </div>
    </div>

    <div id="addAppointmentModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 id="modalTitle" class="text-xl font-semibold mb-4 text-slate-700">Añadir Nueva Cita</h3>
            <div class="mb-4">
                <label for="appointmentTitle" class="block text-sm font-medium text-slate-600 mb-1">Título de la Cita:</label>
                <input type="text" id="appointmentTitle" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
            </div>
            
            <div class="flex space-x-3 mb-4">
                <div class="w-1/2">
                    <label for="appointmentStartHour" class="block text-sm font-medium text-slate-600 mb-1">Hora Inicio:</label>
                    <select id="appointmentStartHour" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white">
                        </select>
                </div>
                <div class="w-1/2">
                    <label for="appointmentStartMinute" class="block text-sm font-medium text-slate-600 mb-1">Minuto Inicio:</label>
                    <select id="appointmentStartMinute" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500 bg-white">
                        </select>
                </div>
            </div>

            <div class="mb-4">
                <label for="appointmentDuration" class="block text-sm font-medium text-slate-600 mb-1">Duración (minutos):</label>
                <input type="number" id="appointmentDuration" min="1" value="30" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
            </div>
            <div class="mb-4">
                <label for="appointmentDetails" class="block text-sm font-medium text-slate-600 mb-1">Detalles (opcional):</label>
                <textarea id="appointmentDetails" rows="3" class="w-full p-2 border border-slate-300 rounded-md focus:ring-blue-500 focus:border-blue-500"></textarea>
            </div>
            <p id="appointmentTimeInfo" class="text-sm text-slate-500 mb-4"></p>
            <div class="flex justify-end space-x-3">
                <button id="cancelAddAppointment" class="bg-slate-200 hover:bg-slate-300 text-slate-700 font-medium py-2 px-4 rounded-md transition">Cancelar</button>
                <button id="saveAppointment" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition">Guardar Cita</button>
            </div>
        </div>
    </div>

    <div id="viewAppointmentDetailsModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
            <h3 id="viewAppointmentTitle" class="text-xl font-semibold mb-2 text-slate-700"></h3>
            <p id="viewAppointmentTime" class="text-sm text-slate-500 mb-1"></p>
            <p id="viewAppointmentDuration" class="text-sm text-slate-500 mb-3"></p>
            <h4 class="text-md font-semibold text-slate-600 mb-1">Detalles:</h4>
            <div id="viewAppointmentDetailsContent" class="details-content mb-4 text-sm text-slate-700"></div>
            <div class="flex justify-between items-center"> 
                <div>
                    <button id="editAppointmentBtn" class="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-md transition mr-2">Editar</button>
                    <button id="deleteAppointmentFromDetailsBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-4 rounded-md transition">Eliminar</button>
                </div>
                <button id="closeViewAppointmentDetails" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 rounded-md transition">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="searchResultsModal" class="modal fixed inset-0 bg-gray-800 bg-opacity-75 items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg max-h-[80vh] flex flex-col">
            <h3 class="text-xl font-semibold mb-4 text-slate-700">Resultados de la Búsqueda</h3>
            <div id="searchResultsContainer" class="flex-grow overflow-y-auto space-y-3 mb-4 pr-2">
                </div>
            <div class="flex justify-end">
                <button id="closeSearchResultsModal" class="bg-slate-500 hover:bg-slate-600 text-white font-semibold py-2 px-4 rounded-md transition">Cerrar</button>
            </div>
        </div>
    </div>


    <script>
        // --- Application State ---
        let currentDisplayDate = new Date(); // Date for month view
        let selectedAgendaDate = new Date(); // Date for agenda view
        selectedAgendaDate.setHours(0, 0, 0, 0); // Normalize to midnight
        // Appointments stored as { "YYYY-MM-DD": [ { id, title, startHour, startMinute, duration, color, details } ] }
        let appointments = JSON.parse(localStorage.getItem('appointments')) || {};
        
        // Color palette for appointments
        const distinctColors = [
            '#EF5350', '#42A5F5', '#66BB6A', '#FFA726', '#AB47BC', 
            '#29B6F6', '#FFEE58', '#26A69A', '#EC407A', '#7E57C2'
        ];
        // Function to determine if a color is light (needs dark text)
        function isColorLight(hexColor) {
            if (!hexColor || hexColor.length < 7) return true; // Default to dark text if color is invalid
            const r = parseInt(hexColor.slice(1, 3), 16);
            const g = parseInt(hexColor.slice(3, 5), 16);
            const b = parseInt(hexColor.slice(5, 7), 16);
            const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return yiq >= 128;
        }
        let nextColorIndex = parseInt(localStorage.getItem('nextColorIndex') || '0');

        // --- DOM Element References ---
        const monthViewEl = document.getElementById('monthView');
        const agendaViewEl = document.getElementById('agendaView');
        const currentMonthYearEl = document.getElementById('currentMonthYear');
        const calendarGridEl = document.getElementById('calendarGrid');
        const agendaSlotsContainerEl = document.getElementById('agendaSlotsContainer');
        const agendaDateTitleEl = document.getElementById('agendaDateTitle');
        // Add/Edit Modal Elements
        const addAppointmentModalEl = document.getElementById('addAppointmentModal');
        const modalTitleEl = document.getElementById('modalTitle'); 
        const appointmentTitleInput = document.getElementById('appointmentTitle');
        const appointmentStartHourSelect = document.getElementById('appointmentStartHour'); 
        const appointmentStartMinuteSelect = document.getElementById('appointmentStartMinute'); 
        const appointmentDurationInput = document.getElementById('appointmentDuration');
        const appointmentDetailsInput = document.getElementById('appointmentDetails'); 
        const appointmentTimeInfoEl = document.getElementById('appointmentTimeInfo');
        const saveAppointmentBtn = document.getElementById('saveAppointment');
        // View Details Modal Elements
        const viewAppointmentDetailsModalEl = document.getElementById('viewAppointmentDetailsModal');
        const viewAppointmentTitleEl = document.getElementById('viewAppointmentTitle');
        const viewAppointmentTimeEl = document.getElementById('viewAppointmentTime');
        const viewAppointmentDurationEl = document.getElementById('viewAppointmentDuration');
        const viewAppointmentDetailsContentEl = document.getElementById('viewAppointmentDetailsContent');
        const editAppointmentBtn = document.getElementById('editAppointmentBtn'); 
        const deleteAppointmentFromDetailsBtn = document.getElementById('deleteAppointmentFromDetailsBtn'); 
        // Search Elements
        const searchIconBtn = document.getElementById('searchIconBtn');
        const searchBarContainer = document.getElementById('searchBarContainer');
        const searchInput = document.getElementById('searchInput');
        const searchAppointmentBtn = document.getElementById('searchAppointmentBtn');
        const searchResultsModalEl = document.getElementById('searchResultsModal');
        const searchResultsContainerEl = document.getElementById('searchResultsContainer');
        const closeSearchResultsModalBtn = document.getElementById('closeSearchResultsModal');

        // --- Context Variables ---
        // Stores context for adding/editing an appointment
        // { date, initialHour, initialMinute, currentSelectedHour, currentSelectedMinute, currentMaxDuration, editingAppointmentId, originalDateKey }
        let currentAppointmentContext = null; 
        // Stores context for the appointment being viewed in the details modal
        // { data: appointmentData, dateKey: key }
        let appointmentContextForDetails = null; 

        // --- Core Application Logic ---

        // Renders the month view calendar
        function renderMonthView() {
            monthViewEl.classList.remove('hidden');
            agendaViewEl.classList.add('hidden');
            const year = currentDisplayDate.getFullYear();
            const month = currentDisplayDate.getMonth();
            currentMonthYearEl.textContent = `${currentDisplayDate.toLocaleString('es-ES', { month: 'long' })} ${year}`;
            // Clear previous grid and add headers
            calendarGridEl.innerHTML = `
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">DOM</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">LUN</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">MAR</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">MIÉ</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">JUE</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">VIE</div>
                <div class="font-semibold text-slate-500 py-2 text-xs sm:text-sm">SÁB</div>
            `;
            // Calculate calendar grid parameters
            const firstDayOfMonth = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const today = new Date();
            today.setHours(0,0,0,0); // Normalize today to midnight for comparison
            // Add empty cells for days before the 1st of the month
            for (let i = 0; i < firstDayOfMonth; i++) {
                calendarGridEl.appendChild(document.createElement('div'));
            }
            // Add cells for each day of the month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayCell = document.createElement('div');
                dayCell.textContent = day;
                dayCell.classList.add('py-2', 'sm:py-3', 'cursor-pointer', 'hover:bg-blue-100', 'rounded-full', 'transition-colors', 'duration-150', 'flex', 'items-center', 'justify-center', 'text-sm', 'sm:text-base');
                const cellDate = new Date(year, month, day);
                // Highlight today's date
                if (cellDate.getTime() === today.getTime()) {
                    dayCell.classList.add('bg-blue-500', 'text-white', 'font-semibold');
                    dayCell.classList.remove('hover:bg-blue-100');
                } else {
                    dayCell.classList.add('text-slate-700');
                }
                // Add dot indicator if there are appointments on this day
                const dateKey = formatDateKey(cellDate);
                if (appointments[dateKey] && appointments[dateKey].length > 0) {
                    const dot = document.createElement('span');
                    dot.classList.add('h-1.5', 'w-1.5', 'bg-green-500', 'rounded-full', 'ml-1', 'inline-block', 'align-middle');
                     if (cellDate.getTime() === today.getTime()) { // Use white dot on today's highlight
                        dot.classList.remove('bg-green-500');
                        dot.classList.add('bg-white');
                    }
                    dayCell.appendChild(dot);
                }
                // Add click listener to switch to agenda view for this day
                dayCell.addEventListener('click', () => {
                    selectedAgendaDate = new Date(year, month, day);
                    selectedAgendaDate.setHours(0,0,0,0);
                    renderAgendaView();
                });
                calendarGridEl.appendChild(dayCell);
            }
        }

        // Renders the daily agenda view
        function renderAgendaView() {
            monthViewEl.classList.add('hidden');
            agendaViewEl.classList.remove('hidden');
            agendaDateTitleEl.textContent = `Agenda para: ${selectedAgendaDate.toLocaleDateString('es-ES', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}`;
            agendaSlotsContainerEl.innerHTML = ''; // Clear previous slots
            const dateKey = formatDateKey(selectedAgendaDate);
            // Get and sort appointments for the selected day
            const dailyAppointments = (appointments[dateKey] || []).sort((a, b) => {
                if (a.startHour === b.startHour) return a.startMinute - b.startMinute;
                return a.startHour - b.startHour;
            });
            // Create a row for each hour (0-23)
            for (let hour = 0; hour < 24; hour++) {
                const hourRow = document.createElement('div');
                hourRow.classList.add('flex', 'items-stretch', 'min-h-[40px]');
                // Hour Label Column
                const hourLabel = document.createElement('div');
                hourLabel.classList.add('w-1/4', 'py-2', 'pr-2', 'text-sm', 'text-slate-600', 'flex', 'items-center', 'border-r', 'border-slate-200');
                hourLabel.textContent = `${String(hour).padStart(2, '0')}:00`;
                hourRow.appendChild(hourLabel);
                // Time Slot Bar Column
                const slotCell = document.createElement('div');
                slotCell.classList.add('w-3/4', 'pl-2');
                const timeSlotBar = document.createElement('div');
                timeSlotBar.classList.add('time-slot');
                // Populate the time slot bar with free/booked segments
                populateTimeSlotBar(timeSlotBar, hour, dailyAppointments);
                slotCell.appendChild(timeSlotBar);
                hourRow.appendChild(slotCell);
                agendaSlotsContainerEl.appendChild(hourRow);
            }
        }

        // Populates a single hour's time slot bar with segments
        function populateTimeSlotBar(timeSlotBar, hour, dailyAppointments) {
            let currentMinuteInHour = 0;
            const appointmentsInThisHour = [];
            // Find all appointments that overlap with this hour
            dailyAppointments.forEach(appt => {
                const apptStartTotalMinutes = appt.startHour * 60 + appt.startMinute;
                const apptEndTotalMinutes = apptStartTotalMinutes + appt.duration;
                const hourStartTotalMinutes = hour * 60;
                const hourEndTotalMinutes = (hour + 1) * 60;
                // Check for overlap
                if (apptStartTotalMinutes < hourEndTotalMinutes && apptEndTotalMinutes > hourStartTotalMinutes) {
                    // Calculate the portion of the appointment within this hour
                    const startMinuteInSlot = Math.max(0, apptStartTotalMinutes - hourStartTotalMinutes);
                    const endMinuteInSlot = Math.min(60, apptEndTotalMinutes - hourStartTotalMinutes);
                    const durationInSlot = endMinuteInSlot - startMinuteInSlot;
                    if (durationInSlot > 0) {
                        appointmentsInThisHour.push({...appt, displayStartMinute: startMinuteInSlot, displayDuration: durationInSlot});
                    }
                }
            });
            // Sort segments within the hour by start time
            appointmentsInThisHour.sort((a,b) => a.displayStartMinute - b.displayStartMinute);
            // Create and append segments (free or booked)
            appointmentsInThisHour.forEach(apptSegment => {
                // Add free segment before this appointment if there's a gap
                if (apptSegment.displayStartMinute > currentMinuteInHour) {
                    const freeDuration = apptSegment.displayStartMinute - currentMinuteInHour;
                    timeSlotBar.appendChild(createTimeSegment(hour, currentMinuteInHour, freeDuration, true, null));
                }
                // Add the booked appointment segment
                timeSlotBar.appendChild(createTimeSegment(hour, apptSegment.displayStartMinute, apptSegment.displayDuration, false, apptSegment));
                currentMinuteInHour = apptSegment.displayStartMinute + apptSegment.displayDuration;
            });
            // Add remaining free segment at the end of the hour if needed
            if (currentMinuteInHour < 60) {
                const freeDuration = 60 - currentMinuteInHour;
                timeSlotBar.appendChild(createTimeSegment(hour, currentMinuteInHour, freeDuration, true, null));
            }
        }

        // Creates a single segment (free or booked) for the time slot bar
        function createTimeSegment(hour, startMinuteOffset, durationMinutes, isFree, appointmentData) {
            const segment = document.createElement('div');
            segment.classList.add('time-segment');
            segment.style.width = `${(durationMinutes / 60) * 100}%`; // Width proportional to duration

            if (isFree) {
                segment.classList.add('free-segment');
                if (durationMinutes > 10) segment.textContent = `${durationMinutes}m libres`; // Show text if space allows
                segment.title = `Añadir cita a las ${String(hour).padStart(2, '0')}:${String(startMinuteOffset).padStart(2, '0')} (${durationMinutes}m disponibles)`;
                // Click listener to open the add modal
                segment.addEventListener('click', () => {
                    const maxDurationPossible = calculateContiguousFreeTime(selectedAgendaDate, hour, startMinuteOffset);
                    openAddAppointmentModal(selectedAgendaDate, hour, startMinuteOffset, maxDurationPossible);
                });
            } else { // Booked segment
                segment.classList.add('booked-segment');
                const bgColor = appointmentData.color || '#EF5350'; // Use assigned color or fallback
                segment.style.backgroundColor = bgColor; 
                // Adjust text color based on background brightness
                if (isColorLight(bgColor)) {
                    segment.classList.add('dark-text'); segment.classList.remove('light-text');
                } else {
                    segment.classList.add('light-text'); segment.classList.remove('dark-text');
                }
                segment.textContent = appointmentData.title; // Display title
                // Tooltip with full details
                const startTimeStr = `${String(appointmentData.startHour).padStart(2, '0')}:${String(appointmentData.startMinute).padStart(2, '0')}`;
                const endTimeStr = formatEndTime(appointmentData.startHour, appointmentData.startMinute, appointmentData.duration);
                segment.title = `${appointmentData.title} (${startTimeStr} - ${endTimeStr}, ${appointmentData.duration}m). Haz clic para ver detalles.`;
                // Click listener to open the view details modal
                segment.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    openViewAppointmentDetailsModal(appointmentData, formatDateKey(selectedAgendaDate)); // Pass dateKey
                });
                // Add delete button ('x') directly on the segment
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = '&times;'; // 'x' symbol
                deleteBtn.classList.add('ml-1', 'delete-btn', 'opacity-70', 'hover:opacity-100', 'font-bold', 'text-xs', 'p-0.5', 'rounded-full');
                // Apply text color class to delete button as well
                if (isColorLight(bgColor)) deleteBtn.classList.add('dark-text');
                else deleteBtn.classList.add('light-text');
                deleteBtn.title = 'Eliminar cita';
                deleteBtn.style.lineHeight = '1'; 
                // Click listener for the delete button
                deleteBtn.onclick = (e) => {
                    e.stopPropagation(); // Prevent opening details modal
                    console.log('Click en botón X:', appointmentData.id, formatDateKey(selectedAgendaDate)); 
                    if (confirm(`¿Eliminar cita "${appointmentData.title}"?`)) {
                        deleteAppointment(appointmentData.id, formatDateKey(selectedAgendaDate));
                    }
                };
                // Only show delete button if segment is wide enough
                if (durationMinutes > 20 && segment.offsetWidth > 30) { // Heuristic check
                    segment.appendChild(deleteBtn);
                }
            }
            return segment;
        }

        // Calculates the maximum contiguous free time starting from a specific point
        function calculateContiguousFreeTime(targetDate, startHour, startMinute, editingApptId = null) {
            const dateKey = formatDateKey(targetDate);
            // Get appointments for the day, excluding the one being edited (if any)
            const dailyAppts = (appointments[dateKey] || [])
                .filter(appt => appt.id !== editingApptId) 
                .slice()
                .sort((a, b) => (a.startHour * 60 + a.startMinute) - (b.startHour * 60 + b.startMinute));
            
            const checkFromMinuteOfDay = startHour * 60 + startMinute;
            // Find the next appointment that starts at or after the check time
            let nextBlockingAppt = dailyAppts.find(appt => (appt.startHour * 60 + appt.startMinute) >= checkFromMinuteOfDay);
            
            // Calculate free minutes until the next appointment or end of day
            return nextBlockingAppt ? (nextBlockingAppt.startHour * 60 + nextBlockingAppt.startMinute) - checkFromMinuteOfDay : (24 * 60) - checkFromMinuteOfDay;
        }

        // Formats the end time given start time and duration
        function formatEndTime(startHour, startMinute, duration) {
            let endTotalMinutes = startHour * 60 + startMinute + duration;
            let endHour = Math.floor(endTotalMinutes / 60) % 24; // Handle crossing midnight
            let endMinute = endTotalMinutes % 60;
            return `${String(endHour).padStart(2, '0')}:${String(endMinute).padStart(2, '0')}`;
        }

        // Populates the hour and minute select dropdowns in the add/edit modal
        function populateTimeSelects() {
            appointmentStartHourSelect.innerHTML = '';
            for (let i = 0; i < 24; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = String(i).padStart(2, '0');
                appointmentStartHourSelect.appendChild(option);
            }
            appointmentStartMinuteSelect.innerHTML = '';
            // Using 5-minute increments for minutes dropdown
            for (let i = 0; i < 60; i += 5) { 
                const option = document.createElement('option');
                option.value = i;
                option.textContent = String(i).padStart(2, '0');
                appointmentStartMinuteSelect.appendChild(option);
            }
        }

        // Updates the time info text and max duration in the add/edit modal
        function updateAppointmentTimeInfo() {
            if (!currentAppointmentContext) return;
            const selectedHour = parseInt(appointmentStartHourSelect.value);
            const selectedMinute = parseInt(appointmentStartMinuteSelect.value);
            // Update context with currently selected time
            currentAppointmentContext.currentSelectedHour = selectedHour;
            currentAppointmentContext.currentSelectedMinute = selectedMinute;
            // Recalculate max duration based on selected time
            currentAppointmentContext.currentMaxDuration = calculateContiguousFreeTime(
                currentAppointmentContext.date, 
                selectedHour, 
                selectedMinute,
                currentAppointmentContext.editingAppointmentId // Pass ID if editing
            );
            // Update the max attribute of the duration input
            appointmentDurationInput.max = currentAppointmentContext.currentMaxDuration;
            // Adjust duration value if it exceeds the new max
            if (parseInt(appointmentDurationInput.value) > currentAppointmentContext.currentMaxDuration && currentAppointmentContext.currentMaxDuration > 0) {
                appointmentDurationInput.value = currentAppointmentContext.currentMaxDuration;
            } else if (currentAppointmentContext.currentMaxDuration <= 0 && !currentAppointmentContext.editingAppointmentId) { 
                 appointmentDurationInput.value = 1; // Prevent 0 or negative duration if no space
            }
            // Update the info text
             appointmentTimeInfoEl.textContent = `Cita para el ${currentAppointmentContext.date.toLocaleDateString('es-ES')} a las ${String(selectedHour).padStart(2, '0')}:${String(selectedMinute).padStart(2, '0')}. Duración máxima: ${currentAppointmentContext.currentMaxDuration > 0 ? currentAppointmentContext.currentMaxDuration : 0} min.`;
        }
        
        // Opens the Add/Edit modal, pre-filling data if editing
        function openAddAppointmentModal(date, hour, minute, maxDurationPossible, appointmentToEditData = null) {
            populateTimeSelects(); // Ensure selects are populated
            if (appointmentToEditData) { // Edit Mode
                currentAppointmentContext = { 
                    date: date, // Date object of the appointment
                    initialHour: appointmentToEditData.startHour, 
                    initialMinute: appointmentToEditData.startMinute,
                    currentSelectedHour: appointmentToEditData.startHour,
                    currentSelectedMinute: appointmentToEditData.startMinute,
                    editingAppointmentId: appointmentToEditData.id,
                    originalDateKey: formatDateKey(date) // Store original date key
                };
                // Set modal title and button text for editing
                modalTitleEl.textContent = "Editar Cita";
                saveAppointmentBtn.textContent = "Actualizar Cita";
                // Pre-fill form fields
                appointmentTitleInput.value = appointmentToEditData.title;
                appointmentStartHourSelect.value = appointmentToEditData.startHour;
                appointmentStartMinuteSelect.value = appointmentToEditData.startMinute;
                appointmentDurationInput.value = appointmentToEditData.duration;
                appointmentDetailsInput.value = appointmentToEditData.details || '';
                // Calculate initial max duration excluding the current appointment
                currentAppointmentContext.currentMaxDuration = calculateContiguousFreeTime(date, appointmentToEditData.startHour, appointmentToEditData.startMinute, appointmentToEditData.id);
            } else { // Add Mode
                currentAppointmentContext = { 
                    date: date, initialHour: hour, initialMinute: minute,
                    currentSelectedHour: hour, currentSelectedMinute: minute,
                    currentMaxDuration: maxDurationPossible,
                    editingAppointmentId: null,
                    originalDateKey: null
                };
                // Set modal title and button text for adding
                modalTitleEl.textContent = "Añadir Nueva Cita";
                saveAppointmentBtn.textContent = "Guardar Cita";
                // Clear form fields
                appointmentTitleInput.value = '';
                appointmentDetailsInput.value = ''; 
                // Set initial time and duration
                appointmentStartHourSelect.value = hour;
                appointmentStartMinuteSelect.value = minute;
                appointmentDurationInput.value = Math.min(30, maxDurationPossible > 0 ? maxDurationPossible : 30); // Default 30min or max
                currentAppointmentContext.currentMaxDuration = maxDurationPossible; // Already calculated
            }
            
            // Set the max attribute for duration input
            appointmentDurationInput.max = currentAppointmentContext.currentMaxDuration > 0 ? currentAppointmentContext.currentMaxDuration : 1;
            updateAppointmentTimeInfo(); // Update info text
            addAppointmentModalEl.classList.add('active'); // Show modal
            appointmentTitleInput.focus(); // Focus on title input
        }

        // Closes the Add/Edit modal
        function closeAddAppointmentModal() {
            addAppointmentModalEl.classList.remove('active');
            currentAppointmentContext = null; // Clear context
        }

        // Saves a new appointment or updates an existing one
        function saveCurrentAppointment() {
            if (!currentAppointmentContext) return;
            // Get data from form
            const title = appointmentTitleInput.value.trim();
            const duration = parseInt(appointmentDurationInput.value, 10);
            const details = appointmentDetailsInput.value.trim();
            // Get selected start time from context (updated by selects)
            const startHour = currentAppointmentContext.currentSelectedHour;
            const startMinute = currentAppointmentContext.currentSelectedMinute;
            const targetDate = currentAppointmentContext.date; 
            const targetDateKey = formatDateKey(targetDate);

            // --- Validations ---
            if (!title) {
                alert('Por favor, introduce un título para la cita.');
                appointmentTitleInput.focus(); return;
            }
            if (isNaN(duration) || duration <= 0) {
                alert('Por favor, introduce una duración válida en minutos.');
                appointmentDurationInput.focus(); return;
            }
            // Validate duration against the max calculated for the selected start time
            if (duration > currentAppointmentContext.currentMaxDuration) {
                alert(`La duración (${duration}m) no puede exceder los ${currentAppointmentContext.currentMaxDuration} minutos disponibles para la hora de inicio seleccionada.`);
                appointmentDurationInput.focus(); return;
            }
            
            // Ensure the date key exists in appointments object
            if (!appointments[targetDateKey]) appointments[targetDateKey] = [];
            
            // --- Conflict Check ---
            const newApptStart = startHour * 60 + startMinute;
            const newApptEnd = newApptStart + duration;
            for (const existingAppt of appointments[targetDateKey]) {
                // Skip checking against itself if editing
                if (currentAppointmentContext.editingAppointmentId && existingAppt.id === currentAppointmentContext.editingAppointmentId) {
                    continue; 
                }
                const existingApptStart = existingAppt.startHour * 60 + existingAppt.startMinute;
                const existingApptEnd = existingApptStart + existingAppt.duration;
                // Check for overlap
                if (Math.max(newApptStart, existingApptStart) < Math.min(newApptEnd, existingApptEnd)) {
                     alert('Conflicto de horario detectado. Esta cita se superpone con otra existente.'); return;
                }
            }
            
            // --- Save or Update ---
            let wasEditing = false; 
            let originalDateKeyForRender = null; 
            if (currentAppointmentContext.editingAppointmentId) { // Update existing appointment
                wasEditing = true;
                originalDateKeyForRender = currentAppointmentContext.originalDateKey;
                const apptIndex = appointments[currentAppointmentContext.originalDateKey].findIndex(appt => appt.id === currentAppointmentContext.editingAppointmentId);
                if (apptIndex > -1) {
                    // Check if the date changed during edit
                    if (targetDateKey === currentAppointmentContext.originalDateKey) {
                        // Date didn't change, update in place
                        appointments[targetDateKey][apptIndex] = {
                            ...appointments[targetDateKey][apptIndex], // Keep original ID and color
                            title: title, 
                            startHour: startHour, 
                            startMinute: startMinute,
                            duration: duration, 
                            details: details 
                        };
                    } else { 
                        // Date changed, move the appointment
                        // 1. Create the updated appointment data
                        const newAppointmentData = {
                            ...appointments[currentAppointmentContext.originalDateKey][apptIndex], 
                            title: title, startHour: startHour, startMinute: startMinute,
                            duration: duration, details: details 
                        };
                        // 2. Add to the new date's array
                        if (!appointments[targetDateKey]) { appointments[targetDateKey] = []; }
                        appointments[targetDateKey].push(newAppointmentData);
                        // 3. Remove from the original date's array
                        appointments[currentAppointmentContext.originalDateKey].splice(apptIndex, 1);
                        // 4. Clean up original date array if empty
                        if (appointments[currentAppointmentContext.originalDateKey].length === 0) {
                            delete appointments[currentAppointmentContext.originalDateKey];
                        }
                    }
                } else {
                    console.error("Error: No se encontró la cita para editar.");
                    // Optionally show an error to the user
                }
            } else { // Add new appointment
                const newColor = distinctColors[nextColorIndex];
                nextColorIndex = (nextColorIndex + 1) % distinctColors.length;
                localStorage.setItem('nextColorIndex', nextColorIndex.toString());
                appointments[targetDateKey].push({
                    id: Date.now().toString() + Math.random().toString(36).substring(2,7), 
                    title: title, startHour: startHour, startMinute: startMinute,
                    duration: duration, color: newColor, details: details 
                });
            }

            saveAppointmentsToLocalStorage();
            const contextDateKey = targetDateKey; // Store date key before closing modal
            const contextOriginalDateKey = originalDateKeyForRender; // Store original date key if editing
            
            closeAddAppointmentModal(); // Close modal first

            // --- Re-render Views ---
            const agendaWasVisible = !agendaViewEl.classList.contains('hidden');
            renderMonthView(); // Always update month view dots

            if (agendaWasVisible) { // If agenda view was active, keep it active
                monthViewEl.classList.add('hidden');
                agendaViewEl.classList.remove('hidden');
                // Re-render agenda view if the change affected the currently selected date
                // or the original date (if editing and date changed)
                if (formatDateKey(selectedAgendaDate) === contextDateKey || 
                    (wasEditing && contextOriginalDateKey && formatDateKey(selectedAgendaDate) === contextOriginalDateKey) ) {
                    renderAgendaView();
                }
            }
        }

        // Opens the View Details modal
        function openViewAppointmentDetailsModal(appointmentData, dateKeyForAppointment) {
            // Store the appointment data and its date key for edit/delete actions
            appointmentContextForDetails = { data: appointmentData, dateKey: dateKeyForAppointment }; 
            // Populate modal fields
            viewAppointmentTitleEl.textContent = appointmentContextForDetails.data.title;
            const startTimeStr = `${String(appointmentContextForDetails.data.startHour).padStart(2, '0')}:${String(appointmentContextForDetails.data.startMinute).padStart(2, '0')}`;
            const endTimeStr = formatEndTime(appointmentContextForDetails.data.startHour, appointmentContextForDetails.data.startMinute, appointmentContextForDetails.data.duration);
            viewAppointmentTimeEl.textContent = `Hora: ${startTimeStr} - ${endTimeStr}`;
            viewAppointmentDurationEl.textContent = `Duración: ${appointmentContextForDetails.data.duration} minutos`;
            viewAppointmentDetailsContentEl.textContent = appointmentContextForDetails.data.details || "No hay detalles adicionales.";
            // Show the modal
            viewAppointmentDetailsModalEl.classList.add('active');
        }
        // Closes the View Details modal
        function closeViewAppointmentDetailsModal() {
            viewAppointmentDetailsModalEl.classList.remove('active');
            appointmentContextForDetails = null; // Clear context
        }
        
        // Handles the delete confirmation and calls deleteAppointment
        function handleDeleteAppointment(apptToDelete, dateKeyOfAppointment) { 
            if (!apptToDelete || !dateKeyOfAppointment) {
                 console.error("Error al eliminar: Faltan datos de la cita o la fecha.");
                 alert("Error: No se pudo identificar la cita a eliminar."); 
                 return;
            }
            // Ask for confirmation
            if (confirm(`¿Estás seguro de que quieres eliminar la cita "${apptToDelete.title}"?`)) {
                console.log('Eliminando cita:', apptToDelete.id, 'en fecha:', dateKeyOfAppointment); 
                deleteAppointment(apptToDelete.id, dateKeyOfAppointment); // Call the actual delete function
                closeViewAppointmentDetailsModal(); // Close the details modal if open
            }
        }

        // Deletes an appointment from the specified dateKey
        function deleteAppointment(appointmentId, dateKey) { 
            console.log('Función deleteAppointment llamada con ID:', appointmentId, 'y dateKey:', dateKey); 
            if (!appointments[dateKey]) {
                console.warn("Intento de eliminar cita en una fecha inexistente:", dateKey);
                return; // Exit if the date key doesn't exist
            }
            const initialLength = appointments[dateKey].length;
            // Filter out the appointment with the matching ID
            appointments[dateKey] = appointments[dateKey].filter(appt => appt.id !== appointmentId);
            
            // Check if an appointment was actually removed
            if (appointments[dateKey].length < initialLength) { 
                console.log('Cita eliminada exitosamente.'); 
                // If the day's array is now empty, remove the date key entirely
                if (appointments[dateKey].length === 0) {
                    delete appointments[dateKey]; 
                }
                saveAppointmentsToLocalStorage(); // Save changes
                // --- Re-render Views ---
                const agendaWasVisible = !agendaViewEl.classList.contains('hidden');
                renderMonthView(); // Always update month view dots
                if (agendaWasVisible) { // If agenda view was active, keep it active
                    monthViewEl.classList.add('hidden');
                    agendaViewEl.classList.remove('hidden');
                    // Re-render agenda view only if the deleted appointment was on the currently selected date
                    if (formatDateKey(selectedAgendaDate) === dateKey) { 
                        renderAgendaView();
                    }
                }
            } else {
                // This shouldn't happen if the ID and dateKey were correct
                console.warn("No se pudo encontrar la cita para eliminar con ID:", appointmentId, "en la fecha", dateKey);
                 alert("Error: No se pudo encontrar la cita para eliminar."); 
            }
        }

        // Saves the entire appointments object to localStorage
        function saveAppointmentsToLocalStorage() {
            localStorage.setItem('appointments', JSON.stringify(appointments));
            localStorage.setItem('nextColorIndex', nextColorIndex.toString()); // Save color index too
        }
        // Formats a Date object into "YYYY-MM-DD" string
        function formatDateKey(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        // Parses a "YYYY-MM-DD" string back into a Date object
        function parseDateKey(dateKey) { 
            const parts = dateKey.split('-');
            // Month is 0-indexed in Date constructor
            return new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
        }

        // --- Search Logic ---
        function performSearch() {
            const query = searchInput.value.trim().toLowerCase();
            if (!query) {
                searchResultsContainerEl.innerHTML = '<p class="text-slate-500">Por favor, introduce un término de búsqueda.</p>';
                openSearchResultsModal();
                return;
            }
            const allFoundAppointments = [];
            // Iterate through all dates and appointments
            Object.keys(appointments).forEach(dateKey => {
                appointments[dateKey].forEach(appt => {
                    // Check if title includes the query (case-insensitive)
                    if (appt.title.toLowerCase().includes(query)) {
                        // Add the dateKey to the found appointment object
                        allFoundAppointments.push({...appt, dateKey: dateKey }); 
                    }
                });
            });
            displaySearchResults(allFoundAppointments); // Display results
            openSearchResultsModal(); // Show results modal
        }
        function displaySearchResults(foundAppointments) {
            searchResultsContainerEl.innerHTML = ''; // Clear previous results
            if (foundAppointments.length === 0) {
                searchResultsContainerEl.innerHTML = '<p class="text-slate-500">No se encontraron citas con ese título.</p>';
                return;
            }
            // Sort results chronologically
            foundAppointments.sort((a,b) => { 
                const dateA = parseDateKey(a.dateKey).getTime();
                const dateB = parseDateKey(b.dateKey).getTime();
                if (dateA !== dateB) return dateA - dateB; // Sort by date first
                const timeA = a.startHour * 60 + a.startMinute;
                const timeB = b.startHour * 60 + b.startMinute;
                return timeA - timeB; // Then sort by time
            });
            // Create HTML elements for each result
            foundAppointments.forEach(appt => {
                const resultItem = document.createElement('div');
                resultItem.classList.add('search-result-item');
                // Title
                const titleEl = document.createElement('p');
                titleEl.classList.add('font-semibold', 'text-indigo-600', 'text-lg');
                titleEl.textContent = appt.title;
                resultItem.appendChild(titleEl);
                // Date
                const dateObj = parseDateKey(appt.dateKey); 
                const dateEl = document.createElement('p');
                dateEl.classList.add('text-sm', 'text-slate-500');
                dateEl.textContent = `Fecha: ${dateObj.toLocaleDateString('es-ES', { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric' })}`;
                resultItem.appendChild(dateEl);
                // Time
                const timeEl = document.createElement('p');
                timeEl.classList.add('text-sm', 'text-slate-500');
                const startTimeStr = `${String(appt.startHour).padStart(2, '0')}:${String(appt.startMinute).padStart(2, '0')}`;
                const endTimeStr = formatEndTime(appt.startHour, appt.startMinute, appt.duration);
                timeEl.textContent = `Hora: ${startTimeStr} - ${endTimeStr}`;
                resultItem.appendChild(timeEl);
                // Details Snippet (if exists)
                if (appt.details) {
                    const detailsEl = document.createElement('p');
                    detailsEl.classList.add('text-sm', 'text-slate-600', 'mt-2', 'whitespace-pre-wrap');
                    const snippetLength = 100; // Max length for snippet
                    detailsEl.textContent = `Detalles: ${appt.details.length > snippetLength ? appt.details.substring(0, snippetLength) + '...' : appt.details}`;
                    resultItem.appendChild(detailsEl);
                }
                // Click listener to open the details modal for this result
                resultItem.addEventListener('click', () => {
                    closeSearchResultsModal(); 
                    openViewAppointmentDetailsModal(appt, appt.dateKey); // Pass dateKey
                });
                searchResultsContainerEl.appendChild(resultItem);
            });
        }
        function openSearchResultsModal() {
            searchResultsModalEl.classList.add('active');
        }
        function closeSearchResultsModal() {
            searchResultsModalEl.classList.remove('active');
        }

        // --- Event Listeners Setup ---
        // Month Navigation
        document.getElementById('prevMonthBtn').addEventListener('click', () => {
            currentDisplayDate.setMonth(currentDisplayDate.getMonth() - 1); renderMonthView();
        });
        document.getElementById('nextMonthBtn').addEventListener('click', () => {
            currentDisplayDate.setMonth(currentDisplayDate.getMonth() + 1); renderMonthView();
        });
        // View Toggles
        document.getElementById('showMonthViewBtn').addEventListener('click', () => {
            currentDisplayDate = new Date(selectedAgendaDate); renderMonthView();
        });
        document.getElementById('showAgendaViewBtn').addEventListener('click', () => {
            selectedAgendaDate = new Date(); selectedAgendaDate.setHours(0,0,0,0); renderAgendaView();
        });
        // Add/Edit Modal Actions
        saveAppointmentBtn.addEventListener('click', saveCurrentAppointment);
        document.getElementById('cancelAddAppointment').addEventListener('click', closeAddAppointmentModal);
        // View Details Modal Actions
        document.getElementById('closeViewAppointmentDetails').addEventListener('click', closeViewAppointmentDetailsModal);
        editAppointmentBtn.addEventListener('click', () => { // Edit button in details modal
            if (appointmentContextForDetails) { 
                const apptData = appointmentContextForDetails.data;
                const apptDateKey = appointmentContextForDetails.dateKey; 
                const dateOfAppointment = parseDateKey(apptDateKey); 
                // Open the add/edit modal in edit mode
                openAddAppointmentModal(dateOfAppointment, apptData.startHour, apptData.startMinute, 0, apptData);
                closeViewAppointmentDetailsModal(); // Close details modal
            }
        });
        deleteAppointmentFromDetailsBtn.addEventListener('click', () => { // Delete button in details modal
             if (appointmentContextForDetails) {
                handleDeleteAppointment(appointmentContextForDetails.data, appointmentContextForDetails.dateKey);
             }
        });
        // Search Actions
        searchIconBtn.addEventListener('click', () => { // Toggle search bar visibility
            searchBarContainer.classList.toggle('hidden');
            if (!searchBarContainer.classList.contains('hidden')) {
                searchInput.focus(); // Focus input when shown
            }
        });
        searchAppointmentBtn.addEventListener('click', performSearch); // Search button click
        searchInput.addEventListener('keypress', (event) => { // Search on Enter key
            if (event.key === 'Enter') performSearch();
        });
        closeSearchResultsModalBtn.addEventListener('click', closeSearchResultsModal); // Close search results
        // Update time info when start time selects change
        appointmentStartHourSelect.addEventListener('change', updateAppointmentTimeInfo);
        appointmentStartMinuteSelect.addEventListener('change', updateAppointmentTimeInfo);
        // Global keydown listener (for Escape key to close modals)
        window.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
                if (addAppointmentModalEl.classList.contains('active')) closeAddAppointmentModal();
                if (viewAppointmentDetailsModalEl.classList.contains('active')) closeViewAppointmentDetailsModal();
                if (searchResultsModalEl.classList.contains('active')) closeSearchResultsModal();
            }
        });
        // Click outside modals to close
        addAppointmentModalEl.addEventListener('click', (event) => { 
            if (event.target === addAppointmentModalEl) closeAddAppointmentModal();
        });
        viewAppointmentDetailsModalEl.addEventListener('click', (event) => { 
            if (event.target === viewAppointmentDetailsModalEl) closeViewAppointmentDetailsModal();
        });
        searchResultsModalEl.addEventListener('click', (event) => { 
            if (event.target === searchResultsModalEl) closeSearchResultsModal();
        });

        // --- Initialization ---
        populateTimeSelects(); // Populate time selects on load
        renderMonthView(); // Initial render

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('sw.js') // Use relative path
              .then(registration => console.log('ServiceWorker registrado con éxito:', registration.scope))
              .catch(error => console.log('Error al registrar ServiceWorker:', error));
          });
        }
    </script>

</body>
</html>
